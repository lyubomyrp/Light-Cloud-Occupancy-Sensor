###############################################################################
#                                                                             #
# IAR C/C++ Compiler V5.52.1.50724/W32 for MSP430       07/Jul/2014  17:16:20 #
# Copyright 1996-2013 IAR Systems AB.                                         #
#                                                                             #
#    __rt_version  =  3                                                       #
#    __double_size =  32                                                      #
#    __reg_r4      =  free                                                    #
#    __reg_r5      =  free                                                    #
#    __pic         =  no                                                      #
#    __core        =  430                                                     #
#    Source file   =  C:\Users\a0283112\Desktop\Submeter i2040                #
#                     8k_DC_THD_AUTO_OSR_IAR5.5\emeter-metrology\src\metrolog #
#                     y-setup.c                                               #
#    Command line  =  "C:\Users\a0283112\Desktop\Submeter i2040               #
#                     8k_DC_THD_AUTO_OSR_IAR5.5\emeter-metrology\src\metrolog #
#                     y-setup.c" -D __MSP430__ -lCN                           #
#                     "C:\Users\a0283112\Desktop\Submeter i2040               #
#                     8k_DC_THD_AUTO_OSR_IAR5.5\emeter-metrology\emeter-metro #
#                     logy-i2041\Debug\List\" -lA                             #
#                     "C:\Users\a0283112\Desktop\Submeter i2040               #
#                     8k_DC_THD_AUTO_OSR_IAR5.5\emeter-metrology\emeter-metro #
#                     logy-i2041\Debug\List\" -o                              #
#                     "C:\Users\a0283112\Desktop\Submeter i2040               #
#                     8k_DC_THD_AUTO_OSR_IAR5.5\emeter-metrology\emeter-metro #
#                     logy-i2041\Debug\Obj\" --debug -D__MSP430I2041__ -e     #
#                     --double=32 --dlib_config "C:\Program Files (x86)\IAR   #
#                     Systems\Embedded Workbench                              #
#                     6.5_0\430\LIB\DLIB\dl430fn.h" --library_module -I       #
#                     "C:\Users\a0283112\Desktop\Submeter i2040               #
#                     8k_DC_THD_AUTO_OSR_IAR5.5\emeter-metrology\emeter-metro #
#                     logy-i2041/../../emeter-toolkit/include\" -I            #
#                     "C:\Users\a0283112\Desktop\Submeter i2040               #
#                     8k_DC_THD_AUTO_OSR_IAR5.5\emeter-metrology\emeter-metro #
#                     logy-i2041/../include\" -I                              #
#                     "C:\Users\a0283112\Desktop\Submeter i2040               #
#                     8k_DC_THD_AUTO_OSR_IAR5.5\emeter-metrology\emeter-metro #
#                     logy-i2041\" -Ohs --multiplier=16s                      #
#    List file     =  C:\Users\a0283112\Desktop\Submeter i2040                #
#                     8k_DC_THD_AUTO_OSR_IAR5.5\emeter-metrology\emeter-metro #
#                     logy-i2041\Debug\List\metrology-setup.lst               #
#    Object file   =  C:\Users\a0283112\Desktop\Submeter i2040                #
#                     8k_DC_THD_AUTO_OSR_IAR5.5\emeter-metrology\emeter-metro #
#                     logy-i2041\Debug\Obj\metrology-setup.r43                #
#                                                                             #
#                                                                             #
###############################################################################

C:\Users\a0283112\Desktop\Submeter i2040 8k_DC_THD_AUTO_OSR_IAR5.5\emeter-metrology\src\metrology-setup.c
      1          /*******************************************************************************
      2           *  metrology-setup.c -
      3           *
      4           *  Copyright (C) 2011 Texas Instruments Incorporated - http://www.ti.com/ 
      5           * 
      6           *  Redistribution and use in source and binary forms, with or without 
      7           *  modification, are permitted provided that the following conditions 
      8           *  are met:
      9           *
     10           *    Redistributions of source code must retain the above copyright 
     11           *    notice, this list of conditions and the following disclaimer.
     12           *
     13           *    Redistributions in binary form must reproduce the above copyright
     14           *    notice, this list of conditions and the following disclaimer in the 
     15           *    documentation and/or other materials provided with the   
     16           *    distribution.
     17           *
     18           *    Neither the name of Texas Instruments Incorporated nor the names of
     19           *    its contributors may be used to endorse or promote products derived
     20           *    from this software without specific prior written permission.
     21           *
     22           *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
     23           *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
     24           *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
     25           *  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT 
     26           *  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, 
     27           *  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
     28           *  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
     29           *  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
     30           *  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
     31           *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
     32           *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
     33           *
     34           ******************************************************************************/
     35          
     36          #include <inttypes.h>
     37          #include <stdlib.h>
     38          #if !defined(__MSP430__)
     39          #include <stdio.h>
     40          #include <fcntl.h>
     41          #include <unistd.h>
     42          #endif
     43          #if defined(__GNUC__)
     44          #include <signal.h>
     45          #endif
     46          #include <math.h>
     47          
     48          #include <emeter-toolkit.h>

   \                                 In  segment DATA16_AN, at 0xb0
   \   unsigned char volatile SD24INCTL0
   \                     SD24INCTL0:
   \   000000                DS8 1

   \                                 In  segment DATA16_AN, at 0xb1
   \   unsigned char volatile SD24INCTL1
   \                     SD24INCTL1:
   \   000000                DS8 1

   \                                 In  segment DATA16_AN, at 0xb2
   \   unsigned char volatile SD24INCTL2
   \                     SD24INCTL2:
   \   000000                DS8 1

   \                                 In  segment DATA16_AN, at 0xb8
   \   unsigned char volatile SD24PRE0
   \                     SD24PRE0:
   \   000000                DS8 1

   \                                 In  segment DATA16_AN, at 0xb9
   \   unsigned char volatile SD24PRE1
   \                     SD24PRE1:
   \   000000                DS8 1

   \                                 In  segment DATA16_AN, at 0xba
   \   unsigned char volatile SD24PRE2
   \                     SD24PRE2:
   \   000000                DS8 1

   \                                 In  segment DATA16_AN, at 0x100
   \   unsigned short volatile SD24CTL
   \                     SD24CTL:
   \   000000                DS8 2

   \                                 In  segment DATA16_AN, at 0x102
   \   unsigned short volatile SD24CCTL0
   \                     SD24CCTL0:
   \   000000                DS8 2

   \                                 In  segment DATA16_AN, at 0x104
   \   unsigned short volatile SD24CCTL1
   \                     SD24CCTL1:
   \   000000                DS8 2

   \                                 In  segment DATA16_AN, at 0x106
   \   unsigned short volatile SD24CCTL2
   \                     SD24CCTL2:
   \   000000                DS8 2

   \                                 In  segment DATA16_AN, at 0x160
   \   unsigned short volatile TA0CTL
   \                     TA0CTL:
   \   000000                DS8 2

   \                                 In  segment DATA16_AN, at 0x162
   \   unsigned short volatile TA0CCTL0
   \                     TA0CCTL0:
   \   000000                DS8 2
     49          
     50          #include "emeter-metrology.h"
     51          #include "metrology-structs.h"
     52          #include "metrology-flash.h"
     53          
     54          #if defined(WIRE_RESISTANCE_COMPENSATE)
     55          extern uint32_t resistance_scaling;
     56          #endif
     57          
     58          #if defined(CAPACITOR_COMPENSATE_ON)
     59          extern uint32_t capacitance_scaling;
     60          #endif
     61          
     62          #if defined(__MSP430_HAS_SD16_2__)  ||  defined(__MSP430_HAS_SD16_3__)
     63          #define SD16CONF0_FUDGE     0x70
     64          #define SD16CONF1_FUDGE     0x48    //0x38
     65          #endif
     66          
     67          #define sd_resolve_x(x) THAT_WAS_ ## x
     68          #define sd_resolve(x) sd_resolve_x(x)
     69          
     70          #if defined(__MSP430_HAS_SD24_B__)
     71          #define sd_set_normal_live_current_mode_(a) \
     72              sd_xxxx_reg(SD_INCTL_, a) = SD_LIVE_CURRENT_GAIN; \
     73              sd_xxxx_reg(SD_CCTL_, a) = SD_DF_1 | SD24SCS_4; \
     74              sd_xxxx_reg(SD_OSR_, a) = OSR - 1; \
     75              sd_xxxx_reg(SD_PRE_, a) = 0;
     76          #define sd_set_normal_live_current_mode(a) sd_set_normal_live_current_mode_(a)
     77          
     78          /*
     79          #define sd_set_limp_live_current_mode_(a) \
     80              sd_xxxx_reg(SD_INCTL_, a) = SD_LIVE_CURRENT_GAIN; \
     81              sd_xxxx_reg(SD_CCTL_, a) = SD_DF_1 | SD_SNGL | SD_GRP; \
     82              sd_xxxx_reg(SD_OSR_, a) = 32 - 1; \
     83              sd_xxxx_reg(SD_PRE_, a) = 0;
     84          #define sd_set_limp_live_current_mode(a) sd_set_limp_live_current_mode_(a)
     85          */
     86          
     87          #define sd_set_idle_live_current_mode_(a) \
     88              sd_xxxx_reg(SD_INCTL_, a) = 0; \
     89              sd_xxxx_reg(SD_CCTL_, a) = 0; \
     90              sd_xxxx_reg(SD_OSR_, a) = 0; \
     91              sd_xxxx_reg(SD_PRE_, a) = 0;
     92          #define sd_set_idle_live_current_mode(a) sd_set_idle_live_current_mode_(a)
     93          
     94          
     95          #define sd_set_normal_neutral_current_mode_(a) \
     96              sd_xxxx_reg(SD_INCTL_, a) = SD_NEUTRAL_CURRENT_GAIN; \
     97              sd_xxxx_reg(SD_CCTL_, a) = SD_DF_1 | SD24SCS_4; \
     98              sd_xxxx_reg(SD_OSR_, a) = OSR - 1; \
     99              sd_xxxx_reg(SD_PRE_, a) = 0;
    100          #define sd_set_normal_neutral_current_mode(a) sd_set_normal_neutral_current_mode_(a)
    101          
    102          /*
    103          #define sd_set_limp_neutral_current_mode_(a) \
    104              sd_xxxx_reg(SD_INCTL_, a) = SD_NEUTRAL_CURRENT_GAIN; \
    105              sd_xxxx_reg(SD_CCTL_, a) = SD_DF_1 | SD_SNGL | SD_GRP; \
    106              sd_xxxx_reg(SD_OSR_, a) = 32 - 1; \
    107              sd_xxxx_reg(SD_PRE_, a) = 0;
    108          #define sd_set_limp_neutral_current_mode(a) sd_set_limp_neutral_current_mode_(a)
    109          */
    110          
    111          #define sd_set_idle_neutral_current_mode_(a) \
    112              sd_xxxx_reg(SD_INCTL_, a) = 0; \
    113              sd_xxxx_reg(SD_CCTL_, a) = 0; \
    114              sd_xxxx_reg(SD_OSR_, a) = 0; \
    115              sd_xxxx_reg(SD_PRE_, a) = 0;
    116          #define sd_set_idle_neutral_current_mode(a) sd_set_idle_neutral_current_mode_(a)
    117          
    118          #define sd_set_normal_voltage_mode_(a) \
    119              sd_xxxx_reg(SD_INCTL_, a) = SD_VOLTAGE_GAIN; \
    120              sd_xxxx_reg(SD_CCTL_, a) = SD_DF_1 | SD24ALGN | SD24SCS_4; \
    121              sd_xxxx_reg(SD_OSR_, a) = OSR - 1; \
    122              sd_xxxx_reg(SD_PRE_, a) = 0;
    123          #define sd_set_normal_voltage_mode(a) sd_set_normal_voltage_mode_(a)
    124          
    125          /*
    126          #define sd_set_limp_voltage_mode_(a) \
    127              sd_xxxx_reg(SD_INCTL_, a) = SD_VOLTAGE_GAIN; \
    128              sd_xxxx_reg(SD_CCTL_, a) = SD_DF_1 | SD_SNGL | SD_GRP; \
    129              sd_xxxx_reg(SD_OSR_, a) = 32 - 1; \
    130              sd_xxxx_reg(SD_PRE_, a) = 0;
    131          #define sd_set_limp_voltage_mode(a) sd_set_limp_voltage_mode_(a)
    132          */
    133          
    134          #define sd_set_idle_voltage_mode_(a) \
    135              sd_xxxx_reg(SD_INCTL_, a) = 0; \
    136              sd_xxxx_reg(SD_CCTL_, a) = 0; \
    137              sd_xxxx_reg(SD_OSR_, a) = 0; \
    138              sd_xxxx_reg(SD_PRE_, a) = 0;
    139          #define sd_set_idle_voltage_mode(a) sd_set_idle_voltage_mode_(a)
    140          
    141          #else
    142          
    143          #define SD_OSR__(x) SD_OSR_ ## x
    144          #define SD_OSR(x)  SD_OSR__ (x)
    145          
    146          #define sd_set_normal_live_current_mode_(a) \
    147              sd_xxxx_reg(SD_INCTL_, a) = SD_INCH_CURRENT | SD_LIVE_CURRENT_GAIN; \
    148                sd_xxxx_reg(SD_CCTL_, a) = (SD_OSR (OSR)) | SD_DF | SD_GRP | SD_IE; \
    149              sd_xxxx_reg(SD_PRE_, a) = 0;
    150          #define sd_set_normal_live_current_mode(a) sd_set_normal_live_current_mode_(a)
    151          
    152          /*
    153          #define sd_set_limp_live_current_mode_(a) \
    154              sd_xxxx_reg(SD_INCTL_, a) = SD_INCH_CURRENT | SD_LIVE_CURRENT_GAIN; \
    155              sd_xxxx_reg(SD_CCTL_, a) = SD_OSR_32 | SD_DF | SD_SNGL | SD_GRP | SD_IE; \
    156              sd_xxxx_reg(SD_PRE_, a) = 0;
    157          #define sd_set_limp_live_current_mode(a) sd_set_limp_live_current_mode_(a)
    158          */
    159          
    160          #define sd_set_idle_live_current_mode_(a) \
    161              sd_xxxx_reg(SD_INCTL_, a) = 0; \
    162              sd_xxxx_reg(SD_CCTL_, a) = 0; \
    163              sd_xxxx_reg(SD_PRE_, a) = 0;
    164          #define sd_set_idle_live_current_mode(a) sd_set_idle_live_current_mode_(a)
    165          
    166          #define sd_set_normal_neutral_current_mode_(a) \
    167              sd_xxxx_reg(SD_INCTL_, a) = SD_INCH_CURRENT | SD_NEUTRAL_CURRENT_GAIN; \
    168                sd_xxxx_reg(SD_CCTL_, a) = (SD_OSR (OSR))  | SD_DF | SD_GRP | SD_IE; \
    169              sd_xxxx_reg(SD_PRE_, a) = 0;
    170          #define sd_set_normal_neutral_current_mode(a) sd_set_normal_neutral_current_mode_(a)
    171          
    172          /*
    173          #define sd_set_limp_neutral_current_mode_(a) \
    174              sd_xxxx_reg(SD_INCTL_, a) = SD_INCH_CURRENT | SD_NEUTRAL_CURRENT_GAIN; \
    175              sd_xxxx_reg(SD_CCTL_, a) = SD_OSR_32 | SD_DF | SD_SNGL | SD_GRP | SD_IE; \
    176              sd_xxxx_reg(SD_PRE_, a) = 0;
    177          #define sd_set_limp_neutral_current_mode(a) sd_set_limp_neutral_current_mode_(a)
    178          */
    179          
    180          #define sd_set_idle_neutral_current_mode_(a) \
    181              sd_xxxx_reg(SD_INCTL_, a) = 0; \
    182              sd_xxxx_reg(SD_CCTL_, a) = 0; \
    183              sd_xxxx_reg(SD_PRE_, a) = 0;
    184          #define sd_set_idle_neutral_current_mode(a) sd_set_idle_neutral_current_mode_(a)
    185          
    186          #define sd_set_normal_voltage_mode_(a) \
    187              sd_xxxx_reg(SD_INCTL_, a) = SD_INCH_VOLTAGE | SD_VOLTAGE_GAIN; \
    188                sd_xxxx_reg(SD_CCTL_, a) = (SD_OSR (OSR)) | SD_DF | SD_GRP; \
    189              sd_xxxx_reg(SD_PRE_, a) = 0;
    190          #define sd_set_normal_voltage_mode(a) sd_set_normal_voltage_mode_(a)
    191          
    192          /*
    193          #define sd_set_limp_voltage_mode_(a) \
    194              sd_xxxx_reg(SD_INCTL_, a) = SD_INCH_VOLTAGE | SD_VOLTAGE_GAIN; \
    195              sd_xxxx_reg(SD_CCTL_, a) = SD_OSR_32 | SD_DF | SD_SNGL | SD_GRP | SD_IE; \
    196              sd_xxxx_reg(SD_PRE_, a) = 0;
    197          #define sd_set_limp_voltage_mode(a) sd_set_limp_voltage_mode_(a)
    198          */
    199          
    200          #define sd_set_idle_voltage_mode_(a) \
    201              sd_xxxx_reg(SD_INCTL_, a) = 0; \
    202              sd_xxxx_reg(SD_CCTL_, a) = 0; \
    203              sd_xxxx_reg(SD_PRE_, a) = 0;
    204          #define sd_set_idle_voltage_mode(a) sd_set_idle_voltage_mode_(a)
    205          
    206          
    207          #define sd_set_normal_temperature_mode_(a) \
    208              sd_xxxx_reg(SD_INCTL_, a) = SD_INCH_TEMPERATURE | SD_GAIN_TEMPERATURE; \
    209                sd_xxxx_reg(SD_CCTL_, a) = (SD_OSR (OSR)) | SD_DF | SD_GRP; \
    210              sd_xxxx_reg(SD_PRE_, a) = 0;
    211          #define sd_set_normal_temperature_mode(a) sd_set_normal_temperature_mode_(a)
    212          #endif
    213          
    214          #if NUM_PHASES > 1  &&  defined(__MSP430_HAS_SD24_B3__)  &&  defined(__MSP430_HAS_ADC10_A__)
    215          extern int16_t dma_adc_buffer[6];
    216          //extern int16_t dma_adc_buffer[NUM_PHASES];
    217          #endif
    218          
    219          /*
    220           * Analog front-end initialization routine.
    221           *
    222           * Configures the sigma-delta ADC module as analog front-end for
    223           * a tamper-resistant meter using a current transformer and a
    224           * shunt as current sensors (see configuration of channel 0 and 1).
    225           */

   \                                 In  segment CODE, align 2
    226          void metrology_init_analog_front_end_normal_mode(void)
   \                     metrology_init_analog_front_end_normal_mode:
    227          {
    228          #if NUM_PHASES > 1
    229              int i;
    230          #endif
    231          
    232              /* The general configuration of the analog front-end,
    233                 that applies to all channels: clock selection (SMCLK) and divider
    234                 settings (depending on SMCLK frequency) and reference voltage
    235                 selections. */
    236          #if defined(__MSP430_HAS_SD24_B__)
    237              /* Enable the voltage reference at 2.0V */
    238              REFCTL0 = REFMSTR | REFVSEL_1 | REFON;
    239              SD_CTL1 &= ~SD24GRP0SC;
    240          #else
    241              sd_xxxx_reg(SD_CCTL_, PHASE_1_VOLTAGE_ADC_CHANNEL) &= ~SD_SC;
   \   000000   A2C30201     BIC.W   #0x2, &0x102
    242              sd_xxxx_reg(SD_CCTL_, PHASE_1_CURRENT_ADC_CHANNEL) &= ~SD_SC;
   \   000004   A2C30401     BIC.W   #0x2, &0x104
    243              #if !defined(VOLTAGE_SIGNAL_IS_COMMON)
    244                  #if NUM_PHASES >= 2
    245              sd_xxxx_reg(SD_CCTL_, PHASE_2_VOLTAGE_ADC_CHANNEL) &= ~SD_SC;
    246              sd_xxxx_reg(SD_CCTL_, PHASE_2_CURRENT_ADC_CHANNEL) &= ~SD_SC;
    247                  #endif
    248                  #if NUM_PHASES >= 3
    249              sd_xxxx_reg(SD_CCTL_, PHASE_3_VOLTAGE_ADC_CHANNEL) &= ~SD_SC;
    250              sd_xxxx_reg(SD_CCTL_, PHASE_3_CURRENT_ADC_CHANNEL) &= ~SD_SC;
    251                  #endif
    252              #else
    253                  #if NUM_PHASES >= 2
    254          //    sd_xxxx_reg(SD_CCTL_, PHASE_2_VOLTAGE_ADC_CHANNEL) &= ~SD_SC;
    255              sd_xxxx_reg(SD_CCTL_, PHASE_2_CURRENT_ADC_CHANNEL) &= ~SD_SC;
    256                  #endif
    257                  #if NUM_PHASES >= 3
    258          //    sd_xxxx_reg(SD_CCTL_, PHASE_3_VOLTAGE_ADC_CHANNEL) &= ~SD_SC;
    259              sd_xxxx_reg(SD_CCTL_, PHASE_3_CURRENT_ADC_CHANNEL) &= ~SD_SC;
    260                  #endif
    261              #endif
    262              #if defined(NEUTRAL_MONITOR_SUPPORT)
    263              sd_xxxx_reg(SD_CCTL_, NEUTRAL_CURRENT_ADC_CHANNEL) &= ~SD_SC;
    264              #endif
    265              
    266              #if defined (TEMPERATURE_ADC_CHANNEL)
    267              sd_xxxx_reg(SD_CCTL_, TEMPERATURE_ADC_CHANNEL) &= ~SD_SC;
   \   000008   A2C30601     BIC.W   #0x2, &0x106
    268              #endif
    269          #endif
    270          
    271              /* Use the SMCLK. It will need to be divided to produce an ADC clock of 1.048576MHz. The ratio will depend on the
    272                 frequency the SMCLK is set to. Use the internal reference. */
    273          #if defined(__MSP430_HAS_SD24_B__)
    274              SD24BCTL0 = SD24SSEL__SMCLK     /* Clock is SMCLK */
    275                        | SD24PDIV_3          /* Divide by 16 => ADC clock: 1.048576MHz */
    276                        | SD24DIV0
    277                        | SD24REFS            /* Use internal reference */
    278                        | SD24OV32;
    279              SD24BCTL1 = 0;
    280          #else
    281              #if defined(__MSP430_HAS_SD24_2__) || defined(__MSP430_HAS_SD24_3__) || defined(__MSP430_HAS_SD24_4__)
    282              SD24CTL = SD24REFS;
   \   00000C   A2420001     MOV.W   #0x4, &0x100
    283              #elif SD_CLOCK_DIVISION == 4
    284              SD_CTL = SD_SSEL_1 | SD_DIV_2 | SD_REFON;
    285              #elif SD_CLOCK_DIVISION == 6
    286              SD_CTL = SD_SSEL_1 | SD_XDIV_1 | SD_DIV_1 | SD_REFON;
    287              #elif SD_CLOCK_DIVISION == 8
    288              SD_CTL = SD_SSEL_1 | SD_DIV_3 | SD_REFON;
    289              #elif SD_CLOCK_DIVISION == 12
    290              SD_CTL = SD_SSEL_1 | SD_XDIV_1 | SD_DIV_2 | SD_REFON;
    291              #elif SD_CLOCK_DIVISION == 16
    292              SD_CTL = SD_SSEL_1 | SD_XDIV_2 | SD_REFON;
    293              #elif SD_CLOCK_DIVISION == 24
    294              SD_CTL = SD_SSEL_1 | SD_XDIV_1 | SD_DIV_3 | SD_REFON;
    295              #endif
    296              #if defined(SD16CONF0_FUDGE)
    297              SD16CONF0 = SD16CONF0_FUDGE;
    298              #endif
    299              #if defined(SD16CONF1_FUDGE)
    300              SD16CONF1 = SD16CONF1_FUDGE;
    301              #endif
    302          #endif
    303          
    304              sd_set_normal_live_current_mode(PHASE_1_CURRENT_ADC_CHANNEL);
   \   000010   F2402000B100 MOV.B   #0x20, &0xb1
   \   000016   B24019010401 MOV.W   #0x119, &0x104
   \   00001C   C243B900     MOV.B   #0x0, &0xb9
    305          #if NUM_PHASES >= 2
    306              sd_set_normal_live_current_mode(PHASE_2_CURRENT_ADC_CHANNEL);
    307          #endif
    308          #if NUM_PHASES >= 3
    309              sd_set_normal_live_current_mode(PHASE_3_CURRENT_ADC_CHANNEL);
    310          #endif
    311          #if NUM_PHASES >= 4
    312              sd_set_normal_live_current_mode(PHASE_4_CURRENT_ADC_CHANNEL);
    313          #endif
    314          #if NUM_PHASES >= 5
    315              sd_set_normal_live_current_mode(PHASE_5_CURRENT_ADC_CHANNEL);
    316          #endif
    317          #if NUM_PHASES >= 6
    318              sd_set_normal_live_current_mode(PHASE_6_CURRENT_ADC_CHANNEL);
    319          #endif
    320          #if defined(NEUTRAL_MONITOR_SUPPORT)
    321              sd_set_normal_neutral_current_mode(NEUTRAL_CURRENT_ADC_CHANNEL);
    322          #endif
    323          // original : #if NUM_PHASES > 1  &&  defined(__MSP430_HAS_SD24_B3__)  &&  defined(__MSP430_HAS_ADC10_A__), modified by mars
    324          #if NUM_PHASES > 1  &&  defined(__MSP430_HAS_SD24_B3__)  &&  defined(__MSP430_HAS_ADC10_A__) && 0
    325              /* The ADC10A is going to measure the three voltages. It will be triggered by the SD24B, and
    326                 will deliver the three results by DMA */
    327              /* Trigger DMA channel 0 from ADCIFG0 */
    328              DMACTL0 = DMA0TSEL__ADC10IFG0;
    329              __data16_write_addr((uint16_t) &DMA0SA, (uint32_t) &ADC10MEM0);
    330              __data16_write_addr((uint16_t) &DMA0DA, (uint32_t) &dma_adc_buffer[0]);
    331              /* Channels 5 to 0. We only want 5 to 3 really, but the sequencing engine in the ADC10A module
    332                 only supports channel X to channel 0, and currently 5, 4, and 3 are our voltage channels */
    333              DMA0SZ = 6;
    334              //DMA0SZ = NUM_PHASES;
    335              /* Enable, destination address incremented, repeating single transfer. */
    336              DMA0CTL = DMADT_4 | DMADSTINCR_3 | DMAEN;
    337              /* Clear pending interrupts to ensure trigger for DMA */
    338              ADC10IFG = 0;
    339          
    340              /* ADC on, ADC10 waits for trigger from the SD24, sampling time 2us 8xADCclk, auto next conv. */
    341              ADC10CTL0 = ADC10SHT0 | ADC10ON | ADC10MSC;
    342              #if SD_CLOCK_DIVISION == 8
    343              /* Triggered by the SD24, SMCLK/2 = 4MHz, Sequence of channels */
    344              ADC10CTL1 = ADC10SHP | ADC10SHS_3 | ADC10DIV_4 | ADC10SSEL_3 | ADC10CONSEQ_1;
    345              #endif
    346              #if SD_CLOCK_DIVISION == 16
    347              /* Triggered by the SD24, SMCLK/4 = 4MHz, Sequence of channels */
    348              ADC10CTL1 = ADC10SHP | ADC10SHS_3 | ADC10DIV_2 | ADC10SSEL_3 | ADC10CONSEQ_1;
    349              #endif
    350              /* Predivide by 1, 10bit resolution, results are scaled to 16bit signed numbers, so
    351                 Vr- = 0x8000 and Vr+ = 0x7FC0. */
    352              ADC10CTL2 = ADC10RES | ADC10DF;
    353              /* Vr- = Vss, Vr+ = Vref+, The sequence of conversions will be ch2 to ch0. */
    354              ADC10MCTL0 = ADC10SREF_1 | ADC10INCH_5;
    355              //ADC10MCTL0 = ADC10SREF_1 | ADC10INCH_2;
    356              /* Start ADC and wait for a trigger from the SD24 */
    357              ADC10CTL0 |= ADC10ENC;
    358              SD24BIE |= SD24IE2;
    359          #else
    360              /* The three voltages are phase coincident. Only interrupt from one of them. */
    361              sd_set_normal_voltage_mode(PHASE_1_VOLTAGE_ADC_CHANNEL);
   \   000020   C243B000     MOV.B   #0x0, &0xb0
   \   000024   B24011010201 MOV.W   #0x111, &0x102
   \   00002A   C243B800     MOV.B   #0x0, &0xb8
    362              #if !defined(VOLTAGE_SIGNAL_IS_COMMON)
    363                  #if NUM_PHASES >= 2
    364              sd_set_normal_voltage_mode(PHASE_2_VOLTAGE_ADC_CHANNEL);
    365                  #endif
    366                  #if NUM_PHASES >= 3
    367              sd_set_normal_voltage_mode(PHASE_3_VOLTAGE_ADC_CHANNEL);
    368                  #endif
    369              #endif
    370          #endif
    371          
    372          #if defined (TEMPERATURE_ADC_CHANNEL)
    373              sd_set_normal_temperature_mode (TEMPERATURE_ADC_CHANNEL)
   \   00002E   F2400600B200 MOV.B   #0x6, &0xb2
   \   000034   B24011010601 MOV.W   #0x111, &0x106
   \   00003A   C243BA00     MOV.B   #0x0, &0xba
    374          #endif
    375          
    376          #if NUM_PHASES == 1
    377              working_data.phases[0].metrology.current[0].in_phase_correction.sd_preloaded_offset = 0;
   \   00003E   8243....     MOV.W   #0x0, &working_data + 330
    378              #if defined(NEUTRAL_MONITOR_SUPPORT)
    379              working_data.phases[0].metrology.current[1].in_phase_correction.sd_preloaded_offset = 0;
    380              #endif
    381          #else
    382              for (i = 0;  i < NUM_PHASES;  i++)
    383                  working_data.phases[i].metrology.current[0].in_phase_correction.sd_preloaded_offset = 0;
    384          #endif
    385          
    386          #if defined(__MSP430_HAS_SD24_B__)
    387              #if NUM_PHASES == 3  &&  defined(__MSP430_HAS_SD24_B3__)  &&  defined(__MSP430_HAS_ADC10_A__)
    388              SD24BTRGCTL = SD24SCS__GROUP0;      /* Trigger generation group 0 +D24TRGIE */
    389              SD24BCTL1 |= SD24GRP0SC;            /* Start group 0 */
    390              #else
    391              SD24BIE = 0x0007;
    392              #endif
    393          #else
    394              sd_xxxx_reg(SD_CCTL_, PHASE_1_VOLTAGE_ADC_CHANNEL) |= SD_IE;
   \   000042   B2D20201     BIS.W   #0x8, &0x102
    395              #if NUM_PHASES >= 2
    396              ?sd_xxxx_reg(SD_CCTL_, PHASE_1_CURRENT_ADC_CHANNEL) |= SD_IE;
    397              sd_xxxx_reg(SD_CCTL_, PHASE_2_CURRENT_ADC_CHANNEL) |= SD_IE;
    398              #endif
    399              #if NUM_PHASES >= 3
    400              sd_xxxx_reg(SD_CCTL_, PHASE_3_CURRENT_ADC_CHANNEL) |= SD_IE;
    401              #endif
    402          #endif
    403          
    404              /* We want to start conversion on the last converter in the set */
    405          #if defined(__MSP430_HAS_SD24_B__)
    406              SD_CTL1 |= SD24GRP0SC;
    407          #else
    408              SD_CCTL_TRIGGER &= ~SD_GRP;
   \   000046   92C30601     BIC.W   #0x1, &0x106
    409              SD_CCTL_TRIGGER |= SD_SC;
   \   00004A   A2D30601     BIS.W   #0x2, &0x106
    410          #endif
    411          #if defined(TEMPERATURE_SUPPORT)
    412              /* Initialise the temperature measurement to the intercept (i.e. 0C), so it doesn't take
    413                 forever to settle. */
    414          //    raw_temperature_from_adc = ((int32_t) cal_info->temperature_sensor_intercept << 11);
    415              raw_temperature_from_adc = cal_info->temperature_sensor_intercept;
   \   00004E   9242........ MOV.W   &nv_parms + 30, &raw_temperature_from_adc
    416          #endif
    417          }
   \   000054   3041         RET
   \   000056                REQUIRE SD24CCTL0
   \   000056                REQUIRE SD24CCTL1
   \   000056                REQUIRE SD24CCTL2
   \   000056                REQUIRE SD24CTL
   \   000056                REQUIRE SD24INCTL1
   \   000056                REQUIRE SD24PRE1
   \   000056                REQUIRE SD24INCTL0
   \   000056                REQUIRE SD24PRE0
   \   000056                REQUIRE SD24INCTL2
   \   000056                REQUIRE SD24PRE2
    418          
    419          #if defined(LIMP_MODE_SUPPORT)
    420          void metrology_init_analog_front_end_limp_mode(void)
    421          {
    422              #if NUM_PHASES > 1
    423              int i;
    424              #endif
    425          
    426              #if defined(__MSP430_HAS_SD24_B__)
    427              SD_CTL1 &= ~SD_SC;
    428              #else
    429              sd_xxxx_reg(SD_CCTL_, PHASE_1_VOLTAGE_ADC_CHANNEL) &= ~SD_SC;
    430              sd_xxxx_reg(SD_CCTL_, PHASE_1_CURRENT_ADC_CHANNEL) &= ~SD_SC;
    431                  #if NUM_PHASES >= 2
    432              sd_xxxx_reg(SD_CCTL_, PHASE_2_VOLTAGE_ADC_CHANNEL) &= ~SD_SC;
    433              sd_xxxx_reg(SD_CCTL_, PHASE_2_CURRENT_ADC_CHANNEL) &= ~SD_SC;
    434                  #endif
    435                  #if NUM_PHASES >= 3
    436              sd_xxxx_reg(SD_CCTL_, PHASE_3_VOLTAGE_ADC_CHANNEL) &= ~SD_SC;
    437              sd_xxxx_reg(SD_CCTL_, PHASE_3_CURRENT_ADC_CHANNEL) &= ~SD_SC;
    438                  #endif
    439                  #if defined(NEUTRAL_MONITOR_SUPPORT)
    440              sd_xxxx_reg(SD_CCTL_, NEUTRAL_CURRENT_ADC_CHANNEL) &= ~SD_SC;
    441                  #endif
    442              #endif
    443          
    444              #if defined(__MSP430_HAS_SD24_B__)
    445              SD24BCTL0 = SD24SSEL__SMCLK     /* Clock is SMCLK */
    446                        | SD24PDIV_3          /* Divide by 16 => ADC clock: 1.048576MHz */
    447                        | SD24DIV0
    448                        | SD24REFS            /* Use internal reference */
    449                        | SD24OV32;
    450              #else
    451                  #if defined(__MSP430_HAS_SD24_2__) || defined (__MSP430_HAS_SD24_3__) || defined (__MSP430_HAS_SD24_4__)
    452              SD24CTL = SD24REFS;
    453                  #elif SD_CLOCK_DIVISION == 4
    454              SD_CTL = SD_SSEL_1 | SD_DIV_2 | SD_REFON;
    455                  #elif SD_CLOCK_DIVISION == 8
    456              SD_CTL = SD_SSEL_1 | SD_DIV_3 | SD_REFON;
    457                  #elif SD_CLOCK_DIVISION == 12
    458              SD_CTL = SD_SSEL_1 | SD_XDIV_1 | SD16DIV_2 | SD_REFON;
    459                  #elif SD_CLOCK_DIVISION == 16
    460              SD_CTL = SD_SSEL_1 | SD_XDIV_2 | SD_REFON;
    461                  #endif
    462                  #if defined(SD16CONF0_FUDGE)
    463              SD16CONF0 = SD16CONF0_FUDGE;
    464                  #endif
    465                  #if defined(SD16CONF1_FUDGE)
    466              SD16CONF1 = SD16CONF1_FUDGE;
    467                  #endif
    468              #endif
    469          
    470              sd_set_limp_live_current_mode(PHASE_1_CURRENT_ADC_CHANNEL);
    471              #if NUM_PHASES >= 2
    472              sd_set_limp_live_current_mode(PHASE_2_CURRENT_ADC_CHANNEL);
    473              #endif
    474              #if NUM_PHASES >= 3
    475              sd_set_limp_live_current_mode(PHASE_3_CURRENT_ADC_CHANNEL);
    476              #endif
    477              #if defined(NEUTRAL_MONITOR_SUPPORT)
    478              sd_set_limp_neutral_current_mode(NEUTRAL_CURRENT_ADC_CHANNEL);
    479              #endif
    480          
    481              sd_set_limp_voltage_mode(PHASE_1_VOLTAGE_ADC_CHANNEL);
    482              #if NUM_PHASES >= 2
    483              sd_set_limp_voltage_mode(PHASE_2_VOLTAGE_ADC_CHANNEL);
    484              #endif
    485              #if NUM_PHASES >= 3
    486              sd_set_limp_voltage_mode(PHASE_3_VOLTAGE_ADC_CHANNEL);
    487              #endif
    488          
    489              /* The three voltages are phase coincident. Only interrupt from one of them. */
    490              #if defined(__MSP430_HAS_SD24_B__)
    491              SD24BIE = 0x0007;
    492              #else
    493                  #if NUM_PHASES >= 2
    494              sd_xxxx_reg(SD_CCTL_, PHASE_1_CURRENT_ADC_CHANNEL) |= SD_IE;
    495              sd_xxxx_reg(SD_CCTL_, PHASE_2_CURRENT_ADC_CHANNEL) |= SD_IE;
    496                  #endif
    497                  #if NUM_PHASES >= 3
    498              sd_xxxx_reg(SD_CCTL_, PHASE_3_CURRENT_ADC_CHANNEL) |= SD_IE;
    499                  #endif
    500              sd_xxxx_reg(SD_CCTL_, PHASE_1_VOLTAGE_ADC_CHANNEL) |= SD_IE;
    501              #endif
    502          
    503              #if NUM_PHASES == 1
    504              working_data.phases[0].metrology.current[0].in_phase_correction.sd_preloaded_offset = 0;
    505                  #if defined(NEUTRAL_MONITOR_SUPPORT)
    506              working_data.phases[0].metrology.current[1].in_phase_correction.sd_preloaded_offset = 0;
    507                  #endif
    508              #else
    509              for (i = 0;  i < NUM_PHASES;  i++)
    510                  working_data.phases[i].metrology.current[0].in_phase_correction.sd_preloaded_offset = 0;
    511              #endif
    512          }
    513          #endif
    514          

   \                                 In  segment CODE, align 2
    515          void metrology_disable_analog_front_end(void)
   \                     metrology_disable_analog_front_end:
    516          {
    517          #if NUM_PHASES > 1
    518              int ph;
    519          #endif
    520          
    521          #if NUM_PHASES > 1  &&  defined(__MSP430_HAS_SD24_B3__)  &&  defined(__MSP430_HAS_ADC10_A__)
    522          #else
    523              sd_set_idle_voltage_mode(PHASE_1_VOLTAGE_ADC_CHANNEL);
   \   000000   C243B000     MOV.B   #0x0, &0xb0
   \   000004   82430201     MOV.W   #0x0, &0x102
   \   000008   C243B800     MOV.B   #0x0, &0xb8
    524              #if !defined(VOLTAGE_SIGNAL_IS_COMMON)
    525                  #if NUM_PHASES >= 2
    526              sd_set_idle_voltage_mode(PHASE_2_VOLTAGE_ADC_CHANNEL);
    527                  #endif
    528                  #if NUM_PHASES >= 3
    529              sd_set_idle_voltage_mode(PHASE_3_VOLTAGE_ADC_CHANNEL);
    530                  #endif
    531              #endif
    532          #endif
    533          
    534              sd_set_idle_live_current_mode(PHASE_1_CURRENT_ADC_CHANNEL);
   \   00000C   C243B100     MOV.B   #0x0, &0xb1
   \   000010   82430401     MOV.W   #0x0, &0x104
   \   000014   C243B900     MOV.B   #0x0, &0xb9
    535          #if NUM_PHASES >= 2
    536              sd_set_idle_live_current_mode(PHASE_2_CURRENT_ADC_CHANNEL);
    537          #endif
    538          #if NUM_PHASES >= 3
    539              sd_set_idle_live_current_mode(PHASE_3_CURRENT_ADC_CHANNEL);
    540          #endif
    541          #if NUM_PHASES >= 4
    542              sd_set_idle_live_current_mode(PHASE_4_CURRENT_ADC_CHANNEL);
    543          #endif
    544          #if NUM_PHASES >= 5
    545              sd_set_idle_live_current_mode(PHASE_5_CURRENT_ADC_CHANNEL);
    546          #endif
    547          #if NUM_PHASES >= 6
    548              sd_set_idle_live_current_mode(PHASE_6_CURRENT_ADC_CHANNEL);
    549          #endif
    550          #if defined(NEUTRAL_MONITOR_SUPPORT)
    551              sd_set_idle_live_current_mode(NEUTRAL_CURRENT_ADC_CHANNEL);
    552          #endif
    553          
    554          #if defined(__MSP430_HAS_SD24_B__)
    555              SD24BCTL0 = 0;
    556          #else
    557              SD_CTL = 0;
   \   000018   82430001     MOV.W   #0x0, &0x100
    558          #endif
    559          
    560          #if NUM_PHASES == 1
    561              working_data.phases[0].metrology.current[0].in_phase_correction.sd_preloaded_offset = 0;
   \   00001C   8243....     MOV.W   #0x0, &working_data + 330
    562              #if defined(NEUTRAL_MONITOR_SUPPORT)
    563              working_data.phases[0].metrology.current[1].in_phase_correction.sd_preloaded_offset = 0;
    564              #endif
    565          #else
    566              for (ph = 0;  ph < NUM_PHASES;  ph++)
    567                  working_data.phases[ph].metrology.current[0].in_phase_correction.sd_preloaded_offset = 0;
    568          #endif
    569          }
   \   000020   3041         RET
   \   000022                REQUIRE SD24INCTL0
   \   000022                REQUIRE SD24CCTL0
   \   000022                REQUIRE SD24PRE0
   \   000022                REQUIRE SD24INCTL1
   \   000022                REQUIRE SD24CCTL1
   \   000022                REQUIRE SD24PRE1
   \   000022                REQUIRE SD24CTL
    570          

   \                                 In  segment CODE, align 2
    571          int metrology_init_from_nv_data(void)
   \                     metrology_init_from_nv_data:
    572          {
    573          #if NUM_PHASES > 1
    574              int ph;
    575              struct phase_parms_s *phase;
    576              struct phase_calibration_data_s const *phase_cal;
    577          
    578              phase = working_data.phases;
    579              phase_cal = cal_info->phases;
    580              for (ph = 0;  ph < NUM_PHASES;  ph++, phase++, phase_cal++)
    581          #endif
    582              {
    583                  /* Prime the DC estimates for quick settling */
    584          #if defined(LIMP_MODE_SUPPORT)
    585                  dc_filter_current_init(phase->metrology.current[0].I_dc_estimate[0], phase_cal->current[0].initial_dc_estimate[0]);
    586                  dc_filter_current_init(phase->metrology.current[0].I_dc_estimate[1], phase_cal->current[0].initial_dc_estimate[1]);
    587                  phase->metrology.current[0].I_endstops = ENDSTOP_HITS_FOR_OVERLOAD;
    588              #if NUM_PHASES == 1  &&  defined(NEUTRAL_MONITOR_SUPPORT)
    589                  dc_filter_current_init(phase->metrology.current[1].I_dc_estimate[0], phase_cal->current[1].initial_dc_estimate[0]);
    590                  dc_filter_current_init(phase->metrology.current[1].I_dc_estimate[1], phase_cal->current[1].initial_dc_estimate[1]);
    591                  phase->metrology.current[1].I_endstops = ENDSTOP_HITS_FOR_OVERLOAD;
    592              #endif
    593                  dc_filter_voltage_init(phase->metrology.V_dc_estimate[0], phase_cal->initial_v_dc_estimate[0]);
    594                  dc_filter_voltage_init(phase->metrology.V_dc_estimate[1], phase_cal->initial_v_dc_estimate[1]);
    595          #else
    596                  dc_filter_current_init(phase->metrology.current[0].I_dc_estimate[0], phase_cal->current[0].initial_dc_estimate[0]);
   \   000000   1E42....     MOV.W   &nv_parms + 2, R14
   \   000004   1F42....     MOV.W   &nv_parms + 4, R15
   \   000008   3C40....     MOV.W   #working_data + 230, R12
   \   00000C   B012....     CALL    #dc_filter24_init
    597                  phase->metrology.current[0].I_endstops = ENDSTOP_HITS_FOR_OVERLOAD;
   \   000010   F2401400.... MOV.B   #0x14, &working_data + 346
    598              #if NUM_PHASES == 1  &&  defined(NEUTRAL_MONITOR_SUPPORT)
    599                  dc_filter_current_init(phase->metrology.current[1].I_dc_estimate[0], phase_cal->current[1].initial_dc_estimate[0]);
    600                  phase->metrology.current[1].I_endstops = ENDSTOP_HITS_FOR_OVERLOAD;
    601              #endif
    602                  dc_filter_voltage_init(phase->metrology.V_dc_estimate[0], phase_cal->initial_v_dc_estimate[0]);
   \   000016   1D42....     MOV.W   &nv_parms + 16, R13
   \   00001A   3C40....     MOV.W   #working_data + 78, R12
   \   00001E   B012....     CALL    #dc_filter16_init
    603          #endif
    604                  phase->metrology.V_endstops = ENDSTOP_HITS_FOR_OVERLOAD;
   \   000022   F2401400.... MOV.B   #0x14, &working_data + 358
    605          #if defined(MAINS_FREQUENCY_SUPPORT)
    606                  phase->metrology.mains_period = ((SAMPLES_PER_10_SECONDS*6554)/MAINS_NOMINAL_FREQUENCY) << 8;
   \   000028   B2400080.... MOV.W   #0x8000, &working_data + 350
   \   00002E   B24002A0.... MOV.W   #0xa002, &working_data + 352
    607          #endif
    608              }
    609          #if NUM_PHASES > 1  &&  defined(NEUTRAL_MONITOR_SUPPORT)
    610              dc_filter_current_init(working_data.neutral.metrology.I_dc_estimate[0], cal_info->neutral.initial_dc_estimate[0]);
    611              working_data.neutral.metrology.I_endstops = ENDSTOP_HITS_FOR_OVERLOAD;
    612          #endif
    613          
    614          #if defined (WIRE_RESISTANCE_COMPENSATE)
    615              resistance_scaling = ((64L * (uint32_t)(cal_info->phases[ph].initial_compensate_resistance[0]) * cal_info->phases[ph].current[0].I_rms_scale_factor[0]) / cal_info->phases[ph].V_rms_scale_factor[0]);
   \   000034   0212         PUSH.W  SR
   \   000036   32C2         DINT
   \   000038   0343         NOP
   \   00003A   9242....3001 MOV.W   &nv_parms + 20, &0x130
   \   000040   9242....3801 MOV.W   &nv_parms + 12, &0x138
   \   000046   1C423A01     MOV.W   &0x13a, R12
   \   00004A   1D423C01     MOV.W   &0x13c, R13
   \   00004E   3241         POP.W   SR
   \   000050   B012....     CALL    #?ShiftLeft32_6
   \   000054   1E42....     MOV.W   &nv_parms + 26, R14
   \   000058   0F43         MOV.W   #0x0, R15
   \   00005A   B012....     CALL    #?DivMod32u
   \   00005E   824C....     MOV.W   R12, &resistance_scaling
   \   000062   824D....     MOV.W   R13, &resistance_scaling + 2
    616          #endif
    617          
    618          #if defined (CAPACITOR_COMPENSATE_ON)
    619              capacitance_scaling = ((uint32_t)(cal_info->phases[ph].initial_compensate_capacitance[0]) * cal_info->phases[ph].V_rms_scale_factor[0]) / ((uint32_t)(cal_info->phases[ph].current[0].I_rms_scale_factor[0]) * (64000 / SAMPLE_RATE));
   \   000066   0212         PUSH.W  SR
   \   000068   32C2         DINT
   \   00006A   0343         NOP
   \   00006C   9242....3001 MOV.W   &nv_parms + 18, &0x130
   \   000072   9242....3801 MOV.W   &nv_parms + 26, &0x138
   \   000078   1C423A01     MOV.W   &0x13a, R12
   \   00007C   1D423C01     MOV.W   &0x13c, R13
   \   000080   3241         POP.W   SR
   \   000082   1E42....     MOV.W   &nv_parms + 12, R14
   \   000086   0F43         MOV.W   #0x0, R15
   \   000088   0E5E         RLA.W   R14
   \   00008A   0F6F         RLC.W   R15
   \   00008C   0E5E         RLA.W   R14
   \   00008E   0F6F         RLC.W   R15
   \   000090   0E5E         RLA.W   R14
   \   000092   0F6F         RLC.W   R15
   \   000094   B012....     CALL    #?DivMod32u
   \   000098   824C....     MOV.W   R12, &capacitance_scaling
   \   00009C   824D....     MOV.W   R13, &capacitance_scaling + 2
    620          #endif
    621          
    622          
    623              return 0;
   \   0000A0   0C43         MOV.W   #0x0, R12
   \   0000A2   3041         RET
    624          }
    625          /*
    626          int metrology_align_with_nv_data(void)
    627          {
    628          #if NUM_PHASES > 1
    629              int ph;
    630              static struct phase_parms_s *phase;
    631              static struct phase_calibration_data_s const *phase_cal;
    632          #endif
    633          
    634              metrology_disable_analog_front_end();
    635              metrology_init_analog_front_end_normal_mode();
    636          
    637          #if NUM_PHASES > 1
    638              phase = working_data.phases;
    639              phase_cal = cal_info->phases;
    640              for (ph = 0;  ph < NUM_PHASES;  ph++, phase++, phase_cal++)
    641          #endif
    642              {
    643                  set_sd_phase_correction(&phase->metrology.current[0].in_phase_correction, ph, phase_cal->current[0].phase_correction);
    644              }
    645          #if NUM_PHASES == 1  &&  defined(NEUTRAL_MONITOR_SUPPORT)
    646                  set_sd_phase_correction(&phase->metrology.current[1].in_phase_correction, NUM_PHASES, phase_cal->current[1].phase_correction);
    647          #endif
    648              return 0;
    649          }
    650          */

   \                                 In  segment CODE, align 2
    651          void metrology_switch_to_normal_mode(void)
   \                     metrology_switch_to_normal_mode:
    652          {
    653          #if NUM_PHASES > 1
    654              int ph;
    655              #if !defined(DYNAMIC_PHASE_CORRECTION_SUPPORT)
    656              struct phase_parms_s *phase;
    657              struct phase_calibration_data_s const *phase_cal;
    658              #endif
    659          #endif
    660          
    661              /* Switch to full speed, full power mode */
    662              // metrology_state |= METROLOGY_STATUS_PHASE_VOLTAGE_OK; - removed by mars 20130204
    663          
    664          #if defined(__HAS_SD_ADC__)
    665              #if defined(__MSP430_HAS_TA3__)
    666              /* Disable the TIMER_A0 interrupt */
    667              TACTL = 0;
   \   000000   82436001     MOV.W   #0x0, &0x160
    668              TACCTL0 = 0;
   \   000004   82436201     MOV.W   #0x0, &0x162
    669              #endif
    670              __disable_interrupt();
   \   000008   32C2         DINT
   \   00000A   0343         NOP
    671              metrology_init_analog_front_end_normal_mode();
   \   00000C   B012....     CALL    #metrology_init_analog_front_end_normal_mode
    672          #endif
    673          
    674          //    samples_per_second = SAMPLES_PER_10_SECONDS/10;
    675          
    676              __enable_interrupt();
   \   000010   32D2         EINT
    677          
    678          #if !defined(DYNAMIC_PHASE_CORRECTION_SUPPORT)
    679              #if NUM_PHASES > 1
    680              phase = working_data.phases;
    681              phase_cal = cal_info->phases;
    682              for (ph = 0;  ph < NUM_PHASES;  ph++, phase++, phase_cal++)
    683              #endif
    684              {
    685              #if defined(__HAS_SD_ADC__)
    686                  set_sd_phase_correction(&phase->metrology.current[0].in_phase_correction, ph, phase_cal->current[0].phase_correction);
   \   000012   1E42....     MOV.W   &nv_parms + 10, R14
   \   000016   0D43         MOV.W   #0x0, R13
   \   000018   3C40....     MOV.W   #working_data + 328, R12
   \   00001C   B012....     CALL    #set_sd_phase_correction
    687                  #if NUM_PHASES == 1  &&  defined(NEUTRAL_MONITOR_SUPPORT)
    688                  set_sd_phase_correction(&phase->metrology.current[1].in_phase_correction, NUM_PHASES, phase_cal->current[1].phase_correction);
    689                  #endif
    690              #else
    691                  set_phase_correction(&phase->metrology.current[0].in_phase_correction, phase_cal->current[0].phase_correction);
    692                  #if NUM_PHASES == 1  &&  defined(NEUTRAL_MONITOR_SUPPORT)
    693                  set_phase_correction(&phase->metrology.current[1].in_phase_correction, phase_cal->current[1]phase_correction);
    694                  #endif
    695              #endif
    696              }
    697              #if defined(__HAS_SD_ADC__)
    698                  #if NUM_PHASES > 1  &&  defined(NEUTRAL_MONITOR_SUPPORT)
    699              set_sd_phase_correction(&working_data.neutral.metrology.in_phase_correction, NUM_PHASES, cal_info->neutral.phase_correction);
    700                  #endif
    701              #endif
    702          #endif
    703              switch_to_normal_mode();
   \   000020   B012....     CALL    #switch_to_normal_mode
    704              operating_mode = OPERATING_MODE_NORMAL;
   \   000024   C243....     MOV.B   #0x0, &operating_mode
    705          #if defined(LIMP_MODE_SUPPORT)
    706              normal_limp = 0;
    707          #endif
    708          }
   \   000028   3041         RET
   \   00002A                REQUIRE TA0CTL
   \   00002A                REQUIRE TA0CCTL0
    709          
    710          #if defined(LIMP_MODE_SUPPORT)
    711          void metrology_switch_to_limp_mode(void)
    712          {
    713              /* Switch to minimum consumption, current measurement only mode */
    714              // metrology_state &= ~(METROLOGY_STATUS_REVERSED | METROLOGY_STATUS_PHASE_VOLTAGE_OK); - removed by mars 20130204
    715          
    716              #if defined(__HAS_SD_ADC__)
    717                  #if defined(__MSP430_HAS_TA3__)
    718              /* Enable the TIMER_A0 interrupt */
    719              TACTL = TACLR | MC_1 | TASSEL_1;
    720              TACCTL0 = CCIE;
    721                  #endif
    722              __disable_interrupt();
    723              metrology_init_analog_front_end_limp_mode();
    724              #endif
    725          
    726              samples_per_second = LIMP_SAMPLES_PER_10_SECONDS/10;
    727          
    728              __enable_interrupt();
    729          
    730              switch_to_limp_mode();
    731              operating_mode = OPERATING_MODE_LIMP;
    732              #if defined(LIMP_MODE_SUPPORT)
    733              normal_limp = 1;
    734              #endif
    735          }
    736          #endif
    737          
    738          #if defined(POWER_DOWN_SUPPORT)
    739          void metrology_switch_to_powerfail_mode(void)
    740          {
    741              operating_mode = OPERATING_MODE_POWERFAIL;
    742              #if defined(LIMP_MODE_SUPPORT)
    743              normal_limp = 0;
    744              #endif
    745          
    746              /* Note that a power down occured */
    747              // metrology_state |= POWER_DOWN; - removed by mars 20130204
    748          
    749              // metrology_state &= ~(STATUS_REVERSED | STATUS_EARTHED | STATUS_PHASE_VOLTAGE_OK); - removed by mars 20130204
    750              /* Turn off all the LEDs. */
    751              #if defined(TOTAL_ACTIVE_ENERGY_SUPPORT)
    752              total_active_energy_pulse_end();
    753              #endif
    754              #if defined(TOTAL_REACTIVE_ENERGY_SUPPORT)
    755              total_reactive_energy_pulse_end();
    756              #endif
    757          
    758              /* Make the EEPROM signals inputs, and rely on pullups. */
    759              disable_eeprom_port();
    760          
    761              /* Shut down the LCD */
    762              custom_lcd_sleep_handler();
    763          
    764              #if defined(__MSP430_HAS_TA3__)  &&  defined(__MSP430_SD_ADC__)
    765              /* Disable the TIMER_A0 interrupt */
    766              TACTL = 0;
    767              TACCTL0 = 0;
    768              /* Disable the interrupt routine which re-enables the ADC */
    769              TACCTL2 = 0;
    770              #endif
    771          
    772              #if defined(__HAS_SD_ADC__)
    773              metrology_disable_analog_front_end();
    774              #endif
    775              #if defined(IEC1107_SUPPORT)  ||  defined(SERIAL_CALIBRATION_SUPPORT)  ||  defined(SERIAL_CALIBRATION_REF_SUPPORT)
    776              /* Disable the serial port. */
    777              U0ME &= ~(UTXE0 | URXE0);
    778                  #if defined(IEC1107_SUPPORT)
    779              disable_ir_receiver();
    780                  #endif
    781              #endif
    782          
    783              #if defined(BATTERY_MONITOR_SUPPORT)
    784              /* Battery sensing control pin */
    785              P3DIR &= ~(BIT1);
    786              P3OUT |= (BIT1);
    787              #endif
    788          
    789              #if defined(__MSP430_HAS_FLLPLUS__)  ||  defined(__MSP430_HAS_FLLPLUS_SMALL__)
    790              /* Slow the clock to 1MHz as quickly as possible. The FLL will not be active
    791                 in LPM3, so switch it off now, and force the FLL's RC oscillator to
    792                 about 1MHz. The exact frequency is not critical. */
    793              _BIS_SR(SCG0);                  /* switch off FLL locking */
    794              SCFI0 = FLLD_1;
    795              SCFQCTL = SCFI0_LOW | SCFQ_M;
    796              SCFI0 = 0x00;
    797              SCFI1 = 0x37;
    798              #endif
    799              #if defined(__MSP430_HAS_SVS__)
    800              /* At 1MHz it is safe to turn off the SVS, and rely on the brownout
    801                 detector. Now the meter can survive on a very weak battery. */
    802              SVSCTL = 0;
    803              #endif
    804          
    805              /* ******************** LOW POWER STATE ************************** */
    806              /* Go to LPM3 mode and exit only when power comes back on. The timer
    807                 interrupt that ticks every second should be checking for power
    808                 restored while we sit here. When it sees the unregulated supply
    809                 at a healthy voltage, it will wake us up. */
    810              _BIS_SR(LPM3_bits);
    811          
    812              /* Waking up from power down mode */
    813              #if defined(__MSP430_HAS_SVS__)
    814              /* Before we go to high speed we need to make sure the supply voltage is 
    815                 adequate. If there is an SVS we can use that. There should be no wait
    816                 at this point, since we should only have been woken up if the supply
    817                 is healthy. However, it seems better to be cautious. */
    818              SVSCTL |= 0x60;
    819              /* Wait for adequate voltage to run at full speed */
    820              while (!(SVSCTL & SVSON))
    821                  /* dummy loop */;
    822              while ((SVSCTL & SVSOP))
    823                  /* dummy loop */;
    824              /* The voltage should now be OK to run the CPU at full speed. Now it should
    825                 be OK to use the SVS as a reset source. */
    826              SVSCTL |= PORON;
    827              #endif
    828          
    829              #if defined(__MSP430_HAS_FLLPLUS__)  ||  defined(__MSP430_HAS_FLLPLUS_SMALL__)
    830              /* Speed up the clock to high speed. */
    831              SCFI0 = FN_3 | FLLD_4;
    832              SCFQCTL = SCFQCTL_HIGH;
    833              /* There seems no good reason to wait until the FLL has settled at this point. */
    834              #endif
    835          
    836              /* Take control of the EEPROM signals again. */
    837              enable_eeprom_port();
    838          
    839              /* Enable the serial port */
    840              #if defined(IEC1107_SUPPORT)  ||  defined(SERIAL_CALIBRATION_SUPPORT)  ||  defined(SERIAL_CALIBRATION_REF_SUPPORT)
    841                  #if defined(SERIAL_CALIBRATION_REF_SUPPORT)
    842              U0ME |= (UTXE0 | URXE0);
    843                  #elif defined(SERIAL_CALIBRATION_SUPPORT)
    844              U0ME |= URXE0;
    845                  #else
    846              U0ME |= UTXE0;
    847                  #endif
    848              #endif
    849          
    850              #if defined(__MSP430_HAS_TA3__)  &&  defined(__HAS_SD_ADC__)
    851              /* Enable the TIMER_A0 interrupt */
    852              TACTL = TACLR | MC_1 | TASSEL_1;
    853              TACCTL0 = CCIE;
    854              #endif
    855          
    856              kick_watchdog();
    857              #if defined(LOSE_FRACTIONAL_PULSE_AT_POWER_ON)
    858                  #if defined(TOTAL_ACTIVE_ENERGY_PULSES_PER_KW_HOUR)
    859              totals.energy.active_energy_pulse.energy_integrator = 0;
    860                  #endif
    861                  #if defined(TOTAL_REACTIVE_ENERGY_PULSES_PER_KVAR_HOUR)
    862              totals.energy.reactive_energy_pulse.energy_integrator = 0;
    863                  #endif
    864              #endif
    865          
    866              /* Come out of power down in limp mode, as we don't know
    867                 if there is sufficent power available to driver the meter
    868                 at full speed. We will soon switch to normal mode if a
    869                 voltage signal is available. */
    870              /* Limp mode will fire up the ADC again. */
    871              #if defined(LIMP_MODE_SUPPORT)
    872              switch_to_limp_mode();
    873              #else
    874              switch_to_normal_mode();
    875              #endif
    876          }
    877          #endif
    878          

   \                                 In  segment CODE, align 2
    879          int metrology_init(void)
   \                     metrology_init:
    880          {
    881              /* There should always be a power scaling factor for the first current sensor channel of the
    882                 first phase, whatever type of metrology is being built, and that factor should not be
    883                 0xFFFF. */
    884              if (cal_info->phases[0].current[0].P_scale_factor == 0xFFFF)
   \   000000   B293....     CMP.W   #0xffff, &nv_parms + 14
   \   000004   0C20         JNE     ??metrology_init_0
    885              {
    886                  flash_memcpy((void *) cal_info, (const void *) &calibration_defaults, sizeof(calibration_defaults));
   \   000006   3E402000     MOV.W   #0x20, R14
   \   00000A   3D40....     MOV.W   #calibration_defaults, R13
   \   00000E   3C40....     MOV.W   #nv_parms + 2, R12
   \   000012   B012....     CALL    #flash_memcpy
    887                  flash_secure();
   \   000016   B012....     CALL    #flash_secure
    888                  return 0xffff;
   \   00001A   3C43         MOV.W   #0xffff, R12
   \   00001C   3041         RET
    889              }
    890              // metrology_state = 0; - removed by mars 20130204
    891              return 0;
   \                     ??metrology_init_0:
   \   00001E   0C43         MOV.W   #0x0, R12
   \   000020   3041         RET
    892          }

   Maximum stack usage in bytes:

   CSTACK Function
   ------ --------
      2   metrology_disable_analog_front_end
      2   metrology_init
        2   -> flash_memcpy
        2   -> flash_secure
      2   metrology_init_analog_front_end_normal_mode
      4   metrology_init_from_nv_data
        2   -> dc_filter16_init
        2   -> dc_filter24_init
      2   metrology_switch_to_normal_mode
        2   -> metrology_init_analog_front_end_normal_mode
        2   -> set_sd_phase_correction
        2   -> switch_to_normal_mode


   Segment part sizes:

   Bytes  Function/Label
   -----  --------------
       2  SD24CCTL0
       2  SD24CCTL1
       2  SD24CCTL2
       2  SD24CTL
       1  SD24INCTL0
       1  SD24INCTL1
       1  SD24INCTL2
       1  SD24PRE0
       1  SD24PRE1
       1  SD24PRE2
       2  TA0CCTL0
       2  TA0CTL
      34  metrology_disable_analog_front_end
      34  metrology_init
      86  metrology_init_analog_front_end_normal_mode
     164  metrology_init_from_nv_data
      42  metrology_switch_to_normal_mode

 
 360 bytes in segment CODE
  18 bytes in segment DATA16_AN
 
 360 bytes of CODE memory
   0 bytes of DATA memory (+ 18 bytes shared)

Errors: none
Warnings: none
