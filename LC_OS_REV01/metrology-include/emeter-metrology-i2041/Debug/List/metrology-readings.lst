###############################################################################
#                                                                             #
# IAR C/C++ Compiler V5.52.1.50724/W32 for MSP430       07/Jul/2014  17:16:19 #
# Copyright 1996-2013 IAR Systems AB.                                         #
#                                                                             #
#    __rt_version  =  3                                                       #
#    __double_size =  32                                                      #
#    __reg_r4      =  free                                                    #
#    __reg_r5      =  free                                                    #
#    __pic         =  no                                                      #
#    __core        =  430                                                     #
#    Source file   =  C:\Users\a0283112\Desktop\Submeter i2040                #
#                     8k_DC_THD_AUTO_OSR_IAR5.5\emeter-metrology\src\metrolog #
#                     y-readings.c                                            #
#    Command line  =  "C:\Users\a0283112\Desktop\Submeter i2040               #
#                     8k_DC_THD_AUTO_OSR_IAR5.5\emeter-metrology\src\metrolog #
#                     y-readings.c" -D __MSP430__ -lCN                        #
#                     "C:\Users\a0283112\Desktop\Submeter i2040               #
#                     8k_DC_THD_AUTO_OSR_IAR5.5\emeter-metrology\emeter-metro #
#                     logy-i2041\Debug\List\" -lA                             #
#                     "C:\Users\a0283112\Desktop\Submeter i2040               #
#                     8k_DC_THD_AUTO_OSR_IAR5.5\emeter-metrology\emeter-metro #
#                     logy-i2041\Debug\List\" -o                              #
#                     "C:\Users\a0283112\Desktop\Submeter i2040               #
#                     8k_DC_THD_AUTO_OSR_IAR5.5\emeter-metrology\emeter-metro #
#                     logy-i2041\Debug\Obj\" --debug -D__MSP430I2041__ -e     #
#                     --double=32 --dlib_config "C:\Program Files (x86)\IAR   #
#                     Systems\Embedded Workbench                              #
#                     6.5_0\430\LIB\DLIB\dl430fn.h" --library_module -I       #
#                     "C:\Users\a0283112\Desktop\Submeter i2040               #
#                     8k_DC_THD_AUTO_OSR_IAR5.5\emeter-metrology\emeter-metro #
#                     logy-i2041/../../emeter-toolkit/include\" -I            #
#                     "C:\Users\a0283112\Desktop\Submeter i2040               #
#                     8k_DC_THD_AUTO_OSR_IAR5.5\emeter-metrology\emeter-metro #
#                     logy-i2041/../include\" -I                              #
#                     "C:\Users\a0283112\Desktop\Submeter i2040               #
#                     8k_DC_THD_AUTO_OSR_IAR5.5\emeter-metrology\emeter-metro #
#                     logy-i2041\" -Ohs --multiplier=16s                      #
#    List file     =  C:\Users\a0283112\Desktop\Submeter i2040                #
#                     8k_DC_THD_AUTO_OSR_IAR5.5\emeter-metrology\emeter-metro #
#                     logy-i2041\Debug\List\metrology-readings.lst            #
#    Object file   =  C:\Users\a0283112\Desktop\Submeter i2040                #
#                     8k_DC_THD_AUTO_OSR_IAR5.5\emeter-metrology\emeter-metro #
#                     logy-i2041\Debug\Obj\metrology-readings.r43             #
#                                                                             #
#                                                                             #
###############################################################################

C:\Users\a0283112\Desktop\Submeter i2040 8k_DC_THD_AUTO_OSR_IAR5.5\emeter-metrology\src\metrology-readings.c
      1          /*******************************************************************************
      2           *  metrology-readings.c -
      3           *
      4           *  Copyright (C) 2011 Texas Instruments Incorporated - http://www.ti.com/ 
      5           * 
      6           *  Redistribution and use in source and binary forms, with or without 
      7           *  modification, are permitted provided that the following conditions 
      8           *  are met:
      9           *
     10           *    Redistributions of source code must retain the above copyright 
     11           *    notice, this list of conditions and the following disclaimer.
     12           *
     13           *    Redistributions in binary form must reproduce the above copyright
     14           *    notice, this list of conditions and the following disclaimer in the 
     15           *    documentation and/or other materials provided with the   
     16           *    distribution.
     17           *
     18           *    Neither the name of Texas Instruments Incorporated nor the names of
     19           *    its contributors may be used to endorse or promote products derived
     20           *    from this software without specific prior written permission.
     21           *
     22           *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
     23           *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
     24           *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
     25           *  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT 
     26           *  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, 
     27           *  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
     28           *  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
     29           *  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
     30           *  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
     31           *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
     32           *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
     33           *
     34           ******************************************************************************/
     35          
     36          /*! \file emeter-metrology.h */
     37          
     38          #include <inttypes.h>
     39          #include <stdlib.h>
     40          #if !defined(__MSP430__)
     41          #include <stdio.h>
     42          #include <fcntl.h>
     43          #include <unistd.h>
     44          #endif
     45          #if defined(__GNUC__)
     46          #include <signal.h>
     47          #endif
     48          #include <math.h>
     49          
     50          #include <emeter-toolkit.h>
     51          
     52          #include "emeter-metrology.h"
     53          #include "metrology-structs.h"
     54          
     55          #if defined(PRECALCULATED_PARAMETER_SUPPORT)

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine0:
   \   000000   0C43         MOV.W   #0x0, R12
   \   000002   0D43         MOV.W   #0x0, R13
   \   000004   3041         RET

   \                                 In  segment CODE, align 2
     56          power_t active_power(int phx)
   \                     active_power:
     57          {
     58              if (phx == FAKE_PHASE_TOTAL)
   \   000000   3C900300     CMP.W   #0x3, R12
   \   000004   0120         JNE     ??active_power_0
     59              #if defined(TOTAL_ACTIVE_POWER_SUPPORT)
     60                  return working_data.totals.readings.active_power;
     61              #else
     62                  return 0;
   \   000006   ....         JMP     ?Subroutine0
     63              #endif
     64              #if NUM_PHASES == 1  &&  defined(NEUTRAL_MONITOR_SUPPORT)  &&  defined(PER_SENSOR_PRECALCULATED_PARAMETER_SUPPORT)
     65              if (phx == FAKE_PHASE_NEUTRAL)
     66                  return working_data.phases[0].metrology.current[1].readings.active_power;
     67              if (phx == FAKE_PHASE_LIVE)
     68                  return working_data.phases[0].metrology.current[0].readings.active_power;
     69              #endif
     70              return working_data.phases[phx].readings.active_power;
   \                     ??active_power_0:
   \   000008   0C5C         RLA.W   R12
   \   00000A   0F4C         MOV.W   R12, R15
   \   00000C   0C5C         RLA.W   R12
   \   00000E   0C5C         RLA.W   R12
   \   000010   0F5C         ADD.W   R12, R15
   \   000012   0C5C         RLA.W   R12
   \   000014   0C5C         RLA.W   R12
   \   000016   0F5C         ADD.W   R12, R15
   \   000018   0C5C         RLA.W   R12
   \   00001A   0F5C         ADD.W   R12, R15
   \   00001C   0C5C         RLA.W   R12
   \   00001E   0C5C         RLA.W   R12
   \   000020   0C5F         ADD.W   R15, R12
   \   000022   0D4C         MOV.W   R12, R13
   \   000024   1C4D....     MOV.W   working_data + 20(R13), R12
   \   000028   1D4D....     MOV.W   working_data + 22(R13), R13
   \   00002C   3041         RET
     71          }
     72          
     73              #if defined(REACTIVE_POWER_SUPPORT)

   \                                 In  segment CODE, align 2, keep-with-next
     74          power_t reactive_power(int phx)
   \                     reactive_power:
     75          {
     76              if (phx == FAKE_PHASE_TOTAL)
   \   000000   3C900300     CMP.W   #0x3, R12
   \   000004   0120         JNE     ??reactive_power_0
     77                  #if defined(TOTAL_REACTIVE_POWER_SUPPORT)
     78                  return working_data.totals.readings.reactive_power;
     79                  #else
     80                  return 0;
   \   000006   ....         JMP     ?Subroutine0
     81                  #endif
     82              return working_data.phases[phx].readings.reactive_power;
   \                     ??reactive_power_0:
   \   000008   0C5C         RLA.W   R12
   \   00000A   0F4C         MOV.W   R12, R15
   \   00000C   0C5C         RLA.W   R12
   \   00000E   0C5C         RLA.W   R12
   \   000010   0F5C         ADD.W   R12, R15
   \   000012   0C5C         RLA.W   R12
   \   000014   0C5C         RLA.W   R12
   \   000016   0F5C         ADD.W   R12, R15
   \   000018   0C5C         RLA.W   R12
   \   00001A   0F5C         ADD.W   R12, R15
   \   00001C   0C5C         RLA.W   R12
   \   00001E   0C5C         RLA.W   R12
   \   000020   0C5F         ADD.W   R15, R12
   \   000022   0D4C         MOV.W   R12, R13
   \   000024   1C4D....     MOV.W   working_data + 28(R13), R12
   \   000028   1D4D....     MOV.W   working_data + 30(R13), R13
   \   00002C   3041         RET
     83          }
     84              #endif
     85          
     86              #if defined(APPARENT_POWER_SUPPORT)

   \                                 In  segment CODE, align 2, keep-with-next
     87          power_t apparent_power(int phx)
   \                     apparent_power:
     88          {
     89              if (phx == FAKE_PHASE_TOTAL)
   \   000000   3C900300     CMP.W   #0x3, R12
   \   000004   0120         JNE     ??apparent_power_0
     90                  #if defined(TOTAL_APPARENT_POWER_SUPPORT)
     91                  return working_data.totals.readings.apparent_power;
     92                  #else
     93                  return 0;
   \   000006   ....         JMP     ?Subroutine0
     94                  #endif
     95              return working_data.phases[phx].readings.apparent_power;
   \                     ??apparent_power_0:
   \   000008   0C5C         RLA.W   R12
   \   00000A   0F4C         MOV.W   R12, R15
   \   00000C   0C5C         RLA.W   R12
   \   00000E   0C5C         RLA.W   R12
   \   000010   0F5C         ADD.W   R12, R15
   \   000012   0C5C         RLA.W   R12
   \   000014   0C5C         RLA.W   R12
   \   000016   0F5C         ADD.W   R12, R15
   \   000018   0C5C         RLA.W   R12
   \   00001A   0F5C         ADD.W   R12, R15
   \   00001C   0C5C         RLA.W   R12
   \   00001E   0C5C         RLA.W   R12
   \   000020   0C5F         ADD.W   R15, R12
   \   000022   0D4C         MOV.W   R12, R13
   \   000024   1C4D....     MOV.W   working_data + 36(R13), R12
   \   000028   1D4D....     MOV.W   working_data + 38(R13), R13
   \   00002C   3041         RET
     96          }
     97              #endif
     98          
     99              #if defined(FUNDAMENTAL_ACTIVE_POWER_SUPPORT)

   \                                 In  segment CODE, align 2, keep-with-next
    100          power_t fundamental_active_power(int phx)
   \                     fundamental_active_power:
    101          {
    102              if (phx == FAKE_PHASE_TOTAL)
   \   000000   3C900300     CMP.W   #0x3, R12
   \   000004   0120         JNE     ??fundamental_active_power_0
    103                  #if defined(TOTAL_FUNDAMENTAL_ACTIVE_POWER_SUPPORT)
    104                  return working_data.totals.readings.fundamental_active_power;
    105                  #else
    106                  return 0;
   \   000006   ....         JMP     ?Subroutine0
    107                  #endif
    108              return working_data.phases[phx].readings.fundamental_active_power;
   \                     ??fundamental_active_power_0:
   \   000008   0C5C         RLA.W   R12
   \   00000A   0F4C         MOV.W   R12, R15
   \   00000C   0C5C         RLA.W   R12
   \   00000E   0C5C         RLA.W   R12
   \   000010   0F5C         ADD.W   R12, R15
   \   000012   0C5C         RLA.W   R12
   \   000014   0C5C         RLA.W   R12
   \   000016   0F5C         ADD.W   R12, R15
   \   000018   0C5C         RLA.W   R12
   \   00001A   0F5C         ADD.W   R12, R15
   \   00001C   0C5C         RLA.W   R12
   \   00001E   0C5C         RLA.W   R12
   \   000020   0C5F         ADD.W   R15, R12
   \   000022   0D4C         MOV.W   R12, R13
   \   000024   1C4D....     MOV.W   working_data + 24(R13), R12
   \   000028   1D4D....     MOV.W   working_data + 26(R13), R13
   \   00002C   3041         RET
    109          }
    110              #endif
    111          
    112              #if defined(FUNDAMENTAL_REACTIVE_POWER_SUPPORT)

   \                                 In  segment CODE, align 2, keep-with-next
    113          power_t fundamental_reactive_power(int phx)
   \                     fundamental_reactive_power:
    114          {
    115              if (phx == FAKE_PHASE_TOTAL)
   \   000000   3C900300     CMP.W   #0x3, R12
   \   000004   0120         JNE     ??fundamental_reactive_power_0
    116                  #if defined(TOTAL_FUNDAMENTAL_REACTIVE_POWER_SUPPORT)
    117                  return working_data.totals.readings.fundamental_reactive_power;
    118                  #else
    119                  return 0;
   \   000006   ....         JMP     ?Subroutine0
    120                  #endif
    121              return working_data.phases[phx].readings.fundamental_reactive_power;
   \                     ??fundamental_reactive_power_0:
   \   000008   0C5C         RLA.W   R12
   \   00000A   0F4C         MOV.W   R12, R15
   \   00000C   0C5C         RLA.W   R12
   \   00000E   0C5C         RLA.W   R12
   \   000010   0F5C         ADD.W   R12, R15
   \   000012   0C5C         RLA.W   R12
   \   000014   0C5C         RLA.W   R12
   \   000016   0F5C         ADD.W   R12, R15
   \   000018   0C5C         RLA.W   R12
   \   00001A   0F5C         ADD.W   R12, R15
   \   00001C   0C5C         RLA.W   R12
   \   00001E   0C5C         RLA.W   R12
   \   000020   0C5F         ADD.W   R15, R12
   \   000022   0D4C         MOV.W   R12, R13
   \   000024   1C4D....     MOV.W   working_data + 32(R13), R12
   \   000028   1D4D....     MOV.W   working_data + 34(R13), R13
   \   00002C   3041         RET
    122          }
    123              #endif
    124          
    125              #if defined(POWER_FACTOR_SUPPORT)

   \                                 In  segment CODE, align 2
    126          power_factor_t power_factor(int phx)
   \                     power_factor:
    127          {
    128              return working_data.phases[phx].readings.power_factor;
   \   000000   0C5C         RLA.W   R12
   \   000002   0F4C         MOV.W   R12, R15
   \   000004   0C5C         RLA.W   R12
   \   000006   0C5C         RLA.W   R12
   \   000008   0F5C         ADD.W   R12, R15
   \   00000A   0C5C         RLA.W   R12
   \   00000C   0C5C         RLA.W   R12
   \   00000E   0F5C         ADD.W   R12, R15
   \   000010   0C5C         RLA.W   R12
   \   000012   0F5C         ADD.W   R12, R15
   \   000014   0C5C         RLA.W   R12
   \   000016   0C5C         RLA.W   R12
   \   000018   0C5F         ADD.W   R15, R12
   \   00001A   1C4C....     MOV.W   working_data + 42(R12), R12
   \   00001E   3041         RET
    129          }
    130              #endif
    131          
    132              #if defined(VRMS_SUPPORT)

   \                                 In  segment CODE, align 2
    133          rms_voltage_t rms_voltage(int phx)
   \                     rms_voltage:
    134          {
    135              return working_data.phases[phx].readings.V_rms;
   \   000000   0C5C         RLA.W   R12
   \   000002   0F4C         MOV.W   R12, R15
   \   000004   0C5C         RLA.W   R12
   \   000006   0C5C         RLA.W   R12
   \   000008   0F5C         ADD.W   R12, R15
   \   00000A   0C5C         RLA.W   R12
   \   00000C   0C5C         RLA.W   R12
   \   00000E   0F5C         ADD.W   R12, R15
   \   000010   0C5C         RLA.W   R12
   \   000012   0F5C         ADD.W   R12, R15
   \   000014   0C5C         RLA.W   R12
   \   000016   0C5C         RLA.W   R12
   \   000018   0C5F         ADD.W   R15, R12
   \   00001A   0D4C         MOV.W   R12, R13
   \   00001C   1C4D....     MOV.W   working_data(R13), R12
   \   000020   1D4D....     MOV.W   working_data + 2(R13), R13
   \   000024   3041         RET
    136          }
    137              #endif
    138          
    139              #if defined(FUNDAMENTAL_VRMS_SUPPORT)

   \                                 In  segment CODE, align 2
    140          rms_voltage_t fundamental_rms_voltage(int phx)
   \                     fundamental_rms_voltage:
    141          {
    142              return working_data.phases[phx].readings.fundamental_V_rms;
   \   000000   0C5C         RLA.W   R12
   \   000002   0F4C         MOV.W   R12, R15
   \   000004   0C5C         RLA.W   R12
   \   000006   0C5C         RLA.W   R12
   \   000008   0F5C         ADD.W   R12, R15
   \   00000A   0C5C         RLA.W   R12
   \   00000C   0C5C         RLA.W   R12
   \   00000E   0F5C         ADD.W   R12, R15
   \   000010   0C5C         RLA.W   R12
   \   000012   0F5C         ADD.W   R12, R15
   \   000014   0C5C         RLA.W   R12
   \   000016   0C5C         RLA.W   R12
   \   000018   0C5F         ADD.W   R15, R12
   \   00001A   0D4C         MOV.W   R12, R13
   \   00001C   1C4D....     MOV.W   working_data + 4(R13), R12
   \   000020   1D4D....     MOV.W   working_data + 6(R13), R13
   \   000024   3041         RET
    143          }
    144              #endif
    145          
    146              #if defined(VOLTAGE_THD_SUPPORT)

   \                                 In  segment CODE, align 2
    147          thd_t voltage_thd(int phx)
   \                     voltage_thd:
    148          {
    149              return working_data.phases[phx].readings.voltage_thd;
   \   000000   0C5C         RLA.W   R12
   \   000002   0F4C         MOV.W   R12, R15
   \   000004   0C5C         RLA.W   R12
   \   000006   0C5C         RLA.W   R12
   \   000008   0F5C         ADD.W   R12, R15
   \   00000A   0C5C         RLA.W   R12
   \   00000C   0C5C         RLA.W   R12
   \   00000E   0F5C         ADD.W   R12, R15
   \   000010   0C5C         RLA.W   R12
   \   000012   0F5C         ADD.W   R12, R15
   \   000014   0C5C         RLA.W   R12
   \   000016   0C5C         RLA.W   R12
   \   000018   0C5F         ADD.W   R15, R12
   \   00001A   1C4C....     MOV.W   working_data + 8(R12), R12
   \   00001E   3041         RET
    150          }
    151              #endif
    152          
    153              #if defined(IRMS_SUPPORT)

   \                                 In  segment CODE, align 2
    154          rms_current_t rms_current(int phx)
   \                     rms_current:
    155          {
    156                  #if defined(NEUTRAL_MONITOR_SUPPORT)
    157                      #if NUM_PHASES == 1  
    158                          #if defined(PER_SENSOR_PRECALCULATED_PARAMETER_SUPPORT)
    159              if (phx == FAKE_PHASE_NEUTRAL)
    160                  return working_data.phases[0].metrology.current[1].readings.I_rms;
    161              if (phx == FAKE_PHASE_LIVE)
    162                  return working_data.phases[0].metrology.current[0].readings.I_rms;
    163                          #endif
    164                      #else
    165              if (phx == FAKE_PHASE_NEUTRAL)
    166                  return working_data.neutral.readings.I_rms;
    167                      #endif
    168                  #endif
    169              return working_data.phases[phx].readings.I_rms;
   \   000000   0C5C         RLA.W   R12
   \   000002   0F4C         MOV.W   R12, R15
   \   000004   0C5C         RLA.W   R12
   \   000006   0C5C         RLA.W   R12
   \   000008   0F5C         ADD.W   R12, R15
   \   00000A   0C5C         RLA.W   R12
   \   00000C   0C5C         RLA.W   R12
   \   00000E   0F5C         ADD.W   R12, R15
   \   000010   0C5C         RLA.W   R12
   \   000012   0F5C         ADD.W   R12, R15
   \   000014   0C5C         RLA.W   R12
   \   000016   0C5C         RLA.W   R12
   \   000018   0C5F         ADD.W   R15, R12
   \   00001A   0D4C         MOV.W   R12, R13
   \   00001C   1C4D....     MOV.W   working_data + 10(R13), R12
   \   000020   1D4D....     MOV.W   working_data + 12(R13), R13
   \   000024   3041         RET
    170          }
    171              #endif
    172          
    173              #if defined(FUNDAMENTAL_IRMS_SUPPORT)

   \                                 In  segment CODE, align 2
    174          rms_current_t fundamental_rms_current(int phx)
   \                     fundamental_rms_current:
    175          {
    176                  #if defined(NEUTRAL_MONITOR_SUPPORT)
    177              if (phx == FAKE_PHASE_NEUTRAL)
    178                  return 0;
    179                  #endif
    180              return working_data.phases[phx].readings.fundamental_I_rms;
   \   000000   0C5C         RLA.W   R12
   \   000002   0F4C         MOV.W   R12, R15
   \   000004   0C5C         RLA.W   R12
   \   000006   0C5C         RLA.W   R12
   \   000008   0F5C         ADD.W   R12, R15
   \   00000A   0C5C         RLA.W   R12
   \   00000C   0C5C         RLA.W   R12
   \   00000E   0F5C         ADD.W   R12, R15
   \   000010   0C5C         RLA.W   R12
   \   000012   0F5C         ADD.W   R12, R15
   \   000014   0C5C         RLA.W   R12
   \   000016   0C5C         RLA.W   R12
   \   000018   0C5F         ADD.W   R15, R12
   \   00001A   0D4C         MOV.W   R12, R13
   \   00001C   1C4D....     MOV.W   working_data + 14(R13), R12
   \   000020   1D4D....     MOV.W   working_data + 16(R13), R13
   \   000024   3041         RET
    181          }
    182              #endif
    183          
    184              #if defined(CURRENT_THD_SUPPORT)

   \                                 In  segment CODE, align 2
    185          thd_t current_thd(int phx)
   \                     current_thd:
    186          {
    187                  #if defined(NEUTRAL_MONITOR_SUPPORT)
    188              if (phx == FAKE_PHASE_NEUTRAL)
    189                  return 0;
    190                  #endif
    191              return working_data.phases[phx].readings.current_thd;
   \   000000   0C5C         RLA.W   R12
   \   000002   0F4C         MOV.W   R12, R15
   \   000004   0C5C         RLA.W   R12
   \   000006   0C5C         RLA.W   R12
   \   000008   0F5C         ADD.W   R12, R15
   \   00000A   0C5C         RLA.W   R12
   \   00000C   0C5C         RLA.W   R12
   \   00000E   0F5C         ADD.W   R12, R15
   \   000010   0C5C         RLA.W   R12
   \   000012   0F5C         ADD.W   R12, R15
   \   000014   0C5C         RLA.W   R12
   \   000016   0C5C         RLA.W   R12
   \   000018   0C5F         ADD.W   R15, R12
   \   00001A   1C4C....     MOV.W   working_data + 18(R12), R12
   \   00001E   3041         RET
    192          }
    193              #endif
    194          
    195              #if defined(MAINS_FREQUENCY_SUPPORT)

   \                                 In  segment CODE, align 2
    196          int16_t mains_frequency(int phx)
   \                     mains_frequency:
    197          {
    198                  #if defined(NEUTRAL_MONITOR_SUPPORT)
    199              if (phx == FAKE_PHASE_NEUTRAL)
    200                  return 0;
    201                  #endif
    202               return working_data.phases[phx].readings.frequency;
   \   000000   0C5C         RLA.W   R12
   \   000002   0F4C         MOV.W   R12, R15
   \   000004   0C5C         RLA.W   R12
   \   000006   0C5C         RLA.W   R12
   \   000008   0F5C         ADD.W   R12, R15
   \   00000A   0C5C         RLA.W   R12
   \   00000C   0C5C         RLA.W   R12
   \   00000E   0F5C         ADD.W   R12, R15
   \   000010   0C5C         RLA.W   R12
   \   000012   0F5C         ADD.W   R12, R15
   \   000014   0C5C         RLA.W   R12
   \   000016   0C5C         RLA.W   R12
   \   000018   0C5F         ADD.W   R15, R12
   \   00001A   1C4C....     MOV.W   working_data + 40(R12), R12
   \   00001E   3041         RET
    203          }
    204              #endif
    205          
    206              #if NUM_PHASES > 1  &&  defined(FUNDAMENTAL_VRMS_SUPPORT)
    207          phase_angle_t phase_to_phase_angle(int phx)
    208          {
    209              return working_data.phases[phx].readings.phase_to_phase_angle;
    210          }
    211              #endif
    212          
    213              #if NUM_PHASES > 1  &&  defined(RESIDUAL_IRMS_SUPPORT)
    214          rms_current_t residual_3phase_rms_current(void)
    215          {
    216              return working_data.neutral.readings.residual_I_rms;
    217          }
    218              #endif
    219          #else
    220          power_t active_power(int phx)
    221          {
    222              return evaluate_active_power(&working_data.phases[phx], &cal_info->phases[phx]);
    223          }
    224          
    225              #if defined(REACTIVE_POWER_SUPPORT)
    226          power_t reactive_power(int phx)
    227          {
    228              return evaluate_reactive_power(&working_data.phases[phx], &cal_info->phases[phx]);
    229          }
    230              #endif
    231          
    232              #if defined(APPARENT_POWER_SUPPORT)
    233          power_t apparent_power(int phx)
    234          {
    235              return evaulate_apparent_power(&working_data.phases[phx], &cal_info->phases[phx]);
    236          }
    237              #endif
    238          
    239              #if defined(FUNDAMENTAL_ACTIVE_POWER_SUPPORT)
    240          power_t fundamental_active_power(int phx)
    241          {
    242              if (phx == FAKE_PHASE_TOTAL)
    243                  #if defined(TOTAL_FUNDAMENTAL_ACTIVE_POWER_SUPPORT)
    244                  return working_data.totals.readings.fundamental_active_power;
    245                  #else
    246                  return 0;
    247                  #endif
    248              return evaluate_fundamental_active_power(&working_data.phases[phx], &cal_info->phases[phx]);
    249          }
    250              #endif
    251          
    252              #if defined(FUNDAMENTAL_REACTIVE_POWER_SUPPORT)
    253          power_t fundamental_reactive_power(int phx)
    254          {
    255              if (phx == FAKE_PHASE_TOTAL)
    256                  #if defined(TOTAL_FUNDAMENTAL_REACTIVE_POWER_SUPPORT)
    257                  return working_data.totals.readings.fundamental_reactive_power;
    258                  #else
    259                  return 0;
    260                  #endif
    261              return evaluate_fundamental_reactive_power(&working_data.phases[phx], &cal_info->phases[phx]);
    262          }
    263              #endif
    264          
    265              #if defined(POWER_FACTOR_SUPPORT)
    266          power_factor_t power_factor(int phx)
    267          {
    268              return evaluate_power_factor(&working_data.phases[phx], &cal_info->phases[phx]);
    269          }
    270              #endif
    271          
    272              #if defined(VRMS_SUPPORT)
    273          rms_voltage_t rms_voltage(int phx)
    274          {
    275              return evaluate_rms_voltage(&working_data.phases[phx], &cal_info->phases[phx]);
    276          }
    277              #endif
    278          
    279              #if defined(FUNDAMENTAL_VRMS_SUPPORT)
    280          rms_voltage_t fundamental_rms_voltage(int phx)
    281          {
    282              return evaluate_fundamental_rms_voltage(&working_data.phases[phx], &cal_info->phases[phx]);
    283          }
    284              #endif
    285          
    286              #if defined(VOLTAGE_THD_SUPPORT)
    287          thd_t voltage_thd(int phx)
    288          {
    289              return evaluate_voltage_thd(&working_data.phases[phx], &cal_info->phases[phx], phx);
    290          }
    291              #endif
    292          
    293              #if defined(IRMS_SUPPORT)
    294          rms_current_t rms_current(int phx)
    295          {
    296                  #if NUM_PHASES > 1  &&  defined(NEUTRAL_MONITOR_SUPPORT)
    297              if (phx == FAKE_PHASE_NEUTRAL)
    298                  return evaluate_neutral_rms_current();
    299                  #endif
    300              return evaluate_rms_current(&working_data.phases[phx], &cal_info->phases[phx], phx);
    301          }
    302              #endif
    303          
    304              #if defined(FUNDAMENTAL_IRMS_SUPPORT)
    305          rms_current_t fundamental_rms_current(int phx)
    306          {
    307              return evaluate_fundamental_rms_current(&working_data.phases[phx], &cal_info->phases[phx], phx);
    308          }
    309              #endif
    310          
    311              #if defined(CURRENT_THD_SUPPORT)
    312          thd_t current_thd(int phx)
    313          {
    314              return evaluate_current_thd(&working_data.phases[phx], &cal_info->phases[phx], phx);
    315          }
    316              #endif
    317          
    318              #if defined(MAINS_FREQUENCY_SUPPORT)
    319          int16_t mains_frequency(int phx)
    320          {
    321              return evaluate_mains_frequency(&working_data.phases[phx], &cal_info->phases[phx]);
    322          }
    323              #endif
    324          
    325              #if NUM_PHASES > 1  &&  defined(FUNDAMENTAL_VRMS_SUPPORT)
    326          phase_angle_t phase_to_phase_angle(int phx)
    327          {
    328              return evaluate_phase_to_phase_angle(&working_data.phases[phx], &cal_info->phases[phx]);
    329          }
    330              #endif
    331          
    332              #if NUM_PHASES > 1  &&  defined(RESIDUAL_IRMS_SUPPORT)
    333          rms_current_t residual_3phase_rms_current(void)
    334          {
    335              return evaluate_residual_3phase_rms_current();
    336          }
    337              #endif
    338          #endif
    339          
    340          #if defined(ACTIVE_ENERGY_SUPPORT)  ||  defined(TOTAL_ACTIVE_ENERGY_SUPPORT)

   \                                 In  segment CODE, align 2
    341          energy_t active_energy(int phx, int import_export)
   \                     active_energy:
    342          {
    343              if (phx == FAKE_PHASE_TOTAL)
   \   000000   3C900300     CMP.W   #0x3, R12
   \   000004   0520         JNE     ??active_energy_0
    344                  #if defined(TOTAL_ACTIVE_ENERGY_SUPPORT)
    345                  return working_data.totals.energy.active[import_export].energy;
    346                  #else
    347                  return 0;
   \   000006   0C43         MOV.W   #0x0, R12
   \   000008   0D43         MOV.W   #0x0, R13
   \   00000A   0E43         MOV.W   #0x0, R14
   \   00000C   0F43         MOV.W   #0x0, R15
   \   00000E   3041         RET
    348                  #endif
    349              #if defined(ACTIVE_ENERGY_SUPPORT)
    350              return working_data.phases[phx].energy.active[import_export].energy;
   \                     ??active_energy_0:
   \   000010   0D5D         RLA.W   R13
   \   000012   0D5D         RLA.W   R13
   \   000014   0F4D         MOV.W   R13, R15
   \   000016   0D5D         RLA.W   R13
   \   000018   0D5F         ADD.W   R15, R13
   \   00001A   0C5C         RLA.W   R12
   \   00001C   0F4C         MOV.W   R12, R15
   \   00001E   0C5C         RLA.W   R12
   \   000020   0C5C         RLA.W   R12
   \   000022   0F5C         ADD.W   R12, R15
   \   000024   0C5C         RLA.W   R12
   \   000026   0C5C         RLA.W   R12
   \   000028   0F5C         ADD.W   R12, R15
   \   00002A   0C5C         RLA.W   R12
   \   00002C   0F5C         ADD.W   R12, R15
   \   00002E   0C5C         RLA.W   R12
   \   000030   0C5C         RLA.W   R12
   \   000032   0C5F         ADD.W   R15, R12
   \   000034   0D5C         ADD.W   R12, R13
   \   000036   0F4D         MOV.W   R13, R15
   \   000038   3F50....     ADD.W   #working_data + 54, R15
   \   00003C   3C4F         MOV.W   @R15+, R12
   \   00003E   3D4F         MOV.W   @R15+, R13
   \   000040   3E4F         MOV.W   @R15+, R14
   \   000042   3F4F         MOV.W   @R15+, R15
   \   000044   3041         RET
    351              #else
    352              return 0;
    353              #endif
    354          }
    355          #endif
    356          
    357          #if defined(REACTIVE_ENERGY_SUPPORT)  ||  defined(TOTAL_REACTIVE_ENERGY_SUPPORT)
    358          energy_t reactive_energy(int phx, int quad)
    359          {
    360              if (phx == FAKE_PHASE_TOTAL)
    361                  #if defined(TOTAL_REACTIVE_ENERGY_SUPPORT)
    362                  return working_data.totals.energy.reactive[quad].energy;
    363                  #else
    364                  return 0;
    365                  #endif
    366              #if defined(REACTIVE_ENERGY_SUPPORT)
    367              return working_data.phases[phx].energy.reactive[quad].energy;
    368              #else
    369              return 0;
    370              #endif
    371          }
    372          #endif
    373          
    374          #if defined(APPARENT_ENERGY_SUPPORT)  ||  defined(TOTAL_APPARENT_ENERGY_SUPPORT)
    375          energy_t apparent_energy(int phx, int import_export)
    376          {
    377              if (phx == FAKE_PHASE_TOTAL)
    378                  #if defined(TOTAL_APPARENT_ENERGY_SUPPORT)
    379                  return working_data.totals.energy.apparent[import_export].energy;
    380                  #else
    381                  return 0;
    382                  #endif
    383              #if defined(APPARENT_ENERGY_SUPPORT)
    384              return working_data.phases[phx].energy.apparent[import_export].energy;
    385              #else
    386              return 0;
    387              #endif
    388          }
    389          #endif
    390          
    391          #if defined(SAG_SWELL_SUPPORT)
    392          int16_t sag_events(int phx, uint32_t *duration)
    393          {
    394              if (duration)
    395                  *duration = working_data.phases[phx].sag_duration;
    396              return working_data.phases[phx].sag_events;
    397          }
    398          
    399          int16_t swell_events(int phx, uint32_t *duration)
    400          {
    401              if (duration)
    402                  *duration = working_data.phases[phx].swell_duration;
    403              return working_data.phases[phx].swell_events;
    404          }
    405          #endif
    406          

   \                                 In  segment CODE, align 2
    407          int32_t voltage_dc_estimate(int phx)
   \                     voltage_dc_estimate:
    408          {
    409              return working_data.phases[phx].metrology.V_dc_estimate_logged;
   \   000000   0C5C         RLA.W   R12
   \   000002   0F4C         MOV.W   R12, R15
   \   000004   0C5C         RLA.W   R12
   \   000006   0C5C         RLA.W   R12
   \   000008   0F5C         ADD.W   R12, R15
   \   00000A   0C5C         RLA.W   R12
   \   00000C   0C5C         RLA.W   R12
   \   00000E   0F5C         ADD.W   R12, R15
   \   000010   0C5C         RLA.W   R12
   \   000012   0F5C         ADD.W   R12, R15
   \   000014   0C5C         RLA.W   R12
   \   000016   0C5C         RLA.W   R12
   \   000018   0C5F         ADD.W   R15, R12
   \   00001A   0D4C         MOV.W   R12, R13
   \   00001C   1C4D....     MOV.W   working_data + 82(R13), R12
   \   000020   1D4D....     MOV.W   working_data + 84(R13), R13
   \   000024   3041         RET
    410          }
    411          
    412          

   \                                 In  segment CODE, align 2
    413          int32_t current_dc_estimate(int phx)
   \                     current_dc_estimate:
    414          {
    415          #if defined(NEUTRAL_MONITOR_SUPPORT)
    416              if (phx == FAKE_PHASE_NEUTRAL)
    417              #if NUM_PHASES == 1
    418                  return working_data.phases[0].metrology.current[1].I_dc_estimate_logged;
    419              #else
    420                  return working_data.neutral.metrology.I_dc_estimate_logged;
    421              #endif
    422          #endif
    423              return working_data.phases[phx].metrology.current[0].I_dc_estimate_logged;
   \   000000   0C5C         RLA.W   R12
   \   000002   0F4C         MOV.W   R12, R15
   \   000004   0C5C         RLA.W   R12
   \   000006   0C5C         RLA.W   R12
   \   000008   0F5C         ADD.W   R12, R15
   \   00000A   0C5C         RLA.W   R12
   \   00000C   0C5C         RLA.W   R12
   \   00000E   0F5C         ADD.W   R12, R15
   \   000010   0C5C         RLA.W   R12
   \   000012   0F5C         ADD.W   R12, R15
   \   000014   0C5C         RLA.W   R12
   \   000016   0C5C         RLA.W   R12
   \   000018   0C5F         ADD.W   R15, R12
   \   00001A   0D4C         MOV.W   R12, R13
   \   00001C   1C4D....     MOV.W   working_data + 236(R13), R12
   \   000020   1D4D....     MOV.W   working_data + 238(R13), R13
   \   000024   3041         RET
    424          }
    425          

   \                                 In  segment CODE, align 2
    426          int64_t dot_product(int phx, int which, uint16_t *samples)
   \                     dot_product:
    427          {
   \   000000   0A12         PUSH.W  R10
   \   000002   0B12         PUSH.W  R11
   \   000004   0812         PUSH.W  R8
   \   000006   0912         PUSH.W  R9
    428              #if defined(NEUTRAL_MONITOR_SUPPORT)
    429              if (phx == FAKE_PHASE_NEUTRAL)
    430              {
    431                  #if NUM_PHASES == 1
    432                  *samples = working_data.phases[0].metrology.current[1].dot_prod[1].sample_count;
    433                  switch (which)
    434                  {
    435                  case DOT_PRODUCT_TYPE_P_ACTIVE:
    436                      return assign_ac_power(working_data.phases[0].metrology.current[1].dot_prod[1].P_active);
    437                      #if defined(FUNDAMENTAL_ACTIVE_POWER_SUPPORT)
    438                  case DOT_PRODUCT_TYPE_P_FUNDAMENTAL_ACTIVE:
    439                      return assign_ac_power(working_data.phases[0].metrology.current[1].dot_prod[1].P_fundamental_active);
    440                      #endif
    441                      #if defined(REACTIVE_POWER_BY_QUADRATURE_SUPPORT)
    442                  case DOT_PRODUCT_TYPE_P_REACTIVE:
    443                      return assign_ac_power(working_data.phases[0].metrology.current[1].dot_prod[1].P_reactive);
    444                      #endif
    445                      #if defined(FUNDAMENTAL_REACTIVE_POWER_SUPPORT)
    446                  case DOT_PRODUCT_TYPE_P_FUNDAMENTAL_REACTIVE:
    447                      return assign_ac_power(working_data.phases[0].metrology.current[1].dot_prod[1].P_fundamental_reactive);
    448                      #endif
    449                      #if defined(IRMS_SUPPORT)
    450                  case DOT_PRODUCT_TYPE_I_SQUARED:
    451                      return assign_ac_current(working_data.phases[0].metrology.current[1].dot_prod[1].I_sq);
    452                      #endif
    453                  }
    454                  #else
    455                  *samples = working_data.neutral.metrology.dot_prod[1].sample_count;
    456                  switch (which)
    457                  {
    458                      #if defined(IRMS_SUPPORT)
    459                  case DOT_PRODUCT_TYPE_V_SQUARED:
    460                      return assign_ac_current(working_data.neutral.metrology.dot_prod[1].I_sq);
    461                      #endif
    462                      #if defined(RESIDUAL_IRMS_SUPPORT)
    463                  case DOT_PRODUCT_TYPE_I_RESIDUAL_SQUARED:
    464                      return assign_ac_current(working_data.neutral.metrology.dot_prod[1].residual_I_sq);
    465                      #endif
    466                  }
    467                  #endif
    468              }
    469              #endif
    470              *samples = working_data.phases[phx].metrology.current[0].dot_prod[1].sample_count;
   \   000008   0C5C         RLA.W   R12
   \   00000A   0F4C         MOV.W   R12, R15
   \   00000C   0C5C         RLA.W   R12
   \   00000E   0C5C         RLA.W   R12
   \   000010   0F5C         ADD.W   R12, R15
   \   000012   0C5C         RLA.W   R12
   \   000014   0C5C         RLA.W   R12
   \   000016   0F5C         ADD.W   R12, R15
   \   000018   0C5C         RLA.W   R12
   \   00001A   0F5C         ADD.W   R12, R15
   \   00001C   0C5C         RLA.W   R12
   \   00001E   0C5C         RLA.W   R12
   \   000020   0C5F         ADD.W   R15, R12
   \   000022   9E4C....0000 MOV.W   working_data + 326(R12), 0(R14)
    471              switch (which)
   \   000028   0D83         SUB.W   #0x0, R13
   \   00002A   0D24         JEQ     ??dot_product_1
   \   00002C   1D83         SUB.W   #0x1, R13
   \   00002E   1324         JEQ     ??dot_product_2
   \   000030   1D83         SUB.W   #0x1, R13
   \   000032   1924         JEQ     ??dot_product_3
   \   000034   1D83         SUB.W   #0x1, R13
   \   000036   2624         JEQ     ??dot_product_4
   \   000038   1D83         SUB.W   #0x1, R13
   \   00003A   1824         JEQ     ??dot_product_5
   \   00003C   1D83         SUB.W   #0x1, R13
   \   00003E   0724         JEQ     ??dot_product_6
   \   000040   1D83         SUB.W   #0x1, R13
   \   000042   0D24         JEQ     ??dot_product_7
   \   000044   273C         JMP     ??dot_product_8
    472              {
    473              case DOT_PRODUCT_TYPE_P_ACTIVE:
    474                  return assign_ac_power(working_data.phases[phx].metrology.current[0].dot_prod[1].P_active);
   \                     ??dot_product_1:
   \   000046   0F4C         MOV.W   R12, R15
   \   000048   3F50....     ADD.W   #working_data + 286, R15
   \   00004C   1E3C         JMP     ??dot_product_0
    475                  #if defined(FUNDAMENTAL_ACTIVE_POWER_SUPPORT)
    476              case DOT_PRODUCT_TYPE_P_FUNDAMENTAL_ACTIVE:
    477                  return assign_ac_power(working_data.phases[phx].metrology.current[0].dot_prod[1].P_fundamental_active);
   \                     ??dot_product_6:
   \   00004E   0F4C         MOV.W   R12, R15
   \   000050   3F50....     ADD.W   #working_data + 302, R15
   \   000054   1A3C         JMP     ??dot_product_0
    478                  #endif
    479                  #if defined(REACTIVE_POWER_BY_QUADRATURE_SUPPORT)
    480              case DOT_PRODUCT_TYPE_P_REACTIVE:
    481                  return assign_ac_power(working_data.phases[phx].metrology.current[0].dot_prod[1].P_reactive);
   \                     ??dot_product_2:
   \   000056   0F4C         MOV.W   R12, R15
   \   000058   3F50....     ADD.W   #working_data + 294, R15
   \   00005C   163C         JMP     ??dot_product_0
    482                  #endif
    483                  #if defined(FUNDAMENTAL_REACTIVE_POWER_SUPPORT)
    484              case DOT_PRODUCT_TYPE_P_FUNDAMENTAL_REACTIVE:
    485                  return assign_ac_power(working_data.phases[phx].metrology.current[0].dot_prod[1].P_fundamental_reactive);
   \                     ??dot_product_7:
   \   00005E   0F4C         MOV.W   R12, R15
   \   000060   3F50....     ADD.W   #working_data + 310, R15
   \   000064   123C         JMP     ??dot_product_0
    486                  #endif
    487                  #if defined(VRMS_SUPPORT)
    488              case DOT_PRODUCT_TYPE_V_SQUARED:
    489                  return assign_ac_voltage(working_data.phases[phx].metrology.dot_prod[1].V_sq);
   \                     ??dot_product_3:
   \   000066   3C50....     ADD.W   #working_data + 216, R12
   \   00006A   023C         JMP     ??dot_product_9
    490                  #endif
    491                  #if defined(FUNDAMENTAL_ACTIVE_POWER_SUPPORT)  ||  defined(FUNDAMENTAL_REACTIVE_POWER_SUPPORT)  ||  defined(FUNDAMENTAL_VRMS_SUPPORT)  ||  defined(FUNDAMENTAL_IRMS_SUPPORT)
    492              case DOT_PRODUCT_TYPE_V_FUNDAMENTAL_SQUARED:
    493                  return assign_ac_voltage(working_data.phases[phx].metrology.dot_prod[1].V_fundamental);
   \                     ??dot_product_5:
   \   00006C   3C50....     ADD.W   #working_data + 222, R12
   \                     ??dot_product_9:
   \   000070   1E4C0400     MOV.W   0x4(R12), R14
   \   000074   0F4E         MOV.W   R14, R15
   \   000076   3FE3         XOR.W   #0xffff, R15
   \   000078   0F5F         RLA.W   R15
   \   00007A   0F7F         SUBC.W  R15, R15
   \   00007C   1D4C0200     MOV.W   0x2(R12), R13
   \   000080   2C4C         MOV.W   @R12, R12
   \   000082   0C3C         JMP     ??dot_product_10
    494                  #endif
    495                  #if defined(IRMS_SUPPORT)
    496              case DOT_PRODUCT_TYPE_I_SQUARED:
    497                  return assign_ac_current(working_data.phases[phx].metrology.current[0].dot_prod[1].I_sq);
   \                     ??dot_product_4:
   \   000084   0F4C         MOV.W   R12, R15
   \   000086   3F50....     ADD.W   #working_data + 318, R15
   \                     ??dot_product_0:
   \   00008A   3C4F         MOV.W   @R15+, R12
   \   00008C   3D4F         MOV.W   @R15+, R13
   \   00008E   3E4F         MOV.W   @R15+, R14
   \   000090   3F4F         MOV.W   @R15+, R15
   \   000092   043C         JMP     ??dot_product_10
    498                  #endif
    499              }
    500              return 0;
   \                     ??dot_product_8:
   \   000094   0C43         MOV.W   #0x0, R12
   \   000096   0D43         MOV.W   #0x0, R13
   \   000098   0E43         MOV.W   #0x0, R14
   \   00009A   0F43         MOV.W   #0x0, R15
   \                     ??dot_product_10:
   \   00009C   3040....     BR      #?Epilogue4
    501          }
    502          

   \                                 In  segment CODE, align 2
    503          int temperature(void)
   \                     temperature:
    504          {
    505          #if defined(TEMPERATURE_SUPPORT)
    506              return temperature_in_celsius;
   \   000000   1C42....     MOV.W   &temperature_in_celsius, R12
   \   000004   3041         RET
    507          #else
    508              return 0x8000;
    509          #endif
    510          }
    511          

   \                                 In  segment CODE, align 2
    512          uint16_t phase_status(int phx)
   \                     phase_status:
    513          {
    514              uint16_t status;
    515          
    516          #if NUM_PHASES > 1  &&  defined(NEUTRAL_MONITOR_SUPPORT)
    517              if (phx == FAKE_PHASE_NEUTRAL)
    518              {
    519                  status = working_data.neutral.status;
    520                  working_data.neutral.status &= ~PHASE_STATUS_NEW_LOG;
    521                  return status;
    522              }
    523          #endif
    524              status = working_data.phases[phx].status;
   \   000000   0C5C         RLA.W   R12
   \   000002   0F4C         MOV.W   R12, R15
   \   000004   0C5C         RLA.W   R12
   \   000006   0C5C         RLA.W   R12
   \   000008   0F5C         ADD.W   R12, R15
   \   00000A   0C5C         RLA.W   R12
   \   00000C   0C5C         RLA.W   R12
   \   00000E   0F5C         ADD.W   R12, R15
   \   000010   0C5C         RLA.W   R12
   \   000012   0F5C         ADD.W   R12, R15
   \   000014   0C5C         RLA.W   R12
   \   000016   0C5C         RLA.W   R12
   \   000018   0C5F         ADD.W   R15, R12
   \   00001A   1F4C....     MOV.W   working_data + 360(R12), R15
    525              working_data.phases[phx].status &= ~PHASE_STATUS_NEW_LOG;
   \   00001E   9CC3....     BIC.W   #0x1, working_data + 360(R12)
    526              return status;
   \   000022   0C4F         MOV.W   R15, R12
   \   000024   3041         RET
    527          }
    528          
    529          //uint16_t metrology_status(void)
    530          //{ 
    531          //    return metrology_state; - removed by mars 20130204
    532          //}
    533          
    534          //int meter_calibrated(void)
    535          //{
    536          //    return !nv_parms.seg_a.s.header.calibration_status;
    537          //}
    538          

   \                                 In  segment CODE, align 2
    539          int16_t get_v_dc_estimate(int phx)
   \                     get_v_dc_estimate:
    540          {
    541            return (int16_t)(working_data.phases[phx].metrology.V_dc_estimate_logged >> 8);
   \   000000   0C5C         RLA.W   R12
   \   000002   0F4C         MOV.W   R12, R15
   \   000004   0C5C         RLA.W   R12
   \   000006   0C5C         RLA.W   R12
   \   000008   0F5C         ADD.W   R12, R15
   \   00000A   0C5C         RLA.W   R12
   \   00000C   0C5C         RLA.W   R12
   \   00000E   0F5C         ADD.W   R12, R15
   \   000010   0C5C         RLA.W   R12
   \   000012   0F5C         ADD.W   R12, R15
   \   000014   0C5C         RLA.W   R12
   \   000016   0C5C         RLA.W   R12
   \   000018   0C5F         ADD.W   R15, R12
   \   00001A   0D4C         MOV.W   R12, R13
   \   00001C   1C4D....     MOV.W   working_data + 82(R13), R12
   \   000020   1D4D....     MOV.W   working_data + 84(R13), R13
   \   000024   8C10         SWPB    R12
   \   000026   8D10         SWPB    R13
   \   000028   4CED         XOR.B   R13, R12
   \   00002A   0CED         XOR.W   R13, R12
   \   00002C   3041         RET
    542          }
    543          

   \                                 In  segment CODE, align 2
    544          int16_t get_initial_v_dc_estimate (int phx)
   \                     get_initial_v_dc_estimate:
    545          {
    546            return cal_info->phases[phx].initial_v_dc_estimate[0];
   \   000000   0C5C         RLA.W   R12
   \   000002   0F4C         MOV.W   R12, R15
   \   000004   0C5C         RLA.W   R12
   \   000006   0C5C         RLA.W   R12
   \   000008   0F5C         ADD.W   R12, R15
   \   00000A   0C5C         RLA.W   R12
   \   00000C   0C5F         ADD.W   R15, R12
   \   00000E   1C4C....     MOV.W   nv_parms + 16(R12), R12
   \   000012   3041         RET
    547          }
    548          

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine1:
   \   000000   B012....     CALL    #flash_write_int16
   \   000004   3040....     BR      #flash_secure

   \                                 In  segment CODE, align 2
    549          void set_v_dc_estimate(int phx, int16_t value)
   \                     set_v_dc_estimate:
    550          {
    551          //    value = (int16_t)(working_data.phases[phx].metrology.V_dc_estimate_logged >> 8) ;
    552              flash_write_int16((int16_t *) &cal_info->phases[phx].initial_v_dc_estimate[0], value);
   \   000000   0C5C         RLA.W   R12
   \   000002   0F4C         MOV.W   R12, R15
   \   000004   0C5C         RLA.W   R12
   \   000006   0C5C         RLA.W   R12
   \   000008   0F5C         ADD.W   R12, R15
   \   00000A   0C5C         RLA.W   R12
   \   00000C   0C5F         ADD.W   R15, R12
   \   00000E   3C50....     ADD.W   #nv_parms + 16, R12
   \   000012   ....         JMP     ?Subroutine1
    553          #if defined(LIMP_MODE_SUPPORT)
    554              flash_write_int16((int16_t *) &cal_info->phases[phx].lower_v_dc_estimate[0], value - 100);
    555              flash_write_int16((int16_t *) &cal_info->phases[phx].upper_v_dc_estimate[0], value + 100);
    556          #endif
    557              flash_secure();
    558          }
    559          
    560          //int32_t get_i_dc_estimate (int phx)
    561          //{
    562          //  return (int32_t)(working_data.phases[phx].metrology.current[0].I_dc_estimate_logged);
    563          //}
    564          

   \                                 In  segment CODE, align 2, keep-with-next
    565          int32_t get_initial_i_dc_estimate(int phx)
   \                     get_initial_i_dc_estimate:
    566          {
    567          #if defined(NEUTRAL_MONITOR_SUPPORT)
    568              if (phx == FAKE_PHASE_NEUTRAL)
    569              {
    570              #if NUM_PHASES > 1
    571                  return cal_info->neutral.initial_dc_estimate[0];
    572              #else
    573                  return cal_info->phases[0].current[1].initial_dc_estimate[0];
    574              #endif
    575              }
    576          #endif
    577              return cal_info->phases[phx].current[0].initial_dc_estimate[0];
   \   000000   0C5C         RLA.W   R12
   \   000002   0F4C         MOV.W   R12, R15
   \   000004   0C5C         RLA.W   R12
   \   000006   0C5C         RLA.W   R12
   \   000008   0F5C         ADD.W   R12, R15
   \   00000A   0C5C         RLA.W   R12
   \   00000C   0C5F         ADD.W   R15, R12
   \   00000E   0D4C         MOV.W   R12, R13
   \   000010   1C4D....     MOV.W   nv_parms + 2(R13), R12
   \   000014   1D4D....     MOV.W   nv_parms + 4(R13), R13
   \   000018   3041         RET
    578          }
    579          

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine2:
   \   000000   B012....     CALL    #flash_write_int32
   \   000004   3040....     BR      #flash_secure

   \                                 In  segment CODE, align 2, keep-with-next
    580          void set_i_dc_estimate(int phx, int32_t value)
   \                     set_i_dc_estimate:
    581          {
    582          //    value = (int32_t)(working_data.phases[phx].metrology.current[0].I_dc_estimate_logged) ;
    583          #if defined(NEUTRAL_MONITOR_SUPPORT)
    584              if (phx == FAKE_PHASE_NEUTRAL)
    585              {
    586              #if NUM_PHASES > 1
    587                  flash_write_int32((int32_t *) &cal_info->neutral.initial_dc_estimate[0], value);
    588              #else
    589                  flash_write_int32((int32_t *) &cal_info->phases[0].current[1].initial_dc_estimate[0], value);
    590              #endif
    591              }
    592              else
    593          #endif
    594              {
    595                  flash_write_int32((int32_t *) &cal_info->phases[phx].current[0].initial_dc_estimate[0], value);
   \   000000   0C5C         RLA.W   R12
   \   000002   0D4C         MOV.W   R12, R13
   \   000004   0C5C         RLA.W   R12
   \   000006   0C5C         RLA.W   R12
   \   000008   0D5C         ADD.W   R12, R13
   \   00000A   0C5C         RLA.W   R12
   \   00000C   0C5D         ADD.W   R13, R12
   \   00000E   3C50....     ADD.W   #nv_parms + 2, R12
   \   000012   ....         JMP     ?Subroutine2
    596              }
    597              flash_secure();
    598          }
    599          

   \                                 In  segment CODE, align 2, keep-with-next
    600          int32_t get_v_ac_offset(int phx)
   \                     get_v_ac_offset:
    601          {
    602              return cal_info->phases[phx].v_ac_offset;
   \   000000   0C5C         RLA.W   R12
   \   000002   0F4C         MOV.W   R12, R15
   \   000004   0C5C         RLA.W   R12
   \   000006   0C5C         RLA.W   R12
   \   000008   0F5C         ADD.W   R12, R15
   \   00000A   0C5C         RLA.W   R12
   \   00000C   0C5F         ADD.W   R15, R12
   \   00000E   0D4C         MOV.W   R12, R13
   \   000010   1C4D....     MOV.W   nv_parms + 22(R13), R12
   \   000014   1D4D....     MOV.W   nv_parms + 24(R13), R13
   \   000018   3041         RET
    603          }
    604          

   \                                 In  segment CODE, align 2, keep-with-next
    605          void set_v_ac_offset(int phx, int32_t value)
   \                     set_v_ac_offset:
    606          {
    607              flash_write_int32((int32_t *) &cal_info->phases[phx].v_ac_offset, value);
   \   000000   0C5C         RLA.W   R12
   \   000002   0D4C         MOV.W   R12, R13
   \   000004   0C5C         RLA.W   R12
   \   000006   0C5C         RLA.W   R12
   \   000008   0D5C         ADD.W   R12, R13
   \   00000A   0C5C         RLA.W   R12
   \   00000C   0C5D         ADD.W   R13, R12
   \   00000E   3C50....     ADD.W   #nv_parms + 22, R12
   \   000012   ....         JMP     ?Subroutine2
    608              flash_secure();
    609          }
    610          

   \                                 In  segment CODE, align 2, keep-with-next
    611          int32_t get_i_ac_offset(int phx)
   \                     get_i_ac_offset:
    612          {
    613          #if defined(NEUTRAL_MONITOR_SUPPORT)
    614              if (phx == FAKE_PHASE_NEUTRAL)
    615              {
    616              #if NUM_PHASES > 1
    617                  return cal_info->neutral.ac_offset;
    618              #else
    619                  return cal_info->phases[0].current[1].ac_offset;
    620              #endif
    621              }
    622          #endif
    623              return cal_info->phases[phx].current[0].ac_offset;
   \   000000   0C5C         RLA.W   R12
   \   000002   0F4C         MOV.W   R12, R15
   \   000004   0C5C         RLA.W   R12
   \   000006   0C5C         RLA.W   R12
   \   000008   0F5C         ADD.W   R12, R15
   \   00000A   0C5C         RLA.W   R12
   \   00000C   0C5F         ADD.W   R15, R12
   \   00000E   0D4C         MOV.W   R12, R13
   \   000010   1C4D....     MOV.W   nv_parms + 6(R13), R12
   \   000014   1D4D....     MOV.W   nv_parms + 8(R13), R13
   \   000018   3041         RET
    624          }
    625          

   \                                 In  segment CODE, align 2, keep-with-next
    626          void set_i_ac_offset(int phx, int32_t value)
   \                     set_i_ac_offset:
    627          {
    628          #if defined(NEUTRAL_MONITOR_SUPPORT)
    629              if (phx == FAKE_PHASE_NEUTRAL)
    630              {
    631              #if NUM_PHASES > 1
    632                  flash_write_int32((int32_t *) &cal_info->neutral.ac_offset, value);
    633              #else
    634                  flash_write_int32((int32_t *) &cal_info->phases[0].current[1].ac_offset, value);
    635              #endif
    636              }
    637              else
    638          #endif
    639              {
    640                  flash_write_int32((int32_t *) &cal_info->phases[phx].current[0].ac_offset, value);
   \   000000   0C5C         RLA.W   R12
   \   000002   0D4C         MOV.W   R12, R13
   \   000004   0C5C         RLA.W   R12
   \   000006   0C5C         RLA.W   R12
   \   000008   0D5C         ADD.W   R12, R13
   \   00000A   0C5C         RLA.W   R12
   \   00000C   0C5D         ADD.W   R13, R12
   \   00000E   3C50....     ADD.W   #nv_parms + 6, R12
   \   000012                REQUIRE ?Subroutine2
   \   000012                // Fall through to label ?Subroutine2
    641              }
    642              flash_secure();
    643          }
    644          

   \                                 In  segment CODE, align 2, keep-with-next
    645          int16_t get_phase_corr(int phx)
   \                     get_phase_corr:
    646          {
    647          #if defined(NEUTRAL_MONITOR_SUPPORT)
    648              if (phx == FAKE_PHASE_NEUTRAL)
    649              {
    650              #if NUM_PHASES > 1
    651                  return cal_info->neutral.phase_correction << 3;
    652              #else
    653                  return cal_info->phases[0].current[1].phase_correction << 3;
    654              #endif
    655              }
    656          #endif
    657              return cal_info->phases[phx].current[0].phase_correction << 3;
   \   000000   0C5C         RLA.W   R12
   \   000002   0F4C         MOV.W   R12, R15
   \   000004   0C5C         RLA.W   R12
   \   000006   0C5C         RLA.W   R12
   \   000008   0F5C         ADD.W   R12, R15
   \   00000A   0C5C         RLA.W   R12
   \   00000C   0C5F         ADD.W   R15, R12
   \   00000E   1C4C....     MOV.W   nv_parms + 10(R12), R12
   \   000012   0C5C         RLA.W   R12
   \   000014   0C5C         RLA.W   R12
   \   000016   0C5C         RLA.W   R12
   \   000018   3041         RET
    658          }
    659          

   \                                 In  segment CODE, align 2, keep-with-next
    660          void set_phase_corr(int phx, int16_t value)
   \                     set_phase_corr:
    661          {
    662              value >>= 3;
    663          
    664          #if defined(NEUTRAL_MONITOR_SUPPORT)
    665              if (phx == FAKE_PHASE_NEUTRAL)
    666              {
    667              #if NUM_PHASES > 1
    668                  flash_write_int16((int16_t *) &cal_info->neutral.phase_correction, value);
    669              #else
    670                  flash_write_int16((int16_t *) &cal_info->phases[0].current[1].phase_correction, value);
    671              #endif
    672              }
    673              else
    674          #endif
    675              {
    676                  flash_write_int16((int16_t *) &cal_info->phases[phx].current[0].phase_correction, value);
   \   000000   0D11         RRA.W   R13
   \   000002   0D11         RRA.W   R13
   \   000004   0D11         RRA.W   R13
   \   000006   0C5C         RLA.W   R12
   \   000008   0F4C         MOV.W   R12, R15
   \   00000A   0C5C         RLA.W   R12
   \   00000C   0C5C         RLA.W   R12
   \   00000E   0F5C         ADD.W   R12, R15
   \   000010   0C5C         RLA.W   R12
   \   000012   0C5F         ADD.W   R15, R12
   \   000014   3C50....     ADD.W   #nv_parms + 10, R12
   \   000018   ....         JMP     ?Subroutine1
    677              }
    678              flash_secure();
    679          }
    680          

   \                                 In  segment CODE, align 2, keep-with-next
    681          calibration_scaling_factor_t get_V_rms_scaling(int phx)
   \                     get_V_rms_scaling:
    682          {
    683              return cal_info->phases[phx].V_rms_scale_factor[0];
   \   000000   0C5C         RLA.W   R12
   \   000002   0F4C         MOV.W   R12, R15
   \   000004   0C5C         RLA.W   R12
   \   000006   0C5C         RLA.W   R12
   \   000008   0F5C         ADD.W   R12, R15
   \   00000A   0C5C         RLA.W   R12
   \   00000C   0C5F         ADD.W   R15, R12
   \   00000E   1C4C....     MOV.W   nv_parms + 26(R12), R12
   \   000012   3041         RET
    684          }
    685          

   \                                 In  segment CODE, align 2, keep-with-next
    686          void set_V_rms_scaling(int phx, calibration_scaling_factor_t value)
   \                     set_V_rms_scaling:
    687          {
    688              flash_write_int16((int16_t *) &cal_info->phases[phx].V_rms_scale_factor[0], value);
   \   000000   0C5C         RLA.W   R12
   \   000002   0F4C         MOV.W   R12, R15
   \   000004   0C5C         RLA.W   R12
   \   000006   0C5C         RLA.W   R12
   \   000008   0F5C         ADD.W   R12, R15
   \   00000A   0C5C         RLA.W   R12
   \   00000C   0C5F         ADD.W   R15, R12
   \   00000E   3C50....     ADD.W   #nv_parms + 26, R12
   \   000012   ....         JMP     ?Subroutine1
    689              flash_secure();
    690          }
    691          

   \                                 In  segment CODE, align 2, keep-with-next
    692          calibration_scaling_factor_t get_I_rms_scaling(int phx)
   \                     get_I_rms_scaling:
    693          {
    694          #if defined(NEUTRAL_MONITOR_SUPPORT)
    695              if (phx == FAKE_PHASE_NEUTRAL)
    696              {
    697              #if NUM_PHASES > 1
    698                  return cal_info->neutral.I_rms_scale_factor[0];
    699              #else
    700                  return cal_info->phases[0].current[1].I_rms_scale_factor[0];
    701              #endif
    702              }
    703          #endif
    704              return cal_info->phases[phx].current[0].I_rms_scale_factor[0];
   \   000000   0C5C         RLA.W   R12
   \   000002   0F4C         MOV.W   R12, R15
   \   000004   0C5C         RLA.W   R12
   \   000006   0C5C         RLA.W   R12
   \   000008   0F5C         ADD.W   R12, R15
   \   00000A   0C5C         RLA.W   R12
   \   00000C   0C5F         ADD.W   R15, R12
   \   00000E   1C4C....     MOV.W   nv_parms + 12(R12), R12
   \   000012   3041         RET
    705          }
    706          

   \                                 In  segment CODE, align 2, keep-with-next
    707          void set_I_rms_scaling(int phx, calibration_scaling_factor_t value)
   \                     set_I_rms_scaling:
    708          {
    709          #if defined(NEUTRAL_MONITOR_SUPPORT)
    710              if (phx == FAKE_PHASE_NEUTRAL)
    711              {
    712              #if NUM_PHASES > 1
    713                  flash_write_int16((int16_t *) &cal_info->neutral.I_rms_scale_factor[0], value);
    714              #else
    715                  flash_write_int16((int16_t *) &cal_info->phases[0].current[1].I_rms_scale_factor[0], value);
    716              #endif
    717              }
    718              else
    719          #endif
    720              {
    721                  flash_write_int16((int16_t *) &cal_info->phases[phx].current[0].I_rms_scale_factor[0], value);
   \   000000   0C5C         RLA.W   R12
   \   000002   0F4C         MOV.W   R12, R15
   \   000004   0C5C         RLA.W   R12
   \   000006   0C5C         RLA.W   R12
   \   000008   0F5C         ADD.W   R12, R15
   \   00000A   0C5C         RLA.W   R12
   \   00000C   0C5F         ADD.W   R15, R12
   \   00000E   3C50....     ADD.W   #nv_parms + 12, R12
   \   000012                REQUIRE ?Subroutine1
   \   000012                // Fall through to label ?Subroutine1
    722              }
    723              flash_secure();
    724          }
    725          

   \                                 In  segment CODE, align 2, keep-with-next
    726          calibration_scaling_factor_t get_P_scaling(int phx)
   \                     get_P_scaling:
    727          {
    728          #if NUM_PHASES == 1  &&  defined(NEUTRAL_MONITOR_SUPPORT)
    729              if (phx == FAKE_PHASE_NEUTRAL)
    730                  return cal_info->phases[0].current[1].P_scale_factor;
    731          #endif
    732              return cal_info->phases[phx].current[0].P_scale_factor;
   \   000000   0C5C         RLA.W   R12
   \   000002   0F4C         MOV.W   R12, R15
   \   000004   0C5C         RLA.W   R12
   \   000006   0C5C         RLA.W   R12
   \   000008   0F5C         ADD.W   R12, R15
   \   00000A   0C5C         RLA.W   R12
   \   00000C   0C5F         ADD.W   R15, R12
   \   00000E   1C4C....     MOV.W   nv_parms + 14(R12), R12
   \   000012   3041         RET
    733          }
    734          

   \                                 In  segment CODE, align 2, keep-with-next
    735          void set_P_scaling(int phx, calibration_scaling_factor_t value)
   \                     set_P_scaling:
    736          {
    737          #if NUM_PHASES == 1  &&  defined(NEUTRAL_MONITOR_SUPPORT)
    738              if (phx == FAKE_PHASE_NEUTRAL)
    739                  flash_write_int16((int16_t *) &cal_info->phases[0].current[1].P_scale_factor, value);
    740              else
    741          #endif
    742                  flash_write_int16((int16_t *) &cal_info->phases[phx].current[0].P_scale_factor, value);
   \   000000   0C5C         RLA.W   R12
   \   000002   0F4C         MOV.W   R12, R15
   \   000004   0C5C         RLA.W   R12
   \   000006   0C5C         RLA.W   R12
   \   000008   0F5C         ADD.W   R12, R15
   \   00000A   0C5C         RLA.W   R12
   \   00000C   0C5F         ADD.W   R15, R12
   \   00000E   3C50....     ADD.W   #nv_parms + 14, R12
   \   000012   ....         JMP     ?Subroutine1
    743              flash_secure();
    744          }
    745          

   \                                 In  segment CODE, align 2, keep-with-next
    746          int get_calibration_status(void)
   \                     get_calibration_status:
    747          {
    748              return nv_parms.seg_a.s.header.calibration_status; 
   \   000000   1C42....     MOV.W   &nv_parms, R12
   \   000004   3041         RET
    749          }
    750          

   \                                 In  segment CODE, align 2, keep-with-next
    751          void set_calibration_status(int value)
   \                     set_calibration_status:
    752          {
    753              flash_write_int16((int16_t *) &nv_parms.seg_a.s.header.calibration_status, value);
   \   000000   0D4C         MOV.W   R12, R13
   \   000002   3C40....     MOV.W   #nv_parms, R12
   \   000006   ....         JMP     ?Subroutine1
    754              flash_secure();
    755          }
    756          
    757          #if defined(TEMPERATURE_SUPPORT)

   \                                 In  segment CODE, align 2, keep-with-next
    758          int16_t get_temperature_intercept(void)
   \                     get_temperature_intercept:
    759          {
    760              return cal_info->temperature_sensor_intercept;
   \   000000   1C42....     MOV.W   &nv_parms + 30, R12
   \   000004   3041         RET
    761          }
    762          

   \                                 In  segment CODE, align 2, keep-with-next
    763          int16_t get_temperature_slope(void)
   \                     get_temperature_slope:
    764          {
    765              return cal_info->temperature_sensor_slope;
   \   000000   1C42....     MOV.W   &nv_parms + 32, R12
   \   000004   3041         RET
    766          }
    767          

   \                                 In  segment CODE, align 2, keep-with-next
    768          void set_temperature_parameters(int16_t temperature_at_calibration, int16_t temperature_sensor_intercept, int16_t temperature_sensor_slope)
   \                     set_temperature_parameters:
    769          {
   \   000000   0A12         PUSH.W  R10
   \   000002   0B12         PUSH.W  R11
   \   000004   0A4D         MOV.W   R13, R10
   \   000006   0B4E         MOV.W   R14, R11
    770              flash_write_int16((int16_t *) &cal_info->temperature_at_calibration, temperature_at_calibration);
   \   000008   0D4C         MOV.W   R12, R13
   \   00000A   3C40....     MOV.W   #nv_parms + 28, R12
   \   00000E   B012....     CALL    #flash_write_int16
    771              flash_write_int16((int16_t *) &cal_info->temperature_sensor_intercept, temperature_sensor_intercept);
   \   000012   0D4A         MOV.W   R10, R13
   \   000014   3C40....     MOV.W   #nv_parms + 30, R12
   \   000018   B012....     CALL    #flash_write_int16
    772              flash_write_int16((int16_t *) &cal_info->temperature_sensor_slope, temperature_sensor_slope);
   \   00001C   0D4B         MOV.W   R11, R13
   \   00001E   3C40....     MOV.W   #nv_parms + 32, R12
   \   000022   B012....     CALL    #flash_write_int16
    773              flash_secure();
   \   000026   B012....     CALL    #flash_secure
    774          }
   \   00002A   3B41         POP.W   R11
   \   00002C   3A41         POP.W   R10
   \   00002E   3041         RET
    775          #endif
    776                                 

   \                                 In  segment CODE, align 2, keep-with-next
    777          uint16_t get_compensate_capacitor_value (int phx)
   \                     get_compensate_capacitor_value:
    778          {
    779          #if defined (CAPACITOR_COMPENSATE_ON)
    780              return (uint16_t)(cal_info->phases[phx].initial_compensate_capacitance[0]);
   \   000000   0C5C         RLA.W   R12
   \   000002   0F4C         MOV.W   R12, R15
   \   000004   0C5C         RLA.W   R12
   \   000006   0C5C         RLA.W   R12
   \   000008   0F5C         ADD.W   R12, R15
   \   00000A   0C5C         RLA.W   R12
   \   00000C   0C5F         ADD.W   R15, R12
   \   00000E   1C4C....     MOV.W   nv_parms + 18(R12), R12
   \   000012   3041         RET
    781          #else
    782              return 0;
    783          #endif
    784          }
    785            

   \                                 In  segment CODE, align 2, keep-with-next
    786          void set_compensate_capacitor_value(int phx, uint16_t value)
   \                     set_compensate_capacitor_value:
    787          {
    788          #if defined (CAPACITOR_COMPENSATE_ON)
    789              flash_write_int16((int16_t *)&cal_info->phases[phx].initial_compensate_capacitance[0], value);
   \   000000   0C5C         RLA.W   R12
   \   000002   0F4C         MOV.W   R12, R15
   \   000004   0C5C         RLA.W   R12
   \   000006   0C5C         RLA.W   R12
   \   000008   0F5C         ADD.W   R12, R15
   \   00000A   0C5C         RLA.W   R12
   \   00000C   0C5F         ADD.W   R15, R12
   \   00000E   3C50....     ADD.W   #nv_parms + 18, R12
   \   000012   ....         JMP     ?Subroutine1
    790              flash_secure();
    791          #endif
    792          }
    793          

   \                                 In  segment CODE, align 2, keep-with-next
    794          uint16_t get_compensate_resistance (int phx)
   \                     get_compensate_resistance:
    795          {
    796          #if defined (WIRE_RESISTANCE_COMPENSATE)
    797              return (uint16_t)(cal_info->phases[phx].initial_compensate_resistance[0]);
   \   000000   0C5C         RLA.W   R12
   \   000002   0F4C         MOV.W   R12, R15
   \   000004   0C5C         RLA.W   R12
   \   000006   0C5C         RLA.W   R12
   \   000008   0F5C         ADD.W   R12, R15
   \   00000A   0C5C         RLA.W   R12
   \   00000C   0C5F         ADD.W   R15, R12
   \   00000E   1C4C....     MOV.W   nv_parms + 20(R12), R12
   \   000012   3041         RET
    798          #else
    799              return 0;
    800          #endif
    801          }
    802            

   \                                 In  segment CODE, align 2, keep-with-next
    803          void set_compensate_resistance(int phx, uint16_t value)
   \                     set_compensate_resistance:
    804          {
    805          #if defined (WIRE_RESISTANCE_COMPENSATE)
    806              flash_write_int16((int16_t *)&cal_info->phases[phx].initial_compensate_resistance[0], value);
   \   000000   0C5C         RLA.W   R12
   \   000002   0F4C         MOV.W   R12, R15
   \   000004   0C5C         RLA.W   R12
   \   000006   0C5C         RLA.W   R12
   \   000008   0F5C         ADD.W   R12, R15
   \   00000A   0C5C         RLA.W   R12
   \   00000C   0C5F         ADD.W   R15, R12
   \   00000E   3C50....     ADD.W   #nv_parms + 20, R12
   \   000012   ....         JMP     ?Subroutine1
    807              flash_secure();
    808          #endif
    809          }
    810          

   \                                 In  segment CODE, align 2
    811          int clear_calibration_data(void)
   \                     clear_calibration_data:
    812          {
    813              flash_clr((int16_t *) &nv_parms);
   \   000000   3C40....     MOV.W   #nv_parms, R12
   \   000004   B012....     CALL    #flash_clr
    814              /* If the nv_parms structure is bigger than a single info memory page, we may need to erase an extra page */
    815          #if defined(__MSP430_INFOD_MEM_SIZE__)
    816              if (sizeof(struct info_mem_s) > __MSP430_INFOD_MEM_SIZE__)
    817                  flash_clr((int16_t *) (((int8_t *) &nv_parms) + __MSP430_INFOD_MEM_SIZE__));
    818          #elif defined(__MSP430_INFOC_MEM_SIZE__)
    819              if (sizeof(struct info_mem_s) > __MSP430_INFOC_MEM_SIZE__)
    820                  flash_clr((int16_t *) (((int8_t *) &nv_parms) + __MSP430_INFOC_MEM_SIZE__));
    821          #elif defined(__MSP430_INFOB_MEM_SIZE__)
    822              if (sizeof(struct info_mem_s) > __MSP430_INFOB_MEM_SIZE__)
    823                  flash_clr((int16_t *) (((int8_t *) &nv_parms) + __MSP430_INFOB_MEM_SIZE__));
    824          #elif defined(__MSP430_INFOA_MEM_SIZE__)
    825              if (sizeof(struct info_mem_s) > __MSP430_INFOA_MEM_SIZE__)
    826                  flash_clr((int16_t *) (((int8_t *) &nv_parms) + __MSP430_INFOA_MEM_SIZE__));
    827          #endif
    828              return 0;
   \   000008   0C43         MOV.W   #0x0, R12
   \   00000A   3041         RET
    829          }

   Maximum stack usage in bytes:

   CSTACK Function
   ------ --------
      2   active_energy
      2   active_power
      2   apparent_power
      2   clear_calibration_data
        2   -> flash_clr
      2   current_dc_estimate
      2   current_thd
     10   dot_product
      2   fundamental_active_power
      2   fundamental_reactive_power
      2   fundamental_rms_current
      2   fundamental_rms_voltage
      2   get_I_rms_scaling
      2   get_P_scaling
      2   get_V_rms_scaling
      2   get_calibration_status
      2   get_compensate_capacitor_value
      2   get_compensate_resistance
      2   get_i_ac_offset
      2   get_initial_i_dc_estimate
      2   get_initial_v_dc_estimate
      2   get_phase_corr
      2   get_temperature_intercept
      2   get_temperature_slope
      2   get_v_ac_offset
      2   get_v_dc_estimate
      2   mains_frequency
      2   phase_status
      2   power_factor
      2   reactive_power
      2   rms_current
      2   rms_voltage
      2   set_I_rms_scaling
        2   -> flash_secure
        2   -> flash_write_int16
      2   set_P_scaling
        2   -> flash_secure
        2   -> flash_write_int16
      2   set_V_rms_scaling
        2   -> flash_secure
        2   -> flash_write_int16
      2   set_calibration_status
        2   -> flash_secure
        2   -> flash_write_int16
      2   set_compensate_capacitor_value
        2   -> flash_secure
        2   -> flash_write_int16
      2   set_compensate_resistance
        2   -> flash_secure
        2   -> flash_write_int16
      2   set_i_ac_offset
        2   -> flash_secure
        2   -> flash_write_int32
      2   set_i_dc_estimate
        2   -> flash_secure
        2   -> flash_write_int32
      2   set_phase_corr
        2   -> flash_secure
        2   -> flash_write_int16
      6   set_temperature_parameters
        6   -> flash_secure
        6   -> flash_write_int16
      2   set_v_ac_offset
        2   -> flash_secure
        2   -> flash_write_int32
      2   set_v_dc_estimate
        2   -> flash_secure
        2   -> flash_write_int16
      2   temperature
      2   voltage_dc_estimate
      2   voltage_thd


   Segment part sizes:

   Bytes  Function/Label
   -----  --------------
       6  ?Subroutine0
       8  ?Subroutine1
       8  ?Subroutine2
      70  active_energy
      46  active_power
      46  apparent_power
      12  clear_calibration_data
      38  current_dc_estimate
      32  current_thd
     160  dot_product
      46  fundamental_active_power
      46  fundamental_reactive_power
      38  fundamental_rms_current
      38  fundamental_rms_voltage
      20  get_I_rms_scaling
      20  get_P_scaling
      20  get_V_rms_scaling
       6  get_calibration_status
      20  get_compensate_capacitor_value
      20  get_compensate_resistance
      26  get_i_ac_offset
      26  get_initial_i_dc_estimate
      20  get_initial_v_dc_estimate
      26  get_phase_corr
       6  get_temperature_intercept
       6  get_temperature_slope
      26  get_v_ac_offset
      46  get_v_dc_estimate
      32  mains_frequency
      38  phase_status
      32  power_factor
      46  reactive_power
      38  rms_current
      38  rms_voltage
      18  set_I_rms_scaling
      20  set_P_scaling
      20  set_V_rms_scaling
       8  set_calibration_status
      20  set_compensate_capacitor_value
      20  set_compensate_resistance
      18  set_i_ac_offset
      20  set_i_dc_estimate
      26  set_phase_corr
      48  set_temperature_parameters
      20  set_v_ac_offset
      20  set_v_dc_estimate
       6  temperature
      38  voltage_dc_estimate
      32  voltage_thd

 
 1 440 bytes in segment CODE
 
 1 440 bytes of CODE memory

Errors: none
Warnings: none
