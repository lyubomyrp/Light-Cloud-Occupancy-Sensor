###############################################################################
#                                                                             #
# IAR C/C++ Compiler V5.52.1.50724/W32 for MSP430       07/Jul/2014  17:16:20 #
# Copyright 1996-2013 IAR Systems AB.                                         #
#                                                                             #
#    __rt_version  =  3                                                       #
#    __double_size =  32                                                      #
#    __reg_r4      =  free                                                    #
#    __reg_r5      =  free                                                    #
#    __pic         =  no                                                      #
#    __core        =  430                                                     #
#    Source file   =  C:\Users\a0283112\Desktop\Submeter i2040                #
#                     8k_DC_THD_AUTO_OSR_IAR5.5\emeter-metrology\src\metrolog #
#                     y-background.c                                          #
#    Command line  =  "C:\Users\a0283112\Desktop\Submeter i2040               #
#                     8k_DC_THD_AUTO_OSR_IAR5.5\emeter-metrology\src\metrolog #
#                     y-background.c" -D __MSP430__ -lCN                      #
#                     "C:\Users\a0283112\Desktop\Submeter i2040               #
#                     8k_DC_THD_AUTO_OSR_IAR5.5\emeter-metrology\emeter-metro #
#                     logy-i2041\Debug\List\" -lA                             #
#                     "C:\Users\a0283112\Desktop\Submeter i2040               #
#                     8k_DC_THD_AUTO_OSR_IAR5.5\emeter-metrology\emeter-metro #
#                     logy-i2041\Debug\List\" -o                              #
#                     "C:\Users\a0283112\Desktop\Submeter i2040               #
#                     8k_DC_THD_AUTO_OSR_IAR5.5\emeter-metrology\emeter-metro #
#                     logy-i2041\Debug\Obj\" --debug -D__MSP430I2041__ -e     #
#                     --double=32 --dlib_config "C:\Program Files (x86)\IAR   #
#                     Systems\Embedded Workbench                              #
#                     6.5_0\430\LIB\DLIB\dl430fn.h" --library_module -I       #
#                     "C:\Users\a0283112\Desktop\Submeter i2040               #
#                     8k_DC_THD_AUTO_OSR_IAR5.5\emeter-metrology\emeter-metro #
#                     logy-i2041/../../emeter-toolkit/include\" -I            #
#                     "C:\Users\a0283112\Desktop\Submeter i2040               #
#                     8k_DC_THD_AUTO_OSR_IAR5.5\emeter-metrology\emeter-metro #
#                     logy-i2041/../include\" -I                              #
#                     "C:\Users\a0283112\Desktop\Submeter i2040               #
#                     8k_DC_THD_AUTO_OSR_IAR5.5\emeter-metrology\emeter-metro #
#                     logy-i2041\" -Ohs --multiplier=16s                      #
#    List file     =  C:\Users\a0283112\Desktop\Submeter i2040                #
#                     8k_DC_THD_AUTO_OSR_IAR5.5\emeter-metrology\emeter-metro #
#                     logy-i2041\Debug\List\metrology-background.lst          #
#    Object file   =  C:\Users\a0283112\Desktop\Submeter i2040                #
#                     8k_DC_THD_AUTO_OSR_IAR5.5\emeter-metrology\emeter-metro #
#                     logy-i2041\Debug\Obj\metrology-background.r43           #
#                                                                             #
#                                                                             #
###############################################################################

C:\Users\a0283112\Desktop\Submeter i2040 8k_DC_THD_AUTO_OSR_IAR5.5\emeter-metrology\src\metrology-background.c
      1          /*******************************************************************************
      2           *  metrology-background.c -
      3           *
      4           *  Copyright (C) 2011 Texas Instruments Incorporated - http://www.ti.com/ 
      5           * 
      6           *  Redistribution and use in source and binary forms, with or without 
      7           *  modification, are permitted provided that the following conditions 
      8           *  are met:
      9           *
     10           *    Redistributions of source code must retain the above copyright 
     11           *    notice, this list of conditions and the following disclaimer.
     12           *
     13           *    Redistributions in binary form must reproduce the above copyright
     14           *    notice, this list of conditions and the following disclaimer in the 
     15           *    documentation and/or other materials provided with the   
     16           *    distribution.
     17           *
     18           *    Neither the name of Texas Instruments Incorporated nor the names of
     19           *    its contributors may be used to endorse or promote products derived
     20           *    from this software without specific prior written permission.
     21           *
     22           *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
     23           *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
     24           *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
     25           *  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT 
     26           *  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, 
     27           *  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
     28           *  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
     29           *  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
     30           *  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
     31           *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
     32           *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
     33           *
     34           ******************************************************************************/
     35          
     36          /*! \file emeter-metrology.h */
     37          
     38          #include <inttypes.h>
     39          #include <stdlib.h>
     40          #if !defined(__MSP430__)
     41          #include <stdio.h>
     42          #include <fcntl.h>
     43          #include <unistd.h>
     44          #endif
     45          #if defined(__GNUC__)
     46          #include <signal.h>
     47          #endif
     48          
     49          #include <emeter-toolkit.h>

   \                                 In  segment DATA16_AN, at 0x102
   \   unsigned short volatile SD24CCTL0
   \                     SD24CCTL0:
   \   000000                DS8 2

   \                                 In  segment DATA16_AN, at 0x104
   \   unsigned short volatile SD24CCTL1
   \                     SD24CCTL1:
   \   000000                DS8 2

   \                                 In  segment DATA16_AN, at 0x106
   \   unsigned short volatile SD24CCTL2
   \                     SD24CCTL2:
   \   000000                DS8 2

   \                                 In  segment DATA16_AN, at 0x110
   \   unsigned short volatile SD24MEM0
   \                     SD24MEM0:
   \   000000                DS8 2

   \                                 In  segment DATA16_AN, at 0x112
   \   unsigned short volatile SD24MEM1
   \                     SD24MEM1:
   \   000000                DS8 2

   \                                 In  segment DATA16_AN, at 0x114
   \   unsigned short volatile SD24MEM2
   \                     SD24MEM2:
   \   000000                DS8 2
     50          
     51          #include "emeter-metrology.h"
     52          #include "metrology-structs.h"
     53          #include "metrology-nv-structs.h"
     54          
     55          #if !defined(NULL)
     56          #define NULL    (void *) 0
     57          #endif
     58          extern const struct operating_parameter_s operating_parameter;
     59          
     60          //int16_t samples_per_second;
     61          
     62          #if defined(WIRE_RESISTANCE_COMPENSATE)

   \                                 In  segment DATA16_Z, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
     63          uint32_t resistance_scaling;
   \                     resistance_scaling:
   \   000000                DS8 4
     64          #endif
     65          
     66          #if defined(CAPACITOR_COMPENSATE_ON)

   \                                 In  segment DATA16_Z, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
     67          uint32_t capacitance_scaling;
   \                     capacitance_scaling:
   \   000000                DS8 4
     68          #endif
     69          
     70          #if defined(TEMPERATURE_SUPPORT)

   \                                 In  segment DATA16_Z, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
     71          int16_t raw_temperature_from_adc;
   \                     raw_temperature_from_adc:
   \   000000                DS8 2

   \                                 In  segment DATA16_Z, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
     72          int temperature_sequence = 0;
   \                     temperature_sequence:
   \   000000                DS8 2
     73              #if defined(TRNG_SUPPORT)
     74          uint16_t random_value;
     75          int new_random_value = FALSE;
     76          uint16_t rolling_random;
     77          int rand_bits = 0;
     78              #endif
     79          #endif
     80          
     81          #if defined(POWER_DOWN_SUPPORT)  &&  defined(POWER_UP_BY_SUPPLY_SENSING)
     82          int8_t power_down_debounce;
     83          #endif
     84          
     85          #if NUM_PHASES > 1  &&  defined(__MSP430_HAS_SD24_B3__)  &&  defined(__MSP430_HAS_ADC10_A__)
     86          /* This is a 3-phase meter, using the ADC10A for the voltage channels. These channels must be
     87             read through DMA. */
     88          int16_t dma_adc_buffer[6];
     89          //int16_t dma_adc_buffer[NUM_PHASES];
     90          #endif
     91          
     92          #if defined(TRNG_SUPPORT)
     93          int trng(uint16_t *val)
     94          {
     95              if (!new_random_value)
     96                  return -1;
     97              /* We now know the random value has been refreshed, so we can pick up a new one. */
     98              *val = random_value;
     99              /* There is a race here, where we may loose a generated number, but there will be more
    100                 along fairly soon, so its fairly harmless if we loose one. */
    101              new_random_value = FALSE;
    102              return 0;
    103          }
    104          
    105          uint16_t trng_wait(void)
    106          {
    107              uint16_t val;
    108          
    109              while (!new_random_value)
    110                  __no_operation();
    111              /* We now know the random value has been refreshed, so we can pick up a new one. */
    112              val = random_value;
    113              /* There is a race here, where we may loose a generated number, but there will be more
    114                 along fairly soon, so its fairly harmless if we loose one. */
    115              new_random_value = FALSE;
    116              return val;
    117          }
    118          #endif
    119          
    120          #if NUM_PHASES == 1

   \                                 In  segment CODE, align 2
    121          static void __inline__ log_parameters(void)
   \                     log_parameters:
    122          #else
    123          static void __inline__ log_parameters(struct phase_parms_s *phase, int ph)
    124          #endif
    125          {
    126          #if NUM_PHASES == 1  &&  defined(NEUTRAL_MONITOR_SUPPORT)
    127              int ch;
    128              static const uint16_t current_overrange_masks[PER_PHASE_CURRENT_CHANNELS] = {PHASE_STATUS_I_OVERRANGE, PHASE_STATUS_I_NEUTRAL_OVERRANGE};
    129          #else
    130              static const uint16_t current_overrange_masks[PER_PHASE_CURRENT_CHANNELS] = {PHASE_STATUS_I_OVERRANGE};
    131          #endif
    132          
    133              /* Take a snapshot of various values for logging purposes; tell the
    134                 foreground to deal with them; and clear the working values ready
    135                 for the next analysis period. */
    136              if (phase->metrology.V_endstops <= 0)
   \   000000   D293....     CMP.B   #0x1, &working_data + 358
   \   000004   0434         JGE     ??log_parameters_0
    137                  phase->status |= PHASE_STATUS_V_OVERRANGE;
   \   000006   B2D01000.... BIS.W   #0x10, &working_data + 360
   \   00000C   033C         JMP     ??log_parameters_1
    138              else
    139                  phase->status &= ~PHASE_STATUS_V_OVERRANGE;
   \                     ??log_parameters_0:
   \   00000E   B2C01000.... BIC.W   #0x10, &working_data + 360
    140              phase->metrology.V_endstops = ENDSTOP_HITS_FOR_OVERLOAD;
   \                     ??log_parameters_1:
   \   000014   F2401400.... MOV.B   #0x14, &working_data + 358
    141              /* Snapshot the DC estimate here, near a zero crossing */
    142          //    phase->metrology.V_dc_estimate_logged = ((dc_filter_voltage_estimate(phase->metrology.V_dc_estimate[normal_limp])));
    143              phase->metrology.V_dc_estimate_logged = (phase->metrology.V_dc_estimate_temp + dc_filter_voltage_estimate(phase->metrology.V_dc_estimate[normal_limp]))>> 1; 
   \   00001A   3C40....     MOV.W   #working_data + 78, R12
   \   00001E   B012....     CALL    #dc_filter16_estimate
   \   000022   1C52....     ADD.W   &working_data + 86, R12
   \   000026   1D62....     ADDC.W  &working_data + 88, R13
   \   00002A   0D11         RRA.W   R13
   \   00002C   0C10         RRC.W   R12
   \   00002E   824C....     MOV.W   R12, &working_data + 82
   \   000032   824D....     MOV.W   R13, &working_data + 84
    144          #if NUM_PHASES > 1  &&  defined(FUNDAMENTAL_VRMS_SUPPORT)
    145              /* Point ph at the previous phase, for differencing */
    146              if (--ph < 0)
    147                  ph = 2;
    148              phase->readings.phase_to_phase_angle = (phase->metrology.pure_phase >> 16) - (working_data.phases[ph].metrology.pure_phase >> 16);
    149          #endif
    150          
    151          #if NUM_PHASES == 1  &&  defined(NEUTRAL_MONITOR_SUPPORT)
    152              for (ch = 0;  ch < 2;  ch++)
    153          #endif
    154              {
    155                  if (phase->metrology.current[ch].I_endstops <= 0)
   \   000036   D293....     CMP.B   #0x1, &working_data + 346
   \   00003A   0434         JGE     ??log_parameters_2
    156                      phase->status |= current_overrange_masks[ch];
   \   00003C   B2D02000.... BIS.W   #0x20, &working_data + 360
   \   000042   033C         JMP     ??log_parameters_3
    157                  else
    158                      phase->status &= ~current_overrange_masks[ch];
   \                     ??log_parameters_2:
   \   000044   B2C02000.... BIC.W   #0x20, &working_data + 360
    159                  phase->metrology.current[ch].I_endstops = ENDSTOP_HITS_FOR_OVERLOAD;
   \                     ??log_parameters_3:
   \   00004A   F2401400.... MOV.B   #0x14, &working_data + 346
    160                  /* Snapshot the DC estimate here, near a zero crossing */
    161          //        phase->metrology.current[ch].I_dc_estimate_logged = dc_filter_current_estimate(phase->metrology.current[ch].I_dc_estimate[normal_limp]);
    162                  phase->metrology.current[ch].I_dc_estimate_logged = (phase->metrology.current[ch].I_dc_estimate_temp  + dc_filter_current_estimate (phase->metrology.current[ch].I_dc_estimate[normal_limp])) >> 1;
   \   000050   3C40....     MOV.W   #working_data + 230, R12
   \   000054   B012....     CALL    #dc_filter24_estimate
   \   000058   1C52....     ADD.W   &working_data + 240, R12
   \   00005C   1D62....     ADDC.W  &working_data + 242, R13
   \   000060   0D11         RRA.W   R13
   \   000062   0C10         RRC.W   R12
   \   000064   824C....     MOV.W   R12, &working_data + 236
   \   000068   824D....     MOV.W   R13, &working_data + 238
    163              }
    164          
    165              /* Tell the foreground there are things to process, and swap the dot product sets. */
    166              phase->metrology.dp_set ^= 1;
   \   00006C   D2E3....     XOR.B   #0x1, &working_data + 359
    167              phase->status |= PHASE_STATUS_NEW_LOG;
   \   000070   92D3....     BIS.W   #0x1, &working_data + 360
    168          }
   \   000074   3041         RET
    169          
    170          #if NUM_PHASES > 1  &&  defined(NEUTRAL_MONITOR_SUPPORT)  &&  defined(IRMS_SUPPORT)
    171          /* This routine logs neutral lead information for poly-phase meters. It is
    172             not used for single phase meters with neutral monitoring. */
    173          static void __inline__ log_neutral_parameters(void)
    174          {
    175              if (working_data.neutral.metrology.I_endstops <= 0)
    176                  working_data.neutral.status |= PHASE_STATUS_I_OVERRANGE;
    177              else
    178                  working_data.neutral.status &= ~PHASE_STATUS_I_OVERRANGE;
    179              working_data.neutral.metrology.I_endstops = ENDSTOP_HITS_FOR_OVERLOAD;
    180              working_data.neutral.metrology.I_dc_estimate_logged = dc_filter_current_estimate(working_data.neutral.metrology.I_dc_estimate[normal_limp]);
    181              /* Tell the foreground there are things to process, and swap the dot product sets. */
    182              working_data.neutral.metrology.dp_set ^= 1;
    183              working_data.neutral.status |= PHASE_STATUS_NEW_LOG;
    184          }
    185          #endif
    186          
    187          #if defined(__HAS_SD_ADC__)
    188              #if defined(VOLTAGE_SIGNAL_IS_COMMON)
    189          #define VOLTAGE_CHANNELS 1
    190              #else
    191          #define VOLTAGE_CHANNELS NUM_PHASES
    192              #endif
    193              #if defined(NEUTRAL_MONITOR_SUPPORT)
    194          #define CURRENT_CHANNELS (NUM_PHASES + 1)
    195              #else
    196          #define CURRENT_CHANNELS NUM_PHASES
    197              #endif
    198          #endif
    199          
    200          /* These are the buffers for one set of samples */

   \                                 In  segment DATA16_Z, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
    201          static voltage_sample_t adc_v_buffer[VOLTAGE_CHANNELS];
   \                     adc_v_buffer:
   \   000000                DS8 2

   \                                 In  segment DATA16_Z, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
    202          static current_sample_t adc_i_buffer[CURRENT_CHANNELS];
   \                     adc_i_buffer:
   \   000000                DS8 4
    203          

   \                                 In  segment CODE, align 2
    204          int8_t adjust_v_history_index (int8_t index)
   \                     adjust_v_history_index:
    205          {
   \   000000   0A12         PUSH.W  R10
   \   000002   4A4C         MOV.B   R12, R10
    206              if (index >= 0)
   \   000004   4C93         CMP.B   #0x0, R12
   \   000006   1338         JL      ??adjust_v_history_index_0
   \   000008   7C903000     CMP.B   #0x30, R12
   \   00000C   1428         JNC     ??adjust_v_history_index_1
   \   00000E   7E403000     MOV.B   #0x30, R14
   \   000012   B012....     CALL    #?DivMod8u
   \   000016   4C5C         RLA.B   R12
   \   000018   4C5C         RLA.B   R12
   \   00001A   4C5C         RLA.B   R12
   \   00001C   4C5C         RLA.B   R12
   \   00001E   4E4C         MOV.B   R12, R14
   \   000020   4C5C         RLA.B   R12
   \   000022   4C5C         RLA.B   R12
   \   000024   4E5C         ADD.B   R12, R14
   \   000026   4C5C         RLA.B   R12
   \   000028   4C5E         ADD.B   R14, R12
   \   00002A   4A5C         ADD.B   R12, R10
   \   00002C   043C         JMP     ??adjust_v_history_index_1
    207              {
    208                  while (index >= (sizeof(phase->metrology.V_history)/sizeof(phase->metrology.V_history[0])))
    209                  {
    210                      index -= (sizeof(phase->metrology.V_history)/sizeof(phase->metrology.V_history[0]));
    211                  }
    212              }
    213              else
    214              {
    215                  while (index < 0)
    216                  {
    217                      index += (sizeof(phase->metrology.V_history)/sizeof(phase->metrology.V_history[0]));
   \                     ??adjust_v_history_index_0:
   \   00002E   7A503000     ADD.B   #0x30, R10
    218                  }
   \   000032   4A93         CMP.B   #0x0, R10
   \   000034   FC3B         JL      ??adjust_v_history_index_0
    219              }
    220              return index;
   \                     ??adjust_v_history_index_1:
   \   000036   4C4A         MOV.B   R10, R12
   \   000038   3A41         POP.W   R10
   \   00003A   3041         RET
    221          }
    222          

   \                                 In  segment CODE, align 2
    223          static __inline__ int per_sample_dsp(void)
   \                     per_sample_dsp:
    224          {
   \   000000   0A12         PUSH.W  R10
   \   000002   0B12         PUSH.W  R11
   \   000004   0812         PUSH.W  R8
   \   000006   0912         PUSH.W  R9
   \   000008   0612         PUSH.W  R6
   \   00000A   0712         PUSH.W  R7
   \   00000C   0412         PUSH.W  R4
   \   00000E   0512         PUSH.W  R5
   \   000010   31800C00     SUB.W   #0xc, SP
    225              int kick;
    226              voltage_sample_t V_sample;
    227              voltage_sample_t V_corrected;
    228          #if defined(REACTIVE_POWER_BY_QUADRATURE_SUPPORT)
    229              voltage_sample_t V_quad_corrected;
    230          #endif
    231          #if defined(FUNDAMENTAL_POWER_SUPPORT)
    232              voltage_sample_t V_pure;
    233              voltage_sample_t V_quad_pure;
    234              int32_t summy;
    235          #endif
    236              current_sample_t I_sample[PER_PHASE_CURRENT_CHANNELS];
    237              current_sample_t I_corrected;
    238          
    239          #if defined (WIRE_RESISTANCE_COMPENSATE)
    240              // ----- resistance compensation
    241              static int16_t Last_I_sample;
    242              // -----
    243          #endif
    244              
    245          #if defined(RESIDUAL_IRMS_SUPPORT)
    246              int32_t I_residue;
    247          #endif
    248              
    249          #if NUM_PHASES > 1
    250              struct phase_parms_s *phase;
    251              int ph;
    252          #endif
    253          #if NUM_PHASES == 1  &&  defined(NEUTRAL_MONITOR_SUPPORT)
    254              static const uint16_t current_pos_masks[PER_PHASE_CURRENT_CHANNELS] = {PHASE_STATUS_I_POS, PHASE_STATUS_I_NEUTRAL_POS};
    255              int ch;
    256          #else
    257          //    static const uint16_t current_pos_masks[PER_PHASE_CURRENT_CHANNELS] = {PHASE_STATUS_I_POS};
    258          #endif
    259              int k;
    260          #if defined(MAINS_FREQUENCY_SUPPORT)
    261              int x;
    262              int y;
    263              int z;
    264          #endif
    265              struct phase_dot_prod_set_s *phase_dot_products;
    266              struct current_sensor_dot_prod_set_s *sensor_dot_products;
    267          #if NUM_PHASES > 1  &&  defined(NEUTRAL_MONITOR_SUPPORT)
    268              struct neutral_dot_prod_set_s *neutral_dot_products;
    269          #endif
    270              int dp;
    271              /* Filter away the DC bias.
    272              
    273                 Do the phase lag compensation. Use a simple FIR approach,
    274                 and absorb the non-unity gain of the filter in the overall
    275                 current/power scaling later on. This is OK for the small
    276                 phase shifts we expect to get. It would cause dynamic
    277                 range problems for larger shifts. Note the some of this
    278                 phase shift is due to the operation of the ADC itself. It
    279                 performs sequential conversions of its 8 inputs, so there is
    280                 some time delay between sampling of the various sensors.
    281              
    282                 Accumulate power for each of the channels. These will
    283                 be divided by the number of samples at the end of the
    284                 measurement cycles, resulting in an average power
    285                 value for each source.
    286          
    287                 If RMS voltage and/or current readings are required, calculate the
    288                 dot products needed to evaluate these. */
    289          
    290              kick = FALSE;
   \   000014   0743         MOV.W   #0x0, R7
    291          #if defined(RESIDUAL_IRMS_SUPPORT)
    292              I_residue = 0;
    293          #endif
    294          
    295          #if NUM_PHASES > 1
    296              for (ph = 0, phase = working_data.phases;  ph < NUM_PHASES;  ph++, phase++)
    297          #endif
    298              {
    299                  dp = phase->metrology.dp_set ^ 1;
   \   000016   5842....     MOV.B   &working_data + 359, R8
   \   00001A   8811         SXT     R8
   \   00001C   18E3         XOR.W   #0x1, R8
    300                  phase_dot_products = &phase->metrology.dot_prod[dp];
   \   00001E   0648         MOV.W   R8, R6
   \   000020   0656         RLA.W   R6
   \   000022   0F46         MOV.W   R6, R15
   \   000024   0656         RLA.W   R6
   \   000026   0F56         ADD.W   R6, R15
   \   000028   0656         RLA.W   R6
   \   00002A   065F         ADD.W   R15, R6
   \   00002C   3650....     ADD.W   #working_data + 202, R6
    301          
    302          #if defined(VOLTAGE_SIGNAL_IS_COMMON)
    303                  V_sample = adc_v_buffer[0];
    304          #else
    305                  V_sample = adc_v_buffer[ph];
   \   000030   1A42....     MOV.W   &adc_v_buffer, R10
    306          #endif
    307                  if ((V_sample >= V_ADC_MAX  ||  V_sample <= V_ADC_MIN)  &&  phase->metrology.V_endstops)
   \   000034   0F4A         MOV.W   R10, R15
   \   000036   3F501779     ADD.W   #0x7917, R15
   \   00003A   3F902FF2     CMP.W   #0xf22f, R15
   \   00003E   0528         JNC     ??per_sample_dsp_9
   \   000040   C293....     CMP.B   #0x0, &working_data + 358
   \   000044   0224         JEQ     ??per_sample_dsp_9
    308                      phase->metrology.V_endstops--;
   \   000046   F253....     ADD.B   #0xff, &working_data + 358
    309          
    310                  if (phase->status & PHASE_STATUS_DC_MODE)
   \                     ??per_sample_dsp_9:
   \   00004A   8293....     CMP.W   #0x0, &working_data + 360
   \   00004E   0D4A         MOV.W   R10, R13
   \   000050   3C40....     MOV.W   #working_data + 78, R12
   \   000054   0334         JGE     ??per_sample_dsp_10
    311                  {
    312                      V_sample = dc_filter_voltage_no_update(phase->metrology.V_dc_estimate[normal_limp], V_sample);      // d.c. mode
   \   000056   B012....     CALL    #dc_filter16_no_update
   \   00005A   023C         JMP     ??per_sample_dsp_11
    313                  }
    314                  else
    315                  {
    316                      V_sample = dc_filter_voltage(phase->metrology.V_dc_estimate[normal_limp], V_sample);    // a.c. mode
   \                     ??per_sample_dsp_10:
   \   00005C   B012....     CALL    #dc_filter16
   \                     ??per_sample_dsp_11:
   \   000060   0A4C         MOV.W   R12, R10
    317                  }
    318                  
    319                  
    320          #if defined (WIRE_RESISTANCE_COMPENSATE)
    321                  // ----- resistance compensation
    322                  V_sample += ((Last_I_sample * resistance_scaling) >> 16);
   \   000062   1442....     MOV.W   &??Last_I_sample, R4
   \   000066   0544         MOV.W   R4, R5
   \   000068   35E3         XOR.W   #0xffff, R5
   \   00006A   0555         RLA.W   R5
   \   00006C   0575         SUBC.W  R5, R5
   \   00006E   1E42....     MOV.W   &resistance_scaling, R14
   \   000072   1F42....     MOV.W   &resistance_scaling + 2, R15
   \   000076   0212         PUSH.W  SR
   \   000078   32C2         DINT
   \   00007A   0343         NOP
   \   00007C   82443001     MOV.W   R4, &0x130
   \   000080   824E3801     MOV.W   R14, &0x138
   \   000084   82443401     MOV.W   R4, &0x134
   \   000088   14423A01     MOV.W   &0x13a, R4
   \   00008C   92423C013A01 MOV.W   &0x13c, &0x13a
   \   000092   824F3801     MOV.W   R15, &0x138
   \   000096   82453401     MOV.W   R5, &0x134
   \   00009A   824E3801     MOV.W   R14, &0x138
   \   00009E   15423A01     MOV.W   &0x13a, R5
   \   0000A2   3241         POP.W   SR
   \   0000A4   0A55         ADD.W   R5, R10
    323                  // ----- end of block
    324          #endif
    325          
    326          #if defined(VRMS_SUPPORT)  ||  defined(POWER_FACTOR_SUPPORT)
    327              #if defined(SAG_SWELL_SUPPORT)
    328                  sqac_voltage(phase->metrology.V_sq_cycle, V_sample);
    329              #else
    330                  sqac_voltage(phase_dot_products->V_sq, V_sample);
   \   0000A6   0D4A         MOV.W   R10, R13
   \   0000A8   0C46         MOV.W   R6, R12
   \   0000AA   B012....     CALL    #sqac48_16
    331              #endif
    332          #endif
    333                  ++phase_dot_products->sample_count;
   \   0000AE   96530C00     ADD.W   #0x1, 0xc(R6)
    334          
    335                  /* We need to save the history of the voltage signal if we are performing phase correction, and/or
    336                     measuring the quadrature shifted power (to obtain an accurate measure of one form of the reactive power). */
    337                  phase->metrology.V_history[(int) phase->metrology.V_history_index] = V_sample;
   \   0000B2   3940....     MOV.W   #working_data + 186, R9
   \   0000B6   6F49         MOV.B   @R9, R15
   \   0000B8   8F11         SXT     R15
   \   0000BA   0F5F         RLA.W   R15
   \   0000BC   8F4A....     MOV.W   R10, working_data + 90(R15)
    338          
    339                  if (operating_mode == OPERATING_MODE_NORMAL)
   \   0000C0   C293....     CMP.B   #0x0, &operating_mode
   \   0000C4   5D20         JNE     ??per_sample_dsp_12
   \   0000C6   6C49         MOV.B   @R9, R12
   \   0000C8   5C82....     SUB.B   &working_data + 328, R12
   \   0000CC   4B4C         MOV.B   R12, R11
    340                  {
    341                      /* Perform bulk delay (i.e. integer sample times) of the voltage signal. */
    342                       V_corrected = phase->metrology.V_history[adjust_v_history_index (phase->metrology.V_history_index - phase->metrology.current[0].in_phase_correction.step)];
   \   0000CE   4C93         CMP.B   #0x0, R12
   \   0000D0   1338         JL      ??per_sample_dsp_0
   \   0000D2   7C903000     CMP.B   #0x30, R12
   \   0000D6   1428         JNC     ??per_sample_dsp_13
   \   0000D8   7E403000     MOV.B   #0x30, R14
   \   0000DC   B012....     CALL    #?DivMod8u
   \   0000E0   4C5C         RLA.B   R12
   \   0000E2   4C5C         RLA.B   R12
   \   0000E4   4C5C         RLA.B   R12
   \   0000E6   4C5C         RLA.B   R12
   \   0000E8   4E4C         MOV.B   R12, R14
   \   0000EA   4C5C         RLA.B   R12
   \   0000EC   4C5C         RLA.B   R12
   \   0000EE   4E5C         ADD.B   R12, R14
   \   0000F0   4C5C         RLA.B   R12
   \   0000F2   4C5E         ADD.B   R14, R12
   \   0000F4   4B5C         ADD.B   R12, R11
   \   0000F6   043C         JMP     ??per_sample_dsp_13
   \                     ??per_sample_dsp_0:
   \   0000F8   7B503000     ADD.B   #0x30, R11
   \   0000FC   4B93         CMP.B   #0x0, R11
   \   0000FE   FC3B         JL      ??per_sample_dsp_0
   \                     ??per_sample_dsp_13:
   \   000100   8B11         SXT     R11
   \   000102   0B5B         RLA.W   R11
   \   000104   1B4B....     MOV.W   working_data + 90(R11), R11
    343          #if defined(FUNDAMENTAL_POWER_SUPPORT)
    344                      /* The dot product of the raw and the pure voltage signals allows us to precisely estimate
    345                         the amplitude of the fundamental component of the mains voltage waveform. This is needed,
    346                         during the foreground processing, to correctly scale the answer from the dot product of the
    347                         full scale pure voltage waveform and the current signal.
    348                         The answer from this estimator will only be correct once the pure waveform is properly phase
    349                         locked. */
    350                      V_pure = dds_lookup(phase->metrology.pure_phase);
   \   000108   1C42....     MOV.W   &working_data + 188, R12
   \   00010C   1D42....     MOV.W   &working_data + 190, R13
   \   000110   B012....     CALL    #dds_lookup
   \   000114   814C0600     MOV.W   R12, 0x6(SP)
    351                      mac_voltage(phase_dot_products->V_fundamental, V_corrected, V_pure);
   \   000118   0E4C         MOV.W   R12, R14
   \   00011A   0D4B         MOV.W   R11, R13
   \   00011C   0C46         MOV.W   R6, R12
   \   00011E   3C500600     ADD.W   #0x6, R12
   \   000122   B012....     CALL    #mac48_16
    352          
    353                      /* If we look for maximum correlation when the real and synthetic waveforms are in sync:
    354                              - the sensitivity to errors is not that big around the match
    355                              - we don't know what the peak should be
    356                              - we don't know which side of the peak we are.
    357                         If we look for minimum correlation in quadrature signals we solve all three issues in one go. */
    358                      /* Cross correlate the real voltage signal with the synthesised quadrature one, and tune the phase to
    359                         minimise the correlation. This assumes the phase rate is being accurately derived from the mains
    360                         frequency measurement, and we only need to adjust the phase here. This is a sort of PLL, with the
    361                         frequency and phase aspects of the lock being seperately evaluated. */
    362                      V_quad_pure = dds_lookup(phase->metrology.pure_phase + 0x40000000);
   \   000126   1C42....     MOV.W   &working_data + 188, R12
   \   00012A   1D42....     MOV.W   &working_data + 190, R13
   \   00012E   3D500040     ADD.W   #0x4000, R13
   \   000132   B012....     CALL    #dds_lookup
   \   000136   814C0400     MOV.W   R12, 0x4(SP)
    363                      summy = imul16(V_corrected, V_quad_pure);
   \   00013A   0D4C         MOV.W   R12, R13
   \   00013C   0C4B         MOV.W   R11, R12
   \   00013E   B012....     CALL    #imul16
    364                      /* We need to filter hard at this point, to massively suppress the harmonics. We do this with a single
    365                         pole with a very low turnover point. Obviously, this only tails off at 6dB/octave, so the downside
    366                         it a very slow pull-in during the initial phase locking. */
    367                      phase->metrology.cross_sum += ((summy - phase->metrology.cross_sum) >> 13);
   \   000142   1C82....     SUB.W   &working_data + 196, R12
   \   000146   1D72....     SUBC.W  &working_data + 198, R13
   \   00014A   8C10         SWPB    R12
   \   00014C   8D10         SWPB    R13
   \   00014E   4CED         XOR.B   R13, R12
   \   000150   0CED         XOR.W   R13, R12
   \   000152   8D11         SXT     R13
   \   000154   B012....     CALL    #?ShiftRight32s_5
   \   000158   825C....     ADD.W   R12, &working_data + 196
   \   00015C   826D....     ADDC.W  R13, &working_data + 198
    368                      phase->metrology.pure_phase += (phase->metrology.cross_sum >> 5);
   \   000160   1C42....     MOV.W   &working_data + 196, R12
   \   000164   1D42....     MOV.W   &working_data + 198, R13
   \   000168   B012....     CALL    #?ShiftRight32s_5
   \   00016C   825C....     ADD.W   R12, &working_data + 188
   \   000170   826D....     ADDC.W  R13, &working_data + 190
    369                      phase->metrology.pure_phase += phase->metrology.pure_phase_rate;
   \   000174   9252........ ADD.W   &working_data + 192, &working_data + 188
   \   00017A   9262........ ADDC.W  &working_data + 194, &working_data + 190
    370          #endif
    371                  }
    372          
    373          #if NUM_PHASES == 1  &&  defined(NEUTRAL_MONITOR_SUPPORT)
    374                  for (ch = 0;  ch < 2;  ch++)
    375                  {
    376                      I_corrected = adc_i_buffer[ch];
    377          #else
    378                  {
    379                      I_corrected = adc_i_buffer[ph];
   \                     ??per_sample_dsp_12:
   \   000180   9142....0800 MOV.W   &adc_i_buffer, 0x8(SP)
   \   000186   9142....0A00 MOV.W   &adc_i_buffer + 2, 0xa(SP)
    380          #endif
    381                      sensor_dot_products = &phase->metrology.current[ch].dot_prod[dp];
   \   00018C   0858         RLA.W   R8
   \   00018E   0F48         MOV.W   R8, R15
   \   000190   0858         RLA.W   R8
   \   000192   0858         RLA.W   R8
   \   000194   0F58         ADD.W   R8, R15
   \   000196   0858         RLA.W   R8
   \   000198   0858         RLA.W   R8
   \   00019A   085F         ADD.W   R15, R8
   \   00019C   3850....     ADD.W   #working_data + 244, R8
    382                      if ((I_corrected >= I_ADC_MAX  ||  I_corrected <= I_ADC_MIN)  &&  phase->metrology.current[0].I_endstops)
   \   0001A0   1E410800     MOV.W   0x8(SP), R14
   \   0001A4   1F410A00     MOV.W   0xa(SP), R15
   \   0001A8   3E50FF17     ADD.W   #0x17ff, R14
   \   0001AC   3F607900     ADDC.W  #0x79, R15
   \   0001B0   3F90F200     CMP.W   #0xf2, R15
   \   0001B4   0928         JNC     ??per_sample_dsp_14
   \   0001B6   0320         JNE     ??per_sample_dsp_15
   \   0001B8   3E90FF2F     CMP.W   #0x2fff, R14
   \   0001BC   0528         JNC     ??per_sample_dsp_14
   \                     ??per_sample_dsp_15:
   \   0001BE   C293....     CMP.B   #0x0, &working_data + 346
   \   0001C2   0224         JEQ     ??per_sample_dsp_14
    383                          phase->metrology.current[ch].I_endstops--;
   \   0001C4   F253....     ADD.B   #0xff, &working_data + 346
    384                      
    385                      if (phase->status & PHASE_STATUS_DC_MODE)
   \                     ??per_sample_dsp_14:
   \   0001C8   8293....     CMP.W   #0x0, &working_data + 360
   \   0001CC   1E42....     MOV.W   &working_data + 338, R14
   \   0001D0   1F42....     MOV.W   &working_data + 340, R15
   \   0001D4   3C40....     MOV.W   #working_data + 230, R12
   \   0001D8   0734         JGE     ??per_sample_dsp_16
    386                      {
    387                          I_sample[ch] = dc_filter_current_no_update(phase->metrology.current[ch].I_dc_estimate[normal_limp], phase->metrology.current[ch].I_history[0]);   // D.C. mode
   \   0001DA   B012....     CALL    #dc_filter24_no_update
   \   0001DE   814C0000     MOV.W   R12, 0(SP)
   \   0001E2   814D0200     MOV.W   R13, 0x2(SP)
   \   0001E6   4F3C         JMP     ??per_sample_dsp_17
    388                      }
    389                      else
    390                      {
    391                          I_sample[ch] = dc_filter_current(phase->metrology.current[ch].I_dc_estimate[normal_limp], phase->metrology.current[ch].I_history[0]); // a.c. mode
   \                     ??per_sample_dsp_16:
   \   0001E8   B012....     CALL    #dc_filter24
   \   0001EC   044C         MOV.W   R12, R4
   \   0001EE   054D         MOV.W   R13, R5
    392          
    393          #if defined (CAPACITOR_COMPENSATE_ON)
    394                      I_sample[ch] += ((V_sample - phase->metrology.V_history[adjust_v_history_index (phase->metrology.V_history_index - 1)]) * capacitance_scaling);
   \   0001F0   6C49         MOV.B   @R9, R12
   \   0001F2   7C53         ADD.B   #0xff, R12
   \   0001F4   4E4C         MOV.B   R12, R14
   \   0001F6   4C93         CMP.B   #0x0, R12
   \   0001F8   1538         JL      ??per_sample_dsp_1
   \   0001FA   7C903000     CMP.B   #0x30, R12
   \   0001FE   1628         JNC     ??per_sample_dsp_18
   \   000200   4C12         PUSH.B  R12
   \   000202   7E403000     MOV.B   #0x30, R14
   \   000206   B012....     CALL    #?DivMod8u
   \   00020A   4C5C         RLA.B   R12
   \   00020C   4C5C         RLA.B   R12
   \   00020E   4C5C         RLA.B   R12
   \   000210   4C5C         RLA.B   R12
   \   000212   4E4C         MOV.B   R12, R14
   \   000214   4C5C         RLA.B   R12
   \   000216   4C5C         RLA.B   R12
   \   000218   4E5C         ADD.B   R12, R14
   \   00021A   4C5C         RLA.B   R12
   \   00021C   4C5E         ADD.B   R14, R12
   \   00021E   7E41         POP.B   R14
   \   000220   4E5C         ADD.B   R12, R14
   \   000222   043C         JMP     ??per_sample_dsp_18
   \                     ??per_sample_dsp_1:
   \   000224   7E503000     ADD.B   #0x30, R14
   \   000228   4E93         CMP.B   #0x0, R14
   \   00022A   FC3B         JL      ??per_sample_dsp_1
    395          #endif            
    396                      
    397                      }
   \                     ??per_sample_dsp_18:
   \   00022C   0C44         MOV.W   R4, R12
   \   00022E   0D45         MOV.W   R5, R13
   \   000230   8E11         SXT     R14
   \   000232   0E5E         RLA.W   R14
   \   000234   1A8E....     SUB.W   working_data + 90(R14), R10
   \   000238   054A         MOV.W   R10, R5
   \   00023A   35E3         XOR.W   #0xffff, R5
   \   00023C   0555         RLA.W   R5
   \   00023E   0575         SUBC.W  R5, R5
   \   000240   1E42....     MOV.W   &capacitance_scaling, R14
   \   000244   1F42....     MOV.W   &capacitance_scaling + 2, R15
   \   000248   0212         PUSH.W  SR
   \   00024A   32C2         DINT
   \   00024C   0343         NOP
   \   00024E   824A3001     MOV.W   R10, &0x130
   \   000252   824E3801     MOV.W   R14, &0x138
   \   000256   824A3401     MOV.W   R10, &0x134
   \   00025A   14423A01     MOV.W   &0x13a, R4
   \   00025E   92423C013A01 MOV.W   &0x13c, &0x13a
   \   000264   824F3801     MOV.W   R15, &0x138
   \   000268   82453401     MOV.W   R5, &0x134
   \   00026C   824E3801     MOV.W   R14, &0x138
   \   000270   15423A01     MOV.W   &0x13a, R5
   \   000274   3241         POP.W   SR
   \   000276   0E4C         MOV.W   R12, R14
   \   000278   0F4D         MOV.W   R13, R15
   \   00027A   0E54         ADD.W   R4, R14
   \   00027C   0F65         ADDC.W  R5, R15
   \   00027E   814E0000     MOV.W   R14, 0(SP)
   \   000282   814F0200     MOV.W   R15, 0x2(SP)
    398          
    399          #if defined (WIRE_RESISTANCE_COMPENSATE)            
    400                      // ----- resistance compensation
    401                      Last_I_sample = (I_sample[ch] >> 8);
   \                     ??per_sample_dsp_17:
   \   000286   2E41         MOV.W   @SP, R14
   \   000288   1F410200     MOV.W   0x2(SP), R15
   \   00028C   8E10         SWPB    R14
   \   00028E   8F10         SWPB    R15
   \   000290   4EEF         XOR.B   R15, R14
   \   000292   0EEF         XOR.W   R15, R14
   \   000294   824E....     MOV.W   R14, &??Last_I_sample
    402                      // -----
    403          #endif
    404                      
    405          #if I_HISTORY_STEPS > 2
    406                      for (k = 0;  k < I_HISTORY_STEPS - 1;  k++)
    407                          phase->metrology.current[ch].I_history[k] = phase->metrology.current[ch].I_history[k + 1];
    408          #else
    409                      phase->metrology.current[ch].I_history[0] = phase->metrology.current[ch].I_history[1];
   \   000298   9242........ MOV.W   &working_data + 342, &working_data + 338
   \   00029E   9242........ MOV.W   &working_data + 344, &working_data + 340
    410          #endif
    411                      phase->metrology.current[ch].I_history[I_HISTORY_STEPS - 1] = I_corrected;
   \   0002A4   92410800.... MOV.W   0x8(SP), &working_data + 342
   \   0002AA   92410A00.... MOV.W   0xa(SP), &working_data + 344
    412          #if defined(RESIDUAL_IRMS_SUPPORT)
    413                      I_residue += I_sample[ch];
    414          #endif
    415          #if defined(IRMS_SUPPORT)  ||  defined(POWER_FACTOR_SUPPORT)
    416                      sqac_current(sensor_dot_products->I_sq, I_sample[ch]);
   \   0002B0   2E41         MOV.W   @SP, R14
   \   0002B2   1F410200     MOV.W   0x2(SP), R15
   \   0002B6   0C48         MOV.W   R8, R12
   \   0002B8   3C502000     ADD.W   #0x20, R12
   \   0002BC   B012....     CALL    #sqac64_24
    417          #endif
    418                      if (operating_mode == OPERATING_MODE_NORMAL)
   \   0002C0   C293....     CMP.B   #0x0, &operating_mode
   \   0002C4   8E20         JNE     ??per_sample_dsp_19
   \   0002C6   6C49         MOV.B   @R9, R12
   \   0002C8   5C82....     SUB.B   &working_data + 328, R12
   \   0002CC   4A4C         MOV.B   R12, R10
    419                      {
    420                          /* Perform bulk delay (i.e. integer sample times) of the voltage signal. */
    421                          V_corrected = phase->metrology.V_history[adjust_v_history_index (phase->metrology.V_history_index - phase->metrology.current[ch].in_phase_correction.step)];
   \   0002CE   4C93         CMP.B   #0x0, R12
   \   0002D0   1338         JL      ??per_sample_dsp_2
   \   0002D2   7C903000     CMP.B   #0x30, R12
   \   0002D6   1428         JNC     ??per_sample_dsp_20
   \   0002D8   7E403000     MOV.B   #0x30, R14
   \   0002DC   B012....     CALL    #?DivMod8u
   \   0002E0   4C5C         RLA.B   R12
   \   0002E2   4C5C         RLA.B   R12
   \   0002E4   4C5C         RLA.B   R12
   \   0002E6   4C5C         RLA.B   R12
   \   0002E8   4E4C         MOV.B   R12, R14
   \   0002EA   4C5C         RLA.B   R12
   \   0002EC   4C5C         RLA.B   R12
   \   0002EE   4E5C         ADD.B   R12, R14
   \   0002F0   4C5C         RLA.B   R12
   \   0002F2   4C5E         ADD.B   R14, R12
   \   0002F4   4A5C         ADD.B   R12, R10
   \   0002F6   043C         JMP     ??per_sample_dsp_20
   \                     ??per_sample_dsp_2:
   \   0002F8   7A503000     ADD.B   #0x30, R10
   \   0002FC   4A93         CMP.B   #0x0, R10
   \   0002FE   FC3B         JL      ??per_sample_dsp_2
   \                     ??per_sample_dsp_20:
   \   000300   8A11         SXT     R10
   \   000302   0A5A         RLA.W   R10
   \   000304   1B4A....     MOV.W   working_data + 90(R10), R11
    422                          mac_power(sensor_dot_products->P_active, V_corrected, I_sample[ch]);
   \   000308   3A40....     MOV.W   #mac64_16_24, R10
   \   00030C   2E41         MOV.W   @SP, R14
   \   00030E   1F410200     MOV.W   0x2(SP), R15
   \   000312   0D4B         MOV.W   R11, R13
   \   000314   0C48         MOV.W   R8, R12
   \   000316   8A12         CALL    R10
   \   000318   6C49         MOV.B   @R9, R12
   \   00031A   5C82....     SUB.B   &working_data + 332, R12
   \   00031E   7C53         ADD.B   #0xff, R12
   \   000320   444C         MOV.B   R12, R4
    423          #if defined(REACTIVE_POWER_BY_QUADRATURE_SUPPORT)
    424                          V_quad_corrected = (q1_15_mul(phase->metrology.V_history[adjust_v_history_index (phase->metrology.V_history_index - phase->metrology.current[ch].quadrature_correction.step - 1)], phase->metrology.current[ch].quadrature_correction.fir_beta) >> 1)
    425                                            + (phase->metrology.V_history[adjust_v_history_index (phase->metrology.V_history_index - phase->metrology.current[ch].quadrature_correction.step)] >> 1);
   \   000322   4C93         CMP.B   #0x0, R12
   \   000324   1338         JL      ??per_sample_dsp_3
   \   000326   7C903000     CMP.B   #0x30, R12
   \   00032A   1428         JNC     ??per_sample_dsp_21
   \   00032C   7E403000     MOV.B   #0x30, R14
   \   000330   B012....     CALL    #?DivMod8u
   \   000334   4C5C         RLA.B   R12
   \   000336   4C5C         RLA.B   R12
   \   000338   4C5C         RLA.B   R12
   \   00033A   4C5C         RLA.B   R12
   \   00033C   4E4C         MOV.B   R12, R14
   \   00033E   4C5C         RLA.B   R12
   \   000340   4C5C         RLA.B   R12
   \   000342   4E5C         ADD.B   R12, R14
   \   000344   4C5C         RLA.B   R12
   \   000346   4C5E         ADD.B   R14, R12
   \   000348   445C         ADD.B   R12, R4
   \   00034A   043C         JMP     ??per_sample_dsp_21
   \                     ??per_sample_dsp_3:
   \   00034C   74503000     ADD.B   #0x30, R4
   \   000350   4493         CMP.B   #0x0, R4
   \   000352   FC3B         JL      ??per_sample_dsp_3
   \                     ??per_sample_dsp_21:
   \   000354   1D42....     MOV.W   &working_data + 334, R13
   \   000358   8411         SXT     R4
   \   00035A   0454         RLA.W   R4
   \   00035C   1C44....     MOV.W   working_data + 90(R4), R12
   \   000360   B012....     CALL    #q1_15_mul
   \   000364   044C         MOV.W   R12, R4
   \   000366   6C49         MOV.B   @R9, R12
   \   000368   5C82....     SUB.B   &working_data + 332, R12
   \   00036C   454C         MOV.B   R12, R5
   \   00036E   4C93         CMP.B   #0x0, R12
   \   000370   1338         JL      ??per_sample_dsp_4
   \   000372   7C903000     CMP.B   #0x30, R12
   \   000376   1428         JNC     ??per_sample_dsp_22
   \   000378   7E403000     MOV.B   #0x30, R14
   \   00037C   B012....     CALL    #?DivMod8u
   \   000380   4C5C         RLA.B   R12
   \   000382   4C5C         RLA.B   R12
   \   000384   4C5C         RLA.B   R12
   \   000386   4C5C         RLA.B   R12
   \   000388   4E4C         MOV.B   R12, R14
   \   00038A   4C5C         RLA.B   R12
   \   00038C   4C5C         RLA.B   R12
   \   00038E   4E5C         ADD.B   R12, R14
   \   000390   4C5C         RLA.B   R12
   \   000392   4C5E         ADD.B   R14, R12
   \   000394   455C         ADD.B   R12, R5
   \   000396   043C         JMP     ??per_sample_dsp_22
   \                     ??per_sample_dsp_4:
   \   000398   75503000     ADD.B   #0x30, R5
   \   00039C   4593         CMP.B   #0x0, R5
   \   00039E   FC3B         JL      ??per_sample_dsp_4
    426                          mac_power(sensor_dot_products->P_reactive, V_quad_corrected, I_sample[ch]);
   \                     ??per_sample_dsp_22:
   \   0003A0   2E41         MOV.W   @SP, R14
   \   0003A2   1F410200     MOV.W   0x2(SP), R15
   \   0003A6   0411         RRA.W   R4
   \   0003A8   8511         SXT     R5
   \   0003AA   0555         RLA.W   R5
   \   0003AC   1D45....     MOV.W   working_data + 90(R5), R13
   \   0003B0   0D11         RRA.W   R13
   \   0003B2   0D54         ADD.W   R4, R13
   \   0003B4   0C48         MOV.W   R8, R12
   \   0003B6   3C52         ADD.W   #0x8, R12
   \   0003B8   8A12         CALL    R10
    427          #endif
    428          #if defined(FUNDAMENTAL_ACTIVE_POWER_SUPPORT)
    429                          mac_power(sensor_dot_products->P_fundamental_active, V_pure, I_sample[ch]);
   \   0003BA   2E41         MOV.W   @SP, R14
   \   0003BC   1F410200     MOV.W   0x2(SP), R15
   \   0003C0   1D410600     MOV.W   0x6(SP), R13
   \   0003C4   0C48         MOV.W   R8, R12
   \   0003C6   3C501000     ADD.W   #0x10, R12
   \   0003CA   8A12         CALL    R10
    430          #endif
    431          #if defined(FUNDAMENTAL_REACTIVE_POWER_SUPPORT)
    432                          mac_power(sensor_dot_products->P_fundamental_reactive, -V_quad_pure, I_sample[ch]);
   \   0003CC   2E41         MOV.W   @SP, R14
   \   0003CE   1F410200     MOV.W   0x2(SP), R15
   \   0003D2   1D410400     MOV.W   0x4(SP), R13
   \   0003D6   3DE3         XOR.W   #0xffff, R13
   \   0003D8   1D53         ADD.W   #0x1, R13
   \   0003DA   0C48         MOV.W   R8, R12
   \   0003DC   3C501800     ADD.W   #0x18, R12
   \   0003E0   8A12         CALL    R10
    433          #endif
    434                      }
    435                      ++sensor_dot_products->sample_count;
   \                     ??per_sample_dsp_19:
   \   0003E2   98532800     ADD.W   #0x1, 0x28(R8)
    436                  }
    437          
    438          #ifdef TEAGER_KAISER_TEST_SUPPORT    
    439                   
    440                  phase->metrology.V_good_history <<= 1;
    441                  if (((int32_t)(phase->metrology.V_history[adjust_v_history_index (phase->metrology.V_history_index - 1)])
    442                     * (phase->metrology.V_history[adjust_v_history_index (phase->metrology.V_history_index - 1)])) 
    443                      - ((int32_t)(V_sample) * phase->metrology.V_history[adjust_v_history_index (phase->metrology.V_history_index - 2)])
    444                        > ((P1OUT & BIT0) ? (170000) : (135000)))
    445                  {
    446                      phase->metrology.V_good_history |= 1;
    447                  }  
    448                  else
    449                  {  
    450                      phase->metrology.V_good_history &= ~0x01;
    451                  }
    452                  
    453                  if (phase->metrology.V_good_history == 0xffff)
    454                  {
    455                      V_GOOD_ON ();
    456                  }
    457                  if (phase->metrology.V_good_history == 0x0000)
    458                  {
    459                      V_GOOD_OFF ();
    460                  }
    461          #endif       
    462                  phase->metrology.V_history_index = adjust_v_history_index (phase->metrology.V_history_index + 1);
   \   0003E6   6C49         MOV.B   @R9, R12
   \   0003E8   5C53         ADD.B   #0x1, R12
   \   0003EA   4A4C         MOV.B   R12, R10
   \   0003EC   4C93         CMP.B   #0x0, R12
   \   0003EE   1338         JL      ??per_sample_dsp_5
   \   0003F0   7C903000     CMP.B   #0x30, R12
   \   0003F4   1428         JNC     ??per_sample_dsp_23
   \   0003F6   7E403000     MOV.B   #0x30, R14
   \   0003FA   B012....     CALL    #?DivMod8u
   \   0003FE   4C5C         RLA.B   R12
   \   000400   4C5C         RLA.B   R12
   \   000402   4C5C         RLA.B   R12
   \   000404   4C5C         RLA.B   R12
   \   000406   4E4C         MOV.B   R12, R14
   \   000408   4C5C         RLA.B   R12
   \   00040A   4C5C         RLA.B   R12
   \   00040C   4E5C         ADD.B   R12, R14
   \   00040E   4C5C         RLA.B   R12
   \   000410   4C5E         ADD.B   R14, R12
   \   000412   4A5C         ADD.B   R12, R10
   \   000414   043C         JMP     ??per_sample_dsp_23
   \                     ??per_sample_dsp_5:
   \   000416   7A503000     ADD.B   #0x30, R10
   \   00041A   4A93         CMP.B   #0x0, R10
   \   00041C   FC3B         JL      ??per_sample_dsp_5
   \                     ??per_sample_dsp_23:
   \   00041E   C24A....     MOV.B   R10, &working_data + 186
    463          
    464                  /* Do the power cycle start detection */
    465                  /* There is no hysteresis used here, but since the signal is
    466                     changing rapidly at the zero crossings, and is always of
    467                     large amplitude, miscounting cycles due to general noise
    468                     should not occur. Spikes are another matter. A large spike
    469                     could cause the power cycles to be miscounted, but does not
    470                     matter very much. The cycle counting is not critical to power
    471                     or energy measurement. */
    472          #if defined(MAINS_FREQUENCY_SUPPORT)
    473              #if defined(LIMP_MODE_SUPPORT)
    474                  if (operating_mode == OPERATING_MODE_LIMP)
    475                      phase->metrology.cycle_sample_count += LIMP_SAMPLING_RATIO*256;
    476                  else
    477              #endif
    478                      phase->metrology.cycle_sample_count += 256;
   \   000422   B2500001.... ADD.W   #0x100, &working_data + 348
    479          #endif
    480                  if (abs(V_corrected - phase->metrology.last_V_sample) <= phase->metrology.since_last*MAX_PER_SAMPLE_VOLTAGE_SLEW)
   \   000428   0F4B         MOV.W   R11, R15
   \   00042A   1F82....     SUB.W   &working_data + 356, R15
   \   00042E   0F93         CMP.W   #0x0, R15
   \   000430   0234         JGE     ??per_sample_dsp_8
   \   000432   3FE3         XOR.W   #0xffff, R15
   \   000434   1F53         ADD.W   #0x1, R15
   \                     ??per_sample_dsp_8:
   \   000436   0212         PUSH.W  SR
   \   000438   32C2         DINT
   \   00043A   0343         NOP
   \   00043C   9242....3001 MOV.W   &working_data + 354, &0x130
   \   000442   B240A00F3801 MOV.W   #0xfa0, &0x138
   \   000448   1E423A01     MOV.W   &0x13a, R14
   \   00044C   3241         POP.W   SR
   \   00044E   0E9F         CMP.W   R15, R14
   \   000450   6638         JL      ??per_sample_dsp_24
    481                  {
    482                      /* This doesn't look like a spike - do mains cycle detection, and
    483                         estimate the precise mains period */
    484                      if (V_corrected < 0)
   \   000452   0B93         CMP.W   #0x0, R11
   \   000454   1834         JGE     ??per_sample_dsp_25
    485                      {
    486                          /* We just crossed from positive to negative */
    487                          /* Log the sign of the signal */
    488                          if (phase->status & PHASE_STATUS_V_POS)
   \   000456   A2B3....     BIT.W   #0x2, &working_data + 360
   \   00045A   5D28         JNC     ??per_sample_dsp_26
    489                          {
    490                              phase->status &= ~PHASE_STATUS_V_POS;
   \   00045C   A2C3....     BIC.W   #0x2, &working_data + 360
    491                              ZERO_CROSS_ON ();
   \   000460   B012....     CALL    #ZERO_CROSS_ON
    492                              phase->metrology.current[ch].I_dc_estimate_temp  = dc_filter_current_estimate (phase->metrology.current[ch].I_dc_estimate[normal_limp]);
   \   000464   3C40....     MOV.W   #working_data + 230, R12
   \   000468   B012....     CALL    #dc_filter24_estimate
   \   00046C   824C....     MOV.W   R12, &working_data + 240
   \   000470   824D....     MOV.W   R13, &working_data + 242
    493                              phase->metrology.V_dc_estimate_temp = dc_filter_voltage_estimate(phase->metrology.V_dc_estimate[normal_limp]); 
   \   000474   3C40....     MOV.W   #working_data + 78, R12
   \   000478   B012....     CALL    #dc_filter16_estimate
   \   00047C   824C....     MOV.W   R12, &working_data + 86
   \   000480   824D....     MOV.W   R13, &working_data + 88
   \   000484   483C         JMP     ??per_sample_dsp_26
    494                          }
    495                      }
    496                      else
    497                      {
    498                          /* We just crossed from negative to positive */
    499                          if (!(phase->status & PHASE_STATUS_V_POS))
   \                     ??per_sample_dsp_25:
   \   000486   A2B3....     BIT.W   #0x2, &working_data + 360
   \   00048A   452C         JC      ??per_sample_dsp_26
    500                          {
    501                              /* Log the sign of the signal */
    502                              phase->status |= PHASE_STATUS_V_POS;
   \   00048C   A2D3....     BIS.W   #0x2, &working_data + 360
    503                              ZERO_CROSS_OFF ();
   \   000490   B012....     CALL    #ZERO_CROSS_OFF
    504          #if defined(MAINS_FREQUENCY_SUPPORT)
    505                              /* Apply limits to the sample count, to avoid spikes or dying power lines disturbing the
    506                                 frequency reading too much */
    507                              /* The mains should be <40Hz or >70Hz to fail this test! */
    508                              if (((256*SAMPLES_PER_10_SECONDS)/700) <= phase->metrology.cycle_sample_count  &&  phase->metrology.cycle_sample_count <= (((256*SAMPLES_PER_10_SECONDS)/400)))
   \   000494   1F42....     MOV.W   &working_data + 348, R15
   \   000498   3F50B78D     ADD.W   #0x8db7, R15
   \   00049C   3F90B855     CMP.W   #0x55b8, R15
   \   0004A0   382C         JC      ??per_sample_dsp_27
    509                              {
    510                                  /* A mains frequency measurement procedure based on interpolating zero crossings,
    511                                     to get a fast update rate for step changes in the mains frequency */
    512              #if defined(SAG_SWELL_SUPPORT)
    513                                  accum48_48(phase_dot_products->V_sq, phase->metrology.V_sq_cycle);
    514                                  decum48_48(phase->metrology.V_sq_window, phase->metrology.V_sq_prev_cycle[phase->metrology.prev_cycle_ptr]);
    515                                  accum48_48(phase->metrology.V_sq_window, phase->metrology.V_sq_cycle);
    516                                  transfer48(phase->metrology.V_sq_prev_cycle[phase->metrology.prev_cycle_ptr], phase->metrology.V_sq_cycle);
    517                                  if (++phase->metrology.prev_cycle_ptr >= SAG_SWELL_WINDOW_LEN)
    518                                      phase->metrology.prev_cycle_ptr = 0;
    519                                  if (phase->metrology.V_sq_window[2] < phase->metrology.sag_threshold[2]
    520                                      ||
    521                                      (phase->metrology.V_sq_window[2] == phase->metrology.sag_threshold[2]  &&  (uint16_t) phase->metrology.V_sq_window[1] < (uint16_t) phase->metrology.sag_threshold[1]))
    522                                  {
    523                                      if (phase->metrology.sag_status != -1)
    524                                      {
    525                                          phase->metrology.sag_status = -1;
    526                                          phase->sag_events++;
    527                                      }
    528                                      phase->sag_duration++;
    529                                  }
    530                                  else if (phase->metrology.V_sq_window[2] > phase->metrology.swell_threshold[2]
    531                                           ||
    532                                           (phase->metrology.V_sq_window[2] == phase->metrology.swell_threshold[2]  &&  (uint16_t) phase->metrology.V_sq_window[1] > (uint16_t) phase->metrology.swell_threshold[1]))
    533                                  {
    534                                      if (phase->metrology.sag_status != 1)
    535                                      {
    536                                          phase->metrology.sag_status = 1;
    537                                          phase->swell_events++;
    538                                      }
    539                                      phase->swell_duration++;
    540                                  }
    541                                  else
    542                                  {
    543                                      phase->metrology.sag_status = 0;
    544                                  }
    545              #endif
    546                                  /* Interpolate the zero crossing by successive approx. */
    547                                  z = V_corrected - phase->metrology.last_V_sample;
   \   0004A2   0D4B         MOV.W   R11, R13
   \   0004A4   1D82....     SUB.W   &working_data + 356, R13
    548                                  x = 0;
   \   0004A8   0F43         MOV.W   #0x0, R15
    549                                  y = 0;
   \   0004AA   0E43         MOV.W   #0x0, R14
    550                                  for (k = 0;  k < 8;  k++)
   \   0004AC   7A42         MOV.B   #0x8, R10
    551                                  {
    552                                      y <<= 1;
   \                     ??per_sample_dsp_6:
   \   0004AE   0E5E         RLA.W   R14
    553                                      z >>= 1;
   \   0004B0   0D11         RRA.W   R13
    554                                      x += z;
   \   0004B2   0F5D         ADD.W   R13, R15
    555                                      if (x > V_corrected)
   \   0004B4   0B9F         CMP.W   R15, R11
   \   0004B6   0234         JGE     ??per_sample_dsp_28
    556                                          x -= z;
   \   0004B8   0F8D         SUB.W   R13, R15
   \   0004BA   013C         JMP     ??per_sample_dsp_29
    557                                      else
    558                                          y |= 1;
   \                     ??per_sample_dsp_28:
   \   0004BC   1ED3         BIS.W   #0x1, R14
    559                                  }
   \                     ??per_sample_dsp_29:
   \   0004BE   7A53         ADD.B   #0xff, R10
   \   0004C0   F623         JNE     ??per_sample_dsp_6
    560                                  /* Now we need to allow for skipped samples, due to spike detection */
    561                                  z = y;
   \   0004C2   0D4E         MOV.W   R14, R13
    562                                  while (phase->metrology.since_last > 1)
   \   0004C4   A293....     CMP.W   #0x2, &working_data + 354
   \   0004C8   1838         JL      ??per_sample_dsp_30
    563                                  {
    564                                      z += y;
   \                     ??per_sample_dsp_7:
   \   0004CA   0D5E         ADD.W   R14, R13
    565                                      phase->metrology.since_last--;
   \   0004CC   B253....     ADD.W   #0xffff, &working_data + 354
   \   0004D0   A293....     CMP.W   #0x2, &working_data + 354
   \   0004D4   1238         JL      ??per_sample_dsp_30
   \   0004D6   0D5E         ADD.W   R14, R13
   \   0004D8   B253....     ADD.W   #0xffff, &working_data + 354
   \   0004DC   A293....     CMP.W   #0x2, &working_data + 354
   \   0004E0   0C38         JL      ??per_sample_dsp_30
   \   0004E2   0D5E         ADD.W   R14, R13
   \   0004E4   B253....     ADD.W   #0xffff, &working_data + 354
   \   0004E8   A293....     CMP.W   #0x2, &working_data + 354
   \   0004EC   0638         JL      ??per_sample_dsp_30
   \   0004EE   0D5E         ADD.W   R14, R13
   \   0004F0   B253....     ADD.W   #0xffff, &working_data + 354
   \   0004F4   A293....     CMP.W   #0x2, &working_data + 354
   \   0004F8   E837         JGE     ??per_sample_dsp_7
    566                                  }
    567                                  /* z is now the fraction of a sample interval between the zero
    568                                     crossing and the current sample, in units of 1/256 of a sample */
    569                                  /* A lightly damped single pole filter should now be enough to remove noise and get a
    570                                     stable value for the frequency */
    571          //                        phase->metrology.mains_period += ((uint32_t) (phase->metrology.cycle_sample_count - z) << 12) - (phase->metrology.mains_period >> 4);
    572                                  phase->metrology.mains_period = (((uint32_t) (phase->metrology.cycle_sample_count - z) << 16));
   \                     ??per_sample_dsp_30:
   \   0004FA   1F42....     MOV.W   &working_data + 348, R15
   \   0004FE   0F8D         SUB.W   R13, R15
   \   000500   8243....     MOV.W   #0x0, &working_data + 350
   \   000504   824F....     MOV.W   R15, &working_data + 352
    573                                  /* Start the next cycle with the residual fraction of a sample */
    574                                  phase->metrology.cycle_sample_count = z;
   \   000508   824D....     MOV.W   R13, &working_data + 348
    575          
    576                                  phase->metrology.cycle_count++;
   \   00050C   9253....     ADD.W   #0x1, &working_data + 200
   \   000510   023C         JMP     ??per_sample_dsp_26
    577                              }
    578                              else
    579                              {
    580                                  phase->metrology.cycle_sample_count = 0;
   \                     ??per_sample_dsp_27:
   \   000512   8243....     MOV.W   #0x0, &working_data + 348
    581                              }
    582          #endif
    583          #if defined(POWER_FACTOR_SUPPORT)  &&  !defined(REACTIVE_POWER_BY_QUADRATURE_SUPPORT)
    584                              /* If we are not measuring the reactive power in a quadrature manner, we
    585                                 need to work out if the current leads or lags the voltage in another way. */
    586                              /* Determine whether the current leads or lags, in a noise tolerant manner.
    587                                 Testing 50 cycles means we will respond in about one second to a genuine
    588                                 swap between lead and lag. Since that is also about the length of our
    589                                 measurement blocks, this seems a sensible response time. */
    590          #if NUM_PHASES == 1  &&  defined(NEUTRAL_MONITOR_SUPPORT)
    591                              for (ch = 0;  ch < 2;  ch++)
    592          #endif
    593                              {
    594                                  if (I_sample[ch] < V_corrected)
    595                                  {
    596                                      if (phase->metrology.current[ch].leading > -50)
    597                                          phase->metrology.current[ch].leading--;
    598                                  }
    599                                  else
    600                                  {
    601                                      if (phase->metrology.current[ch].leading < 50)
    602                                          phase->metrology.current[ch].leading++;
    603                                  }
    604                              }
    605          #endif
    606                              /* See if a sufficiently long measurement interval has been
    607                                 recorded, and catch the start of the next cycle. We do not
    608                                 really care how many cycles there are, as long as the block
    609                                 is a reasonable length. Setting a minimum of 1 second is
    610                                 better than counting cycles, as it is not affected by noise
    611                                 spikes. Synchronising to a whole number of cycles reduces
    612                                 block to block jitter, though it doesn't affect the long
    613                                 term accuracy of the measurements. */
    614          //                    if (phase_dot_products->sample_count >= samples_per_second)
    615                          }
    616                      }
    617                      phase->metrology.since_last = 0;
   \                     ??per_sample_dsp_26:
   \   000516   8243....     MOV.W   #0x0, &working_data + 354
    618                      phase->metrology.last_V_sample = V_corrected;
   \   00051A   824B....     MOV.W   R11, &working_data + 356
    619                  }
    620                  phase->metrology.since_last++;
   \                     ??per_sample_dsp_24:
   \   00051E   9253....     ADD.W   #0x1, &working_data + 354
    621          
    622                  if (phase->metrology.cycle_count >= REPORT_CYCLE)
   \   000522   A292....     CMP.W   #0x4, &working_data + 200
   \   000526   1228         JNC     ??per_sample_dsp_31
    623                  {
    624          #if NUM_PHASES == 1
    625                      log_parameters();
   \   000528   B012....     CALL    #log_parameters
    626          #else
    627                      log_parameters(phase, ph);
    628          #endif
    629          
    630                      if (phase->status & PHASE_STATUS_DC_MODE)
   \   00052C   8293....     CMP.W   #0x0, &working_data + 360
   \   000530   0534         JGE     ??per_sample_dsp_32
    631                      {
    632                          phase->status &= ~PHASE_STATUS_DC_MODE;
   \   000532   B2C00080.... BIC.W   #0x8000, &working_data + 360
    633                          metrology_init_from_nv_data ();
   \   000538   B012....     CALL    #metrology_init_from_nv_data
    634                      }
    635                      phase->metrology.cycle_count = 0;
   \                     ??per_sample_dsp_32:
   \   00053C   8243....     MOV.W   #0x0, &working_data + 200
    636                      kick = TRUE;
   \   000540   1743         MOV.W   #0x1, R7
    637                      DC_MODE_OFF ();
   \   000542   B012....     CALL    #DC_MODE_OFF
    638                      AC_MODE_ON ();
   \   000546   B012....     CALL    #AC_MODE_ON
   \   00054A   2E3C         JMP     ??per_sample_dsp_33
    639                  }
    640          //        else if ((phase_dot_products->sample_count >= ((REPORT_CYCLE*samples_per_second)/MAINS_NOMINAL_FREQUENCY)))
    641                  else if ((phase_dot_products->sample_count >= ((REPORT_CYCLE*SAMPLE_RATE)/MAINS_NOMINAL_FREQUENCY)))
   \                     ??per_sample_dsp_31:
   \   00054C   B69080020C00 CMP.W   #0x280, 0xc(R6)
   \   000552   2A38         JL      ??per_sample_dsp_33
    642                  {
    643                      if (phase->metrology.cycle_count < (REPORT_CYCLE - 1))
   \   000554   B2900300.... CMP.W   #0x3, &working_data + 200
   \   00055A   262C         JC      ??per_sample_dsp_33
    644                      {
    645                      #if NUM_PHASES == 1
    646                          log_parameters();
   \   00055C   B012....     CALL    #log_parameters
    647                      #else
    648                          log_parameters(phase, ph);
    649                      #endif
    650                          if (!(phase->status & PHASE_STATUS_DC_MODE))
   \   000560   8293....     CMP.W   #0x0, &working_data + 360
   \   000564   1A38         JL      ??per_sample_dsp_34
    651                          {
    652                              phase->status |= PHASE_STATUS_DC_MODE;
   \   000566   B2D00080.... BIS.W   #0x8000, &working_data + 360
    653                              metrology_init_from_nv_data ();
   \   00056C   B012....     CALL    #metrology_init_from_nv_data
    654          //                    phase->metrology.V_dc_estimate_logged =  ((int32_t)phase_cal->initial_v_dc_estimate[0] * 256);
    655                              phase->metrology.V_dc_estimate_logged =  ((int32_t)cal_info->phases[ph].initial_v_dc_estimate[0] * 256);
   \   000570   1E42....     MOV.W   &nv_parms + 16, R14
   \   000574   0F4E         MOV.W   R14, R15
   \   000576   3FE3         XOR.W   #0xffff, R15
   \   000578   0F5F         RLA.W   R15
   \   00057A   4F7F         SUBC.B  R15, R15
   \   00057C   4FEE         XOR.B   R14, R15
   \   00057E   0FEE         XOR.W   R14, R15
   \   000580   8F10         SWPB    R15
   \   000582   7EF3         AND.B   #0xff, R14
   \   000584   8E10         SWPB    R14
   \   000586   824E....     MOV.W   R14, &working_data + 82
   \   00058A   824F....     MOV.W   R15, &working_data + 84
    656          //                    phase->metrology.current[ch].I_dc_estimate_logged = phase_cal->current[0].initial_dc_estimate[0];
    657                              phase->metrology.current[ch].I_dc_estimate_logged = cal_info->phases[ph].current[0].initial_dc_estimate[0];
   \   00058E   9242........ MOV.W   &nv_parms + 2, &working_data + 236
   \   000594   9242........ MOV.W   &nv_parms + 4, &working_data + 238
    658                          }
    659                          phase->metrology.cycle_count = 0;
   \                     ??per_sample_dsp_34:
   \   00059A   8243....     MOV.W   #0x0, &working_data + 200
    660                          kick = TRUE;
   \   00059E   1743         MOV.W   #0x1, R7
    661                          AC_MODE_OFF ();
   \   0005A0   B012....     CALL    #AC_MODE_OFF
    662                          DC_MODE_ON ();
   \   0005A4   B012....     CALL    #DC_MODE_ON
    663                      }
    664                  }
    665                  
    666          #if NUM_PHASES == 1  &&  defined(NEUTRAL_MONITOR_SUPPORT)
    667                  for (ch = 0;  ch < 2;  ch++)
    668          #endif
    669                  {
    670          #if defined(MAINS_FREQUENCY_SUPPORT)
    671                      /* Monitor the cycles and frequency of the current sensors, as limp
    672                         mode is based on these. */
    673              #if defined(LIMP_MODE_SUPPORT)
    674                      if (operating_mode == OPERATING_MODE_LIMP)
    675                          phase->metrology.current[ch].cycle_sample_count += 256*LIMP_SAMPLING_RATIO;
    676                      else
    677              #endif
    678          //                phase->metrology.current[ch].cycle_sample_count += 256;
    679          #endif
    680          //            if (I_sample[ch] < 0)
    681          //            {
    682                          /* Log the sign of the signal */
    683          //                phase->status &= ~current_pos_masks[ch];
    684          //            }
    685          //            else
    686          //            {
    687          //                if (!(phase->status & current_pos_masks[ch]))
    688          //                {
    689                              /* A negative to positive transition has occurred. Trust it
    690                                 blindly as a genuine zero crossing/start of cycle, even
    691                                 though it might really be due to a noise spike. */
    692          #if defined(MAINS_FREQUENCY_SUPPORT)
    693          //                    if (SAMPLES_PER_10_SECONDS/700 <= phase->metrology.current[ch].cycle_sample_count  &&  phase->metrology.current[ch].cycle_sample_count <= SAMPLES_PER_10_SECONDS/400)
    694          //                        phase->metrology.current[ch].mains_period += ((uint32_t) phase->metrology.current[ch].cycle_sample_count << 16) - (phase->metrology.current[ch].mains_period >> 8);
    695          //                    phase->metrology.current[ch].cycle_sample_count = 0;
    696          #endif
    697          //                }
    698                          /* Log the sign of the signal */
    699          //                phase->status |= current_pos_masks[ch];
    700          //            }
    701                  }
    702              }
    703          
    704          #if NUM_PHASES > 1  &&  defined(NEUTRAL_MONITOR_SUPPORT)  &&  defined(IRMS_SUPPORT)
    705              /* For multi-phase meters, neutral monitoring is limited to measuring the
    706                 neutral RMS current, and the residual RMS current. */
    707              dp = working_data.neutral.metrology.dp_set ^ 1;
    708              neutral_dot_products = &working_data.neutral.metrology.dot_prod[dp];
    709              I_corrected = adc_i_buffer[NUM_PHASES];
    710              #if defined(TEMPERATURE_SUPPORT)  &&  !defined(__MSP430_HAS_ADC10_A__)
    711              if (temperature_sequence)
    712              {
    713                  temperature_sequence++;
    714                  if (temperature_sequence == 6)
    715                  {
    716                      /* We are in temperature measurement mode */
    717                      raw_temperature_from_adc += I_corrected - (raw_temperature_from_adc >> 3);
    718                  #if defined(TRNG_SUPPORT)
    719                      rolling_random = (rolling_random << 1) | (I_corrected & 1);
    720                      if (++rand_bits == 16)
    721                      {
    722                          random_value = rolling_random;
    723                          new_random_value = TRUE;
    724                          rand_bits = 0;
    725                      }
    726                  #endif
    727                      /* Select the current input */
    728                      sd_xxxx_reg(SD_INCTL_, NEUTRAL_CURRENT_ADC_CHANNEL) = SD_INCH_CURRENT | SD_NEUTRAL_CURRENT_GAIN;
    729                  }
    730                  else if (temperature_sequence == 11)
    731                  {
    732                      /* We have waited long enough to be back on good current samples */
    733                      temperature_sequence = 0;
    734                  }
    735                  /* TODO: Can't we do better than just stalling on the last value? */
    736                  I_corrected = working_data.neutral.metrology.I_history[I_HISTORY_STEPS - 1];
    737              }
    738              else
    739              #endif
    740              {
    741                  if ((I_corrected >= I_ADC_MAX  ||  I_corrected <= I_ADC_MIN)  &&  working_data.neutral.metrology.I_endstops)
    742                      working_data.neutral.metrology.I_endstops--;
    743                  I_sample[0] = dc_filter_current(working_data.neutral.metrology.I_dc_estimate[normal_limp], working_data.neutral.metrology.I_history[0]);
    744                  sqac_current(neutral_dot_products->I_sq, I_sample[0]);
    745              #if defined(RESIDUAL_IRMS_SUPPORT)
    746                  /* Scale the current from the neutral by 1/sqrt(2) */
    747                  I_sample[0] = q1_15_mul(I_sample[0], 21790);
    748                  I_sample[0] -= I_residue;
    749                  sqac_current(neutral_dot_products->residual_I_sq, I_sample[0]);
    750              #endif
    751              }
    752          //    if (++neutral_dot_products->sample_count >= samples_per_second)
    753              if (++neutral_dot_products->sample_count >= SAMPLE_RATE)
    754              {
    755                  log_neutral_parameters();
    756              #if defined(TEMPERATURE_SUPPORT)  &&  !defined(__MSP430_HAS_ADC10_A__)
    757                  temperature_sequence = 1;
    758                  /* Select the temperature diode */
    759                  sd_xxxx_reg(SD_INCTL_, NEUTRAL_CURRENT_ADC_CHANNEL) = SD_INCH_TEMPERATURE | SD_GAIN_TEMPERATURE;
    760              #endif
    761              }
    762              #if I_HISTORY_STEPS > 2
    763              for (k = 0;  k < I_HISTORY_STEPS - 1;  k++)
    764                  working_data.neutral.metrology.I_history[k] = working_data.neutral.metrology.I_history[k + 1];
    765              #else
    766              working_data.neutral.metrology.I_history[0] = working_data.neutral.metrology.I_history[1];
    767              #endif
    768              working_data.neutral.metrology.I_history[I_HISTORY_STEPS - 1] = I_corrected;
    769          #endif
    770              return kick;
   \                     ??per_sample_dsp_33:
   \   0005A8   0C47         MOV.W   R7, R12
   \   0005AA   31500C00     ADD.W   #0xc, SP
   \   0005AE   3040....     BR      #?Epilogue8
    771          }

   \                                 In  segment DATA16_Z, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
   \                     ??Last_I_sample:
   \   000000                DS8 2
    772          
    773          #if defined(ENERGY_PULSE_SUPPORT)  ||  defined(TOTAL_ENERGY_PULSE_SUPPORT)
    774          static __inline__ void per_sample_energy_pulse_processing(void)
    775          {
    776          #if defined(ENERGY_PULSE_SUPPORT)  &&  NUM_PHASES > 1
    777              struct phase_parms_s *phase;
    778              int ph;
    779          #endif
    780              power_t pow;
    781          
    782              /* We now play the last measurement interval's power level, evaluated
    783                 in the foreground, through this measurement interval. In this way
    784                 we can evenly pace the pulsing of the LED. The only error produced
    785                 by this is the ambiguity in the number of samples per measurement.
    786                 This should not exceed 1 or 2 in over 4000. */
    787          
    788          #if defined(TOTAL_ACTIVE_ENERGY_PULSES_PER_KW_HOUR)
    789              pow = working_data.totals.readings.active_power;
    790              #if defined(LIMP_MODE_SUPPORT)
    791              if (operating_mode == OPERATING_MODE_LIMP)
    792                  pow *= LIMP_SAMPLING_RATIO;
    793              #endif
    794              #if defined(INHIBIT_NEGATIVE_TOTAL_POWER_ACCUMULATION)
    795              if (pow > 0)
    796              #endif
    797              {
    798                  if ((working_data.totals.energy.active_energy_pulse.energy_integrator += pow) >= TOTAL_ACTIVE_ENERGY_PULSE_THRESHOLD)
    799                  {
    800                      working_data.totals.energy.active_energy_pulse.energy_integrator -= TOTAL_ACTIVE_ENERGY_PULSE_THRESHOLD;
    801                      working_data.totals.energy.active_energy_pulse.pulse_remaining_time = ENERGY_PULSE_DURATION;
    802                      total_active_energy_pulse_start();
    803                  }
    804              }
    805              if (working_data.totals.energy.active_energy_pulse.pulse_remaining_time  &&  --working_data.totals.energy.active_energy_pulse.pulse_remaining_time == 0)
    806                  total_active_energy_pulse_end();
    807          #endif
    808          
    809          #if defined(TOTAL_REACTIVE_ENERGY_PULSES_PER_KVAR_HOUR)
    810              pow = working_data.totals.readings.reactive_power;
    811              #if defined(LIMP_MODE_SUPPORT)
    812              if (operating_mode == OPERATING_MODE_LIMP)
    813                  pow *= LIMP_SAMPLING_RATIO;
    814              #endif
    815              #if defined(INHIBIT_NEGATIVE_TOTAL_POWER_ACCUMULATION)
    816              if (pow > 0)
    817              #endif
    818              {
    819                  if ((working_data.totals.energy.reactive_energy_pulse.energy_integrator += pow) >= TOTAL_REACTIVE_ENERGY_PULSE_THRESHOLD)
    820                  {
    821                      working_data.totals.energy.reactive_energy_pulse.energy_integrator -= TOTAL_REACTIVE_ENERGY_PULSE_THRESHOLD;
    822                      working_data.totals.energy.reactive_energy_pulse.pulse_remaining_time = ENERGY_PULSE_DURATION;
    823                      total_reactive_energy_pulse_start();
    824                  }
    825              }
    826              if (working_data.totals.energy.reactive_energy_pulse.pulse_remaining_time  &&  --working_data.totals.energy.reactive_energy_pulse.pulse_remaining_time == 0)
    827                  total_reactive_energy_pulse_end();
    828          #endif
    829          
    830          #if defined(TOTAL_APPARENT_ENERGY_PULSES_PER_KVA_HOUR)
    831              pow = working_data.totals.readings.apparent_power;
    832              #if defined(LIMP_MODE_SUPPORT)
    833              if (operating_mode == OPERATING_MODE_LIMP)
    834                  pow *= LIMP_SAMPLING_RATIO;
    835              #endif
    836              #if defined(INHIBIT_NEGATIVE_TOTAL_POWER_ACCUMULATION)
    837              if (pow > 0)
    838              #endif
    839              {
    840                  if ((working_data.totals.energy.reactive_energy_pulse.energy_integrator += pow) >= TOTAL_APPARENT_ENERGY_PULSE_THRESHOLD)
    841                  {
    842                      working_data.totals.energy.reactive_energy_pulse.energy_integrator -= TOTAL_APPARENT_ENERGY_PULSE_THRESHOLD;
    843                      working_data.totals.energy.reactive_energy_pulse.pulse_remaining_time = ENERGY_PULSE_DURATION;
    844                      total_apparent_energy_pulse_start();
    845                  }
    846              }
    847              if (working_data.totals.energy.reactive_energy_pulse.pulse_remaining_time  &&  --working_data.totals.energy.reactive_energy_pulse.pulse_remaining_time == 0)
    848                  total_apparent_energy_pulse_end();
    849          #endif
    850          
    851          #if defined(ENERGY_PULSE_SUPPORT)
    852              #if NUM_PHASES == 1
    853          #undef ph
    854          #define ph /**/
    855              #else
    856              for (ph = 0, phase = working_data.phases;  ph < NUM_PHASES;  ph++, phase++)
    857              #endif
    858              {
    859              #if defined(ACTIVE_ENERGY_PULSES_PER_KW_HOUR)
    860                  pow = phase->readings.active_power;
    861                  #if defined(LIMP_MODE_SUPPORT)
    862                  if (operating_mode == OPERATING_MODE_LIMP)
    863                      pow *= LIMP_SAMPLING_RATIO;
    864                  #endif
    865                  #if defined(INHIBIT_NEGATIVE_POWER_ACCUMULATION)
    866                  if (pow > 0)
    867                  #endif
    868                  {
    869                      if ((phase->energy.active_energy_pulse.energy_integrator += pow) >= ACTIVE_ENERGY_PULSE_THRESHOLD)
    870                      {
    871                          phase->energy.active_energy_pulse.energy_integrator -= ACTIVE_ENERGY_PULSE_THRESHOLD;
    872                          phase->energy.active_energy_pulse.pulse_remaining_time = ENERGY_PULSE_DURATION;
    873                          active_energy_pulse_start(ph);
    874                      }
    875                  }
    876                  if (phase->energy.active_energy_pulse.pulse_remaining_time  &&  --phase->energy.active_energy_pulse.pulse_remaining_time == 0)
    877                      active_energy_pulse_end(ph);
    878              #endif
    879          
    880              #if defined(REACTIVE_ENERGY_PULSES_PER_KVAR_HOUR)
    881                  pow = phase->readings.reactive_power;
    882                  #if defined(LIMP_MODE_SUPPORT)
    883                  if (operating_mode == OPERATING_MODE_LIMP)
    884                      pow *= LIMP_SAMPLING_RATIO;
    885                  #endif
    886                  #if defined(INHIBIT_NEGATIVE_POWER_ACCUMULATION)
    887                  if (pow > 0)
    888                  #endif
    889                  {
    890                      if ((phase->energy.reactive_energy_pulse.energy_integrator += pow) >= REACTIVE_ENERGY_PULSE_THRESHOLD)
    891                      {
    892                          phase->energy.reactive_energy_pulse.energy_integrator -= REACTIVE_ENERGY_PULSE_THRESHOLD;
    893                          phase->energy.reactive_energy_pulse.pulse_remaining_time = ENERGY_PULSE_DURATION;
    894                          reactive_energy_pulse_start(ph);
    895                      }
    896                  }
    897                  if (phase->energy.reactive_energy_pulse.pulse_remaining_time  &&  --phase->energy.reactive_energy_pulse.pulse_remaining_time == 0)
    898                      reactive_energy_pulse_end(ph);
    899              #endif
    900          
    901              #if defined(APPARENT_ENERGY_PULSES_PER_KVA_HOUR)
    902                  pow = phase->readings.apparent_power;
    903                  #if defined(LIMP_MODE_SUPPORT)
    904                  if (operating_mode == OPERATING_MODE_LIMP)
    905                      pow *= LIMP_SAMPLING_RATIO;
    906                  #endif
    907                  #if defined(INHIBIT_NEGATIVE_POWER_ACCUMULATION)
    908                  if (pow > 0)
    909                  #endif
    910                  {
    911                      if ((phase->energy.apparent_energy_pulse.energy_integrator += pow) >= APPARENT_ENERGY_PULSE_THRESHOLD)
    912                      {
    913                          phase->energy.apparent_energy_pulse.energy_integrator -= APPARENT_ENERGY_PULSE_THRESHOLD;
    914                          phase->energy.apparent_energy_pulse.pulse_remaining_time = ENERGY_PULSE_DURATION;
    915                          apparent_energy_pulse_start(ph);
    916                      }
    917                  }
    918                  if (phase->energy.reactive_energy_pulse.pulse_remaining_time  &&  --phase->energy.apparent_energy_pulse.pulse_remaining_time == 0)
    919                      apparent_energy_pulse_end(ph);
    920              #endif
    921              }
    922              #if NUM_PHASES == 1
    923          #undef ph
    924              #endif
    925          #endif
    926          }
    927          #endif
    928          
    929          /*-----------------------------------------------------------------------------------
    930            This is the main interrupt routine where the samples are gathered into a set, with
    931            allowance for the staggered times at which the samples become available.
    932            -----------------------------------------------------------------------------------*/
    933          #if defined(__MSP430__)
    934              #if defined(__MSP430_HAS_SD16_2__)  ||  defined(__MSP430_HAS_SD16_3__)
    935          ISR(SD16, adc_interrupt)
    936              #endif
    937              #if defined(__MSP430_HAS_SD16_A3__)  ||  defined(__MSP430_HAS_SD16_A4__)  ||  defined(__MSP430_HAS_SD16_A6__)  ||  defined(__MSP430_HAS_SD16_A7__)
    938          ISR(SD16A, adc_interrupt)
    939              #endif
    940              #if defined(__MSP430_HAS_SD24_2__)  ||  defined(__MSP430_HAS_SD24_A2__)  \
    941                  || defined(__MSP430_HAS_SD24_3__) ||  defined(__MSP430_HAS_SD24_A3__) \
    942                  || defined(__MSP430_HAS_SD24_4__) ||  defined(__MSP430_HAS_SD24_A4__)

   \                                 In  segment CODE, align 2
    943          ISR(SD24, adc_interrupt)
   \                     adc_interrupt:
    944              #endif
    945              #if defined(__MSP430_HAS_SD24_B__) 
    946                  #if 0 //NUM_PHASES > 1  &&  defined(__MSP430_HAS_SD24_B3__)  &&  defined(__MSP430_HAS_ADC10_A__)
    947          ISR(DMA, adc_interrupt)
    948                  #else
    949          ISR(SD24B, adc_interrupt)
    950                  #endif
    951              #endif
    952          #else
    953          void adc_interrupt(void)
    954          #endif
    955          {
   \   000000   0D12         PUSH.W  R13
   \   000002   0C12         PUSH.W  R12
   \   000004   0F12         PUSH.W  R15
   \   000006   0E12         PUSH.W  R14
   \   000008   2182         SUB.W   #0x4, SP
    956              BACKGROUND_PROCESS_ON();
   \   00000A   B012....     CALL    #BACKGROUND_PROCESS_ON
    957          #if defined(__HAS_SD_ADC__)
    958              if (!ADC_VOLTAGE_PENDING(PHASE_1_VOLTAGE_ADC_CHANNEL))
   \   00000E   A2B20201     BIT.W   #0x4, &0x102
   \   000012   1E2C         JC      ??adc_interrupt_2
    959              {
    960                  /* We do not have a complete set of samples yet, but we may need to pick
    961                     up some current values at this time */
    962                  if (ADC_CURRENT_PENDING(PHASE_1_CURRENT_ADC_CHANNEL))
   \   000014   A2B20401     BIT.W   #0x4, &0x104
   \   000018   AF28         JNC     ??adc_interrupt_1
    963                  {
    964                      adc_i_buffer[0] = ADC_CURRENT(PHASE_1_CURRENT_ADC_CHANNEL);
   \   00001A   B2C040000401 BIC.W   #0x40, &0x104
   \   000020   1F421201     MOV.W   &0x112, R15
   \   000024   8F10         SWPB    R15
   \   000026   8F11         SXT     R15
   \   000028   814F0200     MOV.W   R15, 0x2(SP)
   \   00002C   B2D040000401 BIS.W   #0x40, &0x104
   \   000032   1F421201     MOV.W   &0x112, R15
   \   000036   0F5F         RLA.W   R15
   \   000038   0F5F         RLA.W   R15
   \   00003A   0F5F         RLA.W   R15
   \   00003C   814F0000     MOV.W   R15, 0(SP)
   \   000040   824F....     MOV.W   R15, &adc_i_buffer
   \   000044   92410200.... MOV.W   0x2(SP), &adc_i_buffer + 2
    965                      ADC_CURRENT_CLEAR(PHASE_1_CURRENT_ADC_CHANNEL);
   \   00004A   A2C20401     BIC.W   #0x4, &0x104
    966                  }
    967              #if NUM_PHASES >= 2
    968                  if (ADC_CURRENT_PENDING(PHASE_2_CURRENT_ADC_CHANNEL))
    969                  {
    970                      adc_i_buffer[1] = ADC_CURRENT(PHASE_2_CURRENT_ADC_CHANNEL);
    971                      ADC_CURRENT_CLEAR(PHASE_2_CURRENT_ADC_CHANNEL);
    972                  }
    973              #endif
    974              #if NUM_PHASES >= 3
    975                  if (ADC_CURRENT_PENDING(PHASE_3_CURRENT_ADC_CHANNEL))
    976                  {
    977                      adc_i_buffer[2] = ADC_CURRENT(PHASE_3_CURRENT_ADC_CHANNEL);
    978                      ADC_CURRENT_CLEAR(PHASE_3_CURRENT_ADC_CHANNEL);
    979                  }
    980              #endif
    981              #if NUM_PHASES >= 4
    982                  if (ADC_CURRENT_PENDING(PHASE_4_CURRENT_ADC_CHANNEL))
    983                  {
    984                      adc_i_buffer[3] = ADC_CURRENT(PHASE_4_CURRENT_ADC_CHANNEL);
    985                      ADC_CURRENT_CLEAR(PHASE_4_CURRENT_ADC_CHANNEL);
    986                  }
    987              #endif
    988              #if NUM_PHASES >= 5
    989                  if (ADC_CURRENT_PENDING(PHASE_5_CURRENT_ADC_CHANNEL))
    990                  {
    991                      adc_i_buffer[4] = ADC_CURRENT(PHASE_5_CURRENT_ADC_CHANNEL);
    992                      ADC_CURRENT_CLEAR(PHASE_5_CURRENT_ADC_CHANNEL);
    993                  }
    994              #endif
    995              #if NUM_PHASES >= 6
    996                  if (ADC_CURRENT_PENDING(PHASE_6_CURRENT_ADC_CHANNEL))
    997                  {
    998                      adc_i_buffer[5] = ADC_CURRENT(PHASE_6_CURRENT_ADC_CHANNEL);
    999                      ADC_CURRENT_CLEAR(PHASE_6_CURRENT_ADC_CHANNEL);
   1000                  }
   1001              #endif
   1002              #if defined(NEUTRAL_MONITOR_SUPPORT)
   1003                  if (ADC_CURRENT_PENDING(NEUTRAL_CURRENT_ADC_CHANNEL))
   1004                  {
   1005                      adc_i_buffer[NUM_PHASES] = ADC_CURRENT(NEUTRAL_CURRENT_ADC_CHANNEL);
   1006                      ADC_CURRENT_CLEAR(NEUTRAL_CURRENT_ADC_CHANNEL);
   1007                  }
   1008              #endif
   1009                  return;
   \   00004E   943C         JMP     ??adc_interrupt_1
   1010              }
   1011              /* Voltage is available on all phases (guaranteed, as the voltage ADCs always run in sync). */
   1012              adc_v_buffer[0] = ADC_VOLTAGE(PHASE_1_VOLTAGE_ADC_CHANNEL);
   \                     ??adc_interrupt_2:
   \   000050   92421001.... MOV.W   &0x110, &adc_v_buffer
   1013              ADC_VOLTAGE_CLEAR(PHASE_1_VOLTAGE_ADC_CHANNEL);
   \   000056   A2C20201     BIC.W   #0x4, &0x102
   1014              #if !defined(VOLTAGE_SIGNAL_IS_COMMON)
   1015                  #if NUM_PHASES >= 2
   1016              adc_v_buffer[1] = ADC_VOLTAGE(PHASE_2_VOLTAGE_ADC_CHANNEL);
   1017              ADC_VOLTAGE_CLEAR(PHASE_2_VOLTAGE_ADC_CHANNEL);
   1018                  #endif
   1019                  #if NUM_PHASES >= 3
   1020              adc_v_buffer[2] = ADC_VOLTAGE(PHASE_3_VOLTAGE_ADC_CHANNEL);
   1021              ADC_VOLTAGE_CLEAR(PHASE_3_VOLTAGE_ADC_CHANNEL);
   1022                  #endif
   1023              #endif
   1024              /* Pick up any current samples which may have occurred a little before the
   1025                 voltage sample, but not those which may have occurred just after the
   1026                 voltage sample. */
   1027              if (working_data.phases[0].metrology.current[0].in_phase_correction.sd_preloaded_offset < 128  &&  ADC_CURRENT_PENDING(PHASE_1_CURRENT_ADC_CHANNEL))
   \   00005A   B2908000.... CMP.W   #0x80, &working_data + 330
   \   000060   1D34         JGE     ??adc_interrupt_3
   \   000062   A2B20401     BIT.W   #0x4, &0x104
   \   000066   1A28         JNC     ??adc_interrupt_3
   1028              {
   1029                  adc_i_buffer[0] = ADC_CURRENT(PHASE_1_CURRENT_ADC_CHANNEL);
   \   000068   B2C040000401 BIC.W   #0x40, &0x104
   \   00006E   1F421201     MOV.W   &0x112, R15
   \   000072   8F10         SWPB    R15
   \   000074   8F11         SXT     R15
   \   000076   814F0200     MOV.W   R15, 0x2(SP)
   \   00007A   B2D040000401 BIS.W   #0x40, &0x104
   \   000080   1F421201     MOV.W   &0x112, R15
   \   000084   0F5F         RLA.W   R15
   \   000086   0F5F         RLA.W   R15
   \   000088   0F5F         RLA.W   R15
   \   00008A   814F0000     MOV.W   R15, 0(SP)
   \   00008E   824F....     MOV.W   R15, &adc_i_buffer
   \   000092   92410200.... MOV.W   0x2(SP), &adc_i_buffer + 2
   1030                  ADC_CURRENT_CLEAR(PHASE_1_CURRENT_ADC_CHANNEL);
   \   000098   A2C20401     BIC.W   #0x4, &0x104
   1031              }
   1032              #if NUM_PHASES >= 2
   1033              if (working_data.phases[1].metrology.current[0].in_phase_correction.sd_preloaded_offset < 128  &&  ADC_CURRENT_PENDING(PHASE_2_CURRENT_ADC_CHANNEL))
   1034              {
   1035                  adc_i_buffer[1] = ADC_CURRENT(PHASE_2_CURRENT_ADC_CHANNEL);
   1036                  ADC_CURRENT_CLEAR(PHASE_2_CURRENT_ADC_CHANNEL);
   1037              }
   1038              #endif
   1039              #if NUM_PHASES >= 3
   1040              if (working_data.phases[2].metrology.current[0].in_phase_correction.sd_preloaded_offset < 128  &&  ADC_CURRENT_PENDING(PHASE_3_CURRENT_ADC_CHANNEL))
   1041              {
   1042                  adc_i_buffer[2] = ADC_CURRENT(PHASE_3_CURRENT_ADC_CHANNEL);
   1043                  ADC_CURRENT_CLEAR(PHASE_3_CURRENT_ADC_CHANNEL);
   1044              }
   1045              #endif
   1046              #if NUM_PHASES >= 4
   1047              if (working_data.phases[3].metrology.current[0].in_phase_correction.sd_preloaded_offset < 128  &&  ADC_CURRENT_PENDING(PHASE_4_CURRENT_ADC_CHANNEL))
   1048              {
   1049                  adc_i_buffer[3] = ADC_CURRENT(PHASE_4_CURRENT_ADC_CHANNEL);
   1050                  ADC_CURRENT_CLEAR(PHASE_4_CURRENT_ADC_CHANNEL);
   1051              }
   1052              #endif
   1053              #if NUM_PHASES >= 5
   1054              if (working_data.phases[4].metrology.current[0].in_phase_correction.sd_preloaded_offset < 128  &&  ADC_CURRENT_PENDING(PHASE_5_CURRENT_ADC_CHANNEL))
   1055              {
   1056                  adc_i_buffer[4] = ADC_CURRENT(PHASE_5_CURRENT_ADC_CHANNEL);
   1057                  ADC_CURRENT_CLEAR(PHASE_5_CURRENT_ADC_CHANNEL);
   1058              }
   1059              #endif
   1060              #if NUM_PHASES >= 6
   1061              if (working_data.phases[5].metrology.current[0].in_phase_correction.sd_preloaded_offset < 128  &&  ADC_CURRENT_PENDING(PHASE_6_CURRENT_ADC_CHANNEL))
   1062              {
   1063                  adc_i_buffer[5] = ADC_CURRENT(PHASE_6_CURRENT_ADC_CHANNEL);
   1064                  ADC_CURRENT_CLEAR(PHASE_6_CURRENT_ADC_CHANNEL);
   1065              }
   1066              #endif
   1067              #if defined(NEUTRAL_MONITOR_SUPPORT)
   1068                  #if NUM_PHASES == 1
   1069              if (working_data.phases[0].metrology.current[1].in_phase_correction.sd_preloaded_offset < 128  &&  ADC_CURRENT_PENDING(NEUTRAL_CURRENT_ADC_CHANNEL))
   1070                  #else
   1071              if (working_data.neutral.metrology.in_phase_correction.sd_preloaded_offset < 128  &&  ADC_CURRENT_PENDING(NEUTRAL_CURRENT_ADC_CHANNEL))
   1072                  #endif
   1073              {
   1074                  adc_i_buffer[NUM_PHASES] = ADC_CURRENT(NEUTRAL_CURRENT_ADC_CHANNEL);
   1075                  ADC_CURRENT_CLEAR(NEUTRAL_CURRENT_ADC_CHANNEL);
   1076              }
   1077              #endif
   1078          #endif
   1079          
   1080          #if NUM_PHASES > 1  &&  defined(__MSP430_HAS_SD24_B3__)  &&  defined(__MSP430_HAS_ADC10_A__)
   1081              ADC10CTL0 &= ~ADC10ENC;
   1082              ADC10CTL0 |=  ADC10ENC;
   1083              DMA0CTL &= ~DMAIFG;
   1084          #endif
   1085          
   1086          #if defined (TEMPERATURE_SUPPORT) &&  !defined(__MSP430_HAS_ADC10_A__)
   1087              if (ADC_TEMPERATURE_PENDING(TEMPERATURE_ADC_CHANNEL))
   \                     ??adc_interrupt_3:
   \   00009C   A2B20601     BIT.W   #0x4, &0x106
   \   0000A0   0B28         JNC     ??adc_interrupt_4
   1088              {
   1089                  raw_temperature_from_adc += ((ADC_TEMPERATURE(TEMPERATURE_ADC_CHANNEL) - raw_temperature_from_adc) >> 3);
   \   0000A2   1F421401     MOV.W   &0x114, R15
   \   0000A6   1F82....     SUB.W   &raw_temperature_from_adc, R15
   \   0000AA   0F11         RRA.W   R15
   \   0000AC   0F11         RRA.W   R15
   \   0000AE   0F11         RRA.W   R15
   \   0000B0   825F....     ADD.W   R15, &raw_temperature_from_adc
   1090                  ADC_TEMPERATURE_CLEAR(TEMPERATURE_ADC_CHANNEL);
   \   0000B4   A2C20601     BIC.W   #0x4, &0x106
   1091              }
   1092          #endif    
   1093          
   1094              /* We have a complete set of samples. Process them. */
   1095              if (per_sample_dsp())
   \                     ??adc_interrupt_4:
   \   0000B8   B012....     CALL    #per_sample_dsp
   \   0000BC   0C93         CMP.W   #0x0, R12
   \   0000BE   0324         JEQ     ??adc_interrupt_5
   1096              {
   1097          #if defined(__MSP430__)
   1098                  /* The foreground may be conserving power (e.g. in limp mode), so we need to kick it. */
   1099                  _BIC_SR_IRQ(LPM0_bits);
   \   0000C0   B1C010000C00 BIC.W   #0x10, 0xc(SP)
   1100          #endif
   1101              }
   1102          
   1103          #if defined(ENERGY_PULSE_SUPPORT)  ||  defined(TOTAL_ENERGY_PULSE_SUPPORT)
   1104              per_sample_energy_pulse_processing();
   \                     ??adc_interrupt_5:
   \   0000C6   1C42....     MOV.W   &working_data + 20, R12
   \   0000CA   1D42....     MOV.W   &working_data + 22, R13
   \   0000CE   0E4D         MOV.W   R13, R14
   \   0000D0   3EE3         XOR.W   #0xffff, R14
   \   0000D2   0E5E         RLA.W   R14
   \   0000D4   0E7E         SUBC.W  R14, R14
   \   0000D6   825C....     ADD.W   R12, &working_data + 44
   \   0000DA   826D....     ADDC.W  R13, &working_data + 46
   \   0000DE   826E....     ADDC.W  R14, &working_data + 48
   \   0000E2   826E....     ADDC.W  R14, &working_data + 50
   \   0000E6   9292........ CMP.W   &operating_parameter + 8, &working_data + 50
   \   0000EC   1E38         JL      ??adc_interrupt_6
   \   0000EE   0E20         JNE     ??adc_interrupt_7
   \   0000F0   9292........ CMP.W   &operating_parameter + 6, &working_data + 48
   \   0000F6   1928         JNC     ??adc_interrupt_6
   \   0000F8   0920         JNE     ??adc_interrupt_7
   \   0000FA   9292........ CMP.W   &operating_parameter + 4, &working_data + 46
   \   000100   1428         JNC     ??adc_interrupt_6
   \   000102   0420         JNE     ??adc_interrupt_7
   \   000104   9292........ CMP.W   &operating_parameter + 2, &working_data + 44
   \   00010A   0F28         JNC     ??adc_interrupt_6
   \                     ??adc_interrupt_7:
   \   00010C   3F40....     MOV.W   #operating_parameter + 2, R15
   \   000110   B28F....     SUB.W   @R15+, &working_data + 44
   \   000114   B27F....     SUBC.W  @R15+, &working_data + 46
   \   000118   B27F....     SUBC.W  @R15+, &working_data + 48
   \   00011C   B27F....     SUBC.W  @R15+, &working_data + 50
   \   000120   D242........ MOV.B   &operating_parameter, &working_data + 52
   \   000126   B012....     CALL    #active_energy_pulse_start
   \                     ??adc_interrupt_6:
   \   00012A   C293....     CMP.B   #0x0, &working_data + 52
   \   00012E   0524         JEQ     ??adc_interrupt_8
   \   000130   F253....     ADD.B   #0xff, &working_data + 52
   \   000134   0220         JNE     ??adc_interrupt_8
   \   000136   B012....     CALL    #active_energy_pulse_end
   1105          #endif
   1106          
   1107          #if defined(__HAS_SD_ADC__)
   1108              /* There may be some current samples available, which we need to pick up */
   1109              if (ADC_CURRENT_PENDING(PHASE_1_CURRENT_ADC_CHANNEL))
   \                     ??adc_interrupt_8:
   \   00013A   A2B20401     BIT.W   #0x4, &0x104
   \   00013E   1A28         JNC     ??adc_interrupt_9
   1110              {
   1111                  adc_i_buffer[0] = ADC_CURRENT(PHASE_1_CURRENT_ADC_CHANNEL);
   \   000140   B2C040000401 BIC.W   #0x40, &0x104
   \   000146   1F421201     MOV.W   &0x112, R15
   \   00014A   8F10         SWPB    R15
   \   00014C   8F11         SXT     R15
   \   00014E   814F0200     MOV.W   R15, 0x2(SP)
   \   000152   B2D040000401 BIS.W   #0x40, &0x104
   \   000158   1F421201     MOV.W   &0x112, R15
   \   00015C   0F5F         RLA.W   R15
   \   00015E   0F5F         RLA.W   R15
   \   000160   0F5F         RLA.W   R15
   \   000162   814F0000     MOV.W   R15, 0(SP)
   \   000166   824F....     MOV.W   R15, &adc_i_buffer
   \   00016A   92410200.... MOV.W   0x2(SP), &adc_i_buffer + 2
   1112                  ADC_CURRENT_CLEAR(PHASE_1_CURRENT_ADC_CHANNEL);
   \   000170   A2C20401     BIC.W   #0x4, &0x104
   1113              }
   1114              #if NUM_PHASES >= 2
   1115              if (ADC_CURRENT_PENDING(PHASE_2_CURRENT_ADC_CHANNEL))
   1116              {
   1117                  adc_i_buffer[1] = ADC_CURRENT(PHASE_2_CURRENT_ADC_CHANNEL);
   1118                  ADC_CURRENT_CLEAR(PHASE_2_CURRENT_ADC_CHANNEL);
   1119              }
   1120              #endif
   1121              #if NUM_PHASES >= 3
   1122              if (ADC_CURRENT_PENDING(PHASE_3_CURRENT_ADC_CHANNEL))
   1123              {
   1124                  adc_i_buffer[2] = ADC_CURRENT(PHASE_3_CURRENT_ADC_CHANNEL);
   1125                  ADC_CURRENT_CLEAR(PHASE_3_CURRENT_ADC_CHANNEL);
   1126              }
   1127              #endif
   1128              #if NUM_PHASES >= 4
   1129              if (ADC_CURRENT_PENDING(PHASE_4_CURRENT_ADC_CHANNEL))
   1130              {
   1131                  adc_i_buffer[3] = ADC_CURRENT(PHASE_4_CURRENT_ADC_CHANNEL);
   1132                  ADC_CURRENT_CLEAR(PHASE_4_CURRENT_ADC_CHANNEL);
   1133              }
   1134              #endif
   1135              #if NUM_PHASES >= 5
   1136              if (ADC_CURRENT_PENDING(PHASE_5_CURRENT_ADC_CHANNEL))
   1137              {
   1138                  adc_i_buffer[4] = ADC_CURRENT(PHASE_5_CURRENT_ADC_CHANNEL);
   1139                  ADC_CURRENT_CLEAR(PHASE_5_CURRENT_ADC_CHANNEL);
   1140              }
   1141              #endif
   1142              #if NUM_PHASES >= 6
   1143              if (ADC_CURRENT_PENDING(PHASE_6_CURRENT_ADC_CHANNEL))
   1144              {
   1145                  adc_i_buffer[5] = ADC_CURRENT(PHASE_6_CURRENT_ADC_CHANNEL);
   1146                  ADC_CURRENT_CLEAR(PHASE_6_CURRENT_ADC_CHANNEL);
   1147              }
   1148              #endif
   1149              #if defined(NEUTRAL_MONITOR_SUPPORT)
   1150              if (ADC_CURRENT_PENDING(NEUTRAL_CURRENT_ADC_CHANNEL))
   1151              {
   1152                  adc_i_buffer[NUM_PHASES] = ADC_CURRENT(NEUTRAL_CURRENT_ADC_CHANNEL);
   1153                  ADC_CURRENT_CLEAR(NEUTRAL_CURRENT_ADC_CHANNEL);
   1154              }
   1155              #endif
   1156          #endif
   1157          
   1158              custom_adc_interrupt();
   1159              BACKGROUND_PROCESS_OFF ();
   \                     ??adc_interrupt_9:
   \   000174   B012....     CALL    #BACKGROUND_PROCESS_OFF
   1160          }
   \                     ??adc_interrupt_1:
   \   000178   2152         ADD.W   #0x4, SP
   \   00017A   3E41         POP.W   R14
   \   00017C   3F41         POP.W   R15
   \   00017E   3C41         POP.W   R12
   \   000180   3D41         POP.W   R13
   \   000182   0013         RETI
   \   000184                REQUIRE SD24CCTL2
   \   000184                REQUIRE SD24MEM2
   \   000184                REQUIRE SD24CCTL0
   \   000184                REQUIRE SD24MEM0
   \   000184                REQUIRE SD24CCTL1
   \   000184                REQUIRE SD24MEM1

   \                                 In  segment INTVEC, offset 0xe, root
   \                     `??adc_interrupt??INTVEC 14`:
   \   00000E   ....         DC16    adc_interrupt
   1161          
   1162          #if defined(__MSP430__)  &&  defined(__HAS_SD_ADC__)  &&  NUM_PHASES == 1  &&  defined(LIMP_MODE_SUPPORT)
   1163          /* Interrupt to trigger the SD16 ADC in limp mode */
   1164          #if defined(TIMER0_A0_VECTOR)
   1165          ISR(TIMER0_A0, limp_trigger_interrupt)
   1166          #else
   1167          ISR(TIMERA0, limp_trigger_interrupt)
   1168          #endif
   1169          {
   1170              /* Trigger the ADC to perform a single conversion from all inputs. */
   1171              sd_xxxx_reg(SD_PRE_, PHASE_1_VOLTAGE_ADC_CHANNEL) = 0;
   1172              sd_xxxx_reg(SD_PRE_, PHASE_1_CURRENT_ADC_CHANNEL) = 0;
   1173              #if defined(NEUTRAL_MONITOR_SUPPORT)
   1174              sd_xxxx_reg(SD_PRE_, NEUTRAL_CURRENT_ADC_CHANNEL) = 0;
   1175              #endif
   1176              SD_CCTL_TRIGGER |= SD_SC;
   1177          }
   1178          #endif
   1179          
   1180          #if defined(__MSP430__)  &&  defined(__MSP430_HAS_ADC10_A__)
   1181          /* Interrupt to handle the ADC10A in the 6xx family devices. */
   1182          ISR(ADC10, adc10_interrupt)
   1183          {
   1184              int16_t corrected;
   1185          
   1186              if (operating_mode == OPERATING_MODE_NORMAL)
   1187              {
   1188              #if defined(TEMPERATURE_SUPPORT)
   1189                  if ((ADC10MCTL0 & ADC10INCH_15) == ADC10INCH_10)
   1190                  {
   1191                      corrected = ADC10MEM0;
   1192                      raw_temperature_from_adc += corrected - (raw_temperature_from_adc >> 3);
   1193                  }
   1194              #endif
   1195              #if defined(VCC_MEASURE_SUPPORT)
   1196                  if ((ADC10MCTL0 & ADC10INCH_15) == ADC10INCH_11)
   1197                      vcc = ADC10MEM0;
   1198              #endif
   1199              }
   1200              /* Clear ADC10IFG by reading ADC10MEM0 */
   1201              ADC10IFG = 0x00;
   1202          }
   1203          #endif

   Maximum stack usage in bytes:

   CSTACK Function
   ------ --------
     16   adc_interrupt
       16   -> BACKGROUND_PROCESS_OFF
       16   -> BACKGROUND_PROCESS_ON
       16   -> active_energy_pulse_end
       16   -> active_energy_pulse_start
       16   -> per_sample_dsp
      4   adjust_v_history_index
      2   log_parameters
        2   -> dc_filter16_estimate
        2   -> dc_filter24_estimate
     32   per_sample_dsp
       30   -> AC_MODE_OFF
       30   -> AC_MODE_ON
       30   -> DC_MODE_OFF
       30   -> DC_MODE_ON
       30   -> ZERO_CROSS_OFF
       30   -> ZERO_CROSS_ON
       30   -> dc_filter16
       30   -> dc_filter16_estimate
       30   -> dc_filter16_no_update
       30   -> dc_filter24
       30   -> dc_filter24_estimate
       30   -> dc_filter24_no_update
       30   -> dds_lookup
       30   -> imul16
       30   -> log_parameters
       30   -> mac48_16
       30   -> mac64_16_24
       30   -> metrology_init_from_nv_data
       30   -> q1_15_mul
       30   -> sqac48_16
       30   -> sqac64_24


   Segment part sizes:

   Bytes  Function/Label
   -----  --------------
       2  ??adc_interrupt??INTVEC 14
       2  Last_I_sample
       2  SD24CCTL0
       2  SD24CCTL1
       2  SD24CCTL2
       2  SD24MEM0
       2  SD24MEM1
       2  SD24MEM2
       4  adc_i_buffer
     388  adc_interrupt
       2  adc_v_buffer
      60  adjust_v_history_index
       4  capacitance_scaling
     118  log_parameters
    1458  per_sample_dsp
       2  raw_temperature_from_adc
       4  resistance_scaling
       2  temperature_sequence

 
 2 024 bytes in segment CODE
    12 bytes in segment DATA16_AN
    20 bytes in segment DATA16_Z
     2 bytes in segment INTVEC
 
 2 024 bytes of CODE  memory
     0 bytes of CONST memory (+  2 bytes shared)
    20 bytes of DATA  memory (+ 12 bytes shared)

Errors: none
Warnings: none
