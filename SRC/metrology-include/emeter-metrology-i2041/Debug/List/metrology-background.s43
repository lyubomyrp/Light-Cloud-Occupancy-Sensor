///////////////////////////////////////////////////////////////////////////////
//                                                                            /
// IAR C/C++ Compiler V5.52.1.50724/W32 for MSP430      07/Jul/2014  17:16:20 /
// Copyright 1996-2013 IAR Systems AB.                                        /
//                                                                            /
//    __rt_version  =  3                                                      /
//    __double_size =  32                                                     /
//    __reg_r4      =  free                                                   /
//    __reg_r5      =  free                                                   /
//    __pic         =  no                                                     /
//    __core        =  430                                                    /
//    Source file   =  C:\Users\a0283112\Desktop\Submeter i2040               /
//                     8k_DC_THD_AUTO_OSR_IAR5.5\emeter-metrology\src\metrolo /
//                     gy-background.c                                        /
//    Command line  =  "C:\Users\a0283112\Desktop\Submeter i2040              /
//                     8k_DC_THD_AUTO_OSR_IAR5.5\emeter-metrology\src\metrolo /
//                     gy-background.c" -D __MSP430__ -lCN                    /
//                     "C:\Users\a0283112\Desktop\Submeter i2040              /
//                     8k_DC_THD_AUTO_OSR_IAR5.5\emeter-metrology\emeter-metr /
//                     ology-i2041\Debug\List\" -lA                           /
//                     "C:\Users\a0283112\Desktop\Submeter i2040              /
//                     8k_DC_THD_AUTO_OSR_IAR5.5\emeter-metrology\emeter-metr /
//                     ology-i2041\Debug\List\" -o                            /
//                     "C:\Users\a0283112\Desktop\Submeter i2040              /
//                     8k_DC_THD_AUTO_OSR_IAR5.5\emeter-metrology\emeter-metr /
//                     ology-i2041\Debug\Obj\" --debug -D__MSP430I2041__ -e   /
//                     --double=32 --dlib_config "C:\Program Files (x86)\IAR  /
//                     Systems\Embedded Workbench                             /
//                     6.5_0\430\LIB\DLIB\dl430fn.h" --library_module -I      /
//                     "C:\Users\a0283112\Desktop\Submeter i2040              /
//                     8k_DC_THD_AUTO_OSR_IAR5.5\emeter-metrology\emeter-metr /
//                     ology-i2041/../../emeter-toolkit/include\" -I          /
//                     "C:\Users\a0283112\Desktop\Submeter i2040              /
//                     8k_DC_THD_AUTO_OSR_IAR5.5\emeter-metrology\emeter-metr /
//                     ology-i2041/../include\" -I                            /
//                     "C:\Users\a0283112\Desktop\Submeter i2040              /
//                     8k_DC_THD_AUTO_OSR_IAR5.5\emeter-metrology\emeter-metr /
//                     ology-i2041\" -Ohs --multiplier=16s                    /
//    List file     =  C:\Users\a0283112\Desktop\Submeter i2040               /
//                     8k_DC_THD_AUTO_OSR_IAR5.5\emeter-metrology\emeter-metr /
//                     ology-i2041\Debug\List\metrology-background.s43        /
//                                                                            /
//                                                                            /
///////////////////////////////////////////////////////////////////////////////

        MODULE `metrology-background`

        RTMODEL "__SystemLibrary", "DLib"
        RTMODEL "__core", "430"
        RTMODEL "__dlib_full_locale_support", "0"
        RTMODEL "__double_size", "32"
        RTMODEL "__pic", "no"
        RTMODEL "__reg_r4", "free"
        RTMODEL "__reg_r5", "free"
        RTMODEL "__rt_version", "3"

        RSEG CSTACK:DATA:SORT:NOROOT(0)

        EXTERN ?ShiftRight32s_5
        EXTERN ?Epilogue8
        EXTERN ?DivMod8u
        EXTERN ?cstart_init_zero
        EXTERN ?longjmp_r4
        EXTERN ?longjmp_r5
        EXTERN ?setjmp_r4
        EXTERN ?setjmp_r5

        PUBWEAK `??adc_interrupt??INTVEC 14`
        PUBWEAK ?setjmp_save_r4
        PUBWEAK ?setjmp_save_r5
        PUBWEAK SD24CCTL0
        PUBWEAK SD24CCTL1
        PUBWEAK SD24CCTL2
        PUBWEAK SD24MEM0
        PUBWEAK SD24MEM1
        PUBWEAK SD24MEM2
        PUBLIC adc_interrupt
        FUNCTION adc_interrupt,021233H
        ARGFRAME CSTACK, 0, STACK
        LOCFRAME CSTACK, 16, STACK
        PUBLIC adjust_v_history_index
        FUNCTION adjust_v_history_index,0203H
        ARGFRAME CSTACK, 0, STACK
        LOCFRAME CSTACK, 4, STACK
        PUBLIC capacitance_scaling
        FUNCTION log_parameters,021203H
        ARGFRAME CSTACK, 0, STACK
        LOCFRAME CSTACK, 2, STACK
        FUNCTION per_sample_dsp,021203H
        ARGFRAME CSTACK, 0, STACK
        LOCFRAME CSTACK, 32, STACK
        PUBLIC raw_temperature_from_adc
        PUBLIC resistance_scaling
        PUBLIC temperature_sequence
        
          CFI Names cfiNames0
          CFI StackFrame CFA SP DATA
          CFI Resource PC:16, SP:16, SR:16, R4:16, R5:16, R6:16, R7:16, R8:16
          CFI Resource R9:16, R10:16, R11:16, R12:16, R13:16, R14:16, R15:16
          CFI EndNames cfiNames0
        
          CFI Common cfiCommon0 Using cfiNames0
          CFI CodeAlign 2
          CFI DataAlign 2
          CFI ReturnAddress PC CODE
          CFI CFA SP+2
          CFI PC Frame(CFA, -2)
          CFI SR Undefined
          CFI R4 SameValue
          CFI R5 SameValue
          CFI R6 SameValue
          CFI R7 SameValue
          CFI R8 SameValue
          CFI R9 SameValue
          CFI R10 SameValue
          CFI R11 SameValue
          CFI R12 Undefined
          CFI R13 Undefined
          CFI R14 Undefined
          CFI R15 Undefined
          CFI EndCommon cfiCommon0
        
        
          CFI Common cfiCommon1 Using cfiNames0
          CFI CodeAlign 2
          CFI DataAlign 2
          CFI ReturnAddress PC CODE
          CFI CFA SP+4
          CFI PC Frame(CFA, -2)
          CFI SR Frame(CFA, -4)
          CFI R4 SameValue
          CFI R5 SameValue
          CFI R6 SameValue
          CFI R7 SameValue
          CFI R8 SameValue
          CFI R9 SameValue
          CFI R10 SameValue
          CFI R11 SameValue
          CFI R12 SameValue
          CFI R13 SameValue
          CFI R14 SameValue
          CFI R15 SameValue
          CFI EndCommon cfiCommon1
        
adc_interrupt       SYMBOL "adc_interrupt"
`??adc_interrupt??INTVEC 14` SYMBOL "??INTVEC 14", adc_interrupt

        EXTERN BACKGROUND_PROCESS_ON
        FUNCTION BACKGROUND_PROCESS_ON,0202H
        EXTERN working_data
        EXTERN operating_parameter
        EXTERN active_energy_pulse_start
        FUNCTION active_energy_pulse_start,0202H
        EXTERN active_energy_pulse_end
        FUNCTION active_energy_pulse_end,0202H
        EXTERN BACKGROUND_PROCESS_OFF
        FUNCTION BACKGROUND_PROCESS_OFF,0202H
        EXTERN dc_filter16_no_update
        FUNCTION dc_filter16_no_update,0202H
        EXTERN dc_filter16
        FUNCTION dc_filter16,0202H
        EXTERN sqac48_16
        FUNCTION sqac48_16,0202H
        EXTERN operating_mode
        EXTERN dds_lookup
        FUNCTION dds_lookup,0202H
        EXTERN mac48_16
        FUNCTION mac48_16,0202H
        EXTERN imul16
        FUNCTION imul16,0202H
        EXTERN dc_filter24_no_update
        FUNCTION dc_filter24_no_update,0202H
        EXTERN dc_filter24
        FUNCTION dc_filter24,0202H
        EXTERN sqac64_24
        FUNCTION sqac64_24,0202H
        EXTERN mac64_16_24
        FUNCTION mac64_16_24,0202H
        EXTERN q1_15_mul
        FUNCTION q1_15_mul,0202H
        EXTERN ZERO_CROSS_ON
        FUNCTION ZERO_CROSS_ON,0202H
        EXTERN dc_filter24_estimate
        FUNCTION dc_filter24_estimate,0202H
        EXTERN dc_filter16_estimate
        FUNCTION dc_filter16_estimate,0202H
        EXTERN ZERO_CROSS_OFF
        FUNCTION ZERO_CROSS_OFF,0202H
        EXTERN metrology_init_from_nv_data
        FUNCTION metrology_init_from_nv_data,0202H
        EXTERN DC_MODE_OFF
        FUNCTION DC_MODE_OFF,0202H
        EXTERN AC_MODE_ON
        FUNCTION AC_MODE_ON,0202H
        EXTERN nv_parms
        EXTERN AC_MODE_OFF
        FUNCTION AC_MODE_OFF,0202H
        EXTERN DC_MODE_ON
        FUNCTION DC_MODE_ON,0202H

// C:\Users\a0283112\Desktop\Submeter i2040 8k_DC_THD_AUTO_OSR_IAR5.5\emeter-metrology\src\metrology-background.c
//    1 /*******************************************************************************
//    2  *  metrology-background.c -
//    3  *
//    4  *  Copyright (C) 2011 Texas Instruments Incorporated - http://www.ti.com/ 
//    5  * 
//    6  *  Redistribution and use in source and binary forms, with or without 
//    7  *  modification, are permitted provided that the following conditions 
//    8  *  are met:
//    9  *
//   10  *    Redistributions of source code must retain the above copyright 
//   11  *    notice, this list of conditions and the following disclaimer.
//   12  *
//   13  *    Redistributions in binary form must reproduce the above copyright
//   14  *    notice, this list of conditions and the following disclaimer in the 
//   15  *    documentation and/or other materials provided with the   
//   16  *    distribution.
//   17  *
//   18  *    Neither the name of Texas Instruments Incorporated nor the names of
//   19  *    its contributors may be used to endorse or promote products derived
//   20  *    from this software without specific prior written permission.
//   21  *
//   22  *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
//   23  *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
//   24  *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
//   25  *  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT 
//   26  *  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, 
//   27  *  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
//   28  *  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
//   29  *  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
//   30  *  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
//   31  *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
//   32  *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//   33  *
//   34  ******************************************************************************/
//   35 
//   36 /*! \file emeter-metrology.h */
//   37 
//   38 #include <inttypes.h>
//   39 #include <stdlib.h>
//   40 #if !defined(__MSP430__)
//   41 #include <stdio.h>
//   42 #include <fcntl.h>
//   43 #include <unistd.h>
//   44 #endif
//   45 #if defined(__GNUC__)
//   46 #include <signal.h>
//   47 #endif
//   48 
//   49 #include <emeter-toolkit.h>

        ASEGN DATA16_AN:DATA:NOROOT,0102H
// unsigned short volatile SD24CCTL0
SD24CCTL0:
        DS8 2

        ASEGN DATA16_AN:DATA:NOROOT,0104H
// unsigned short volatile SD24CCTL1
SD24CCTL1:
        DS8 2

        ASEGN DATA16_AN:DATA:NOROOT,0106H
// unsigned short volatile SD24CCTL2
SD24CCTL2:
        DS8 2

        ASEGN DATA16_AN:DATA:NOROOT,0110H
// unsigned short volatile SD24MEM0
SD24MEM0:
        DS8 2

        ASEGN DATA16_AN:DATA:NOROOT,0112H
// unsigned short volatile SD24MEM1
SD24MEM1:
        DS8 2

        ASEGN DATA16_AN:DATA:NOROOT,0114H
// unsigned short volatile SD24MEM2
SD24MEM2:
        DS8 2
//   50 
//   51 #include "emeter-metrology.h"
//   52 #include "metrology-structs.h"
//   53 #include "metrology-nv-structs.h"
//   54 
//   55 #if !defined(NULL)
//   56 #define NULL    (void *) 0
//   57 #endif
//   58 extern const struct operating_parameter_s operating_parameter;
//   59 
//   60 //int16_t samples_per_second;
//   61 
//   62 #if defined(WIRE_RESISTANCE_COMPENSATE)

        RSEG DATA16_Z:DATA:SORT:NOROOT(1)
        REQUIRE ?cstart_init_zero
//   63 uint32_t resistance_scaling;
resistance_scaling:
        DS8 4
//   64 #endif
//   65 
//   66 #if defined(CAPACITOR_COMPENSATE_ON)

        RSEG DATA16_Z:DATA:SORT:NOROOT(1)
        REQUIRE ?cstart_init_zero
//   67 uint32_t capacitance_scaling;
capacitance_scaling:
        DS8 4
//   68 #endif
//   69 
//   70 #if defined(TEMPERATURE_SUPPORT)

        RSEG DATA16_Z:DATA:SORT:NOROOT(1)
        REQUIRE ?cstart_init_zero
//   71 int16_t raw_temperature_from_adc;
raw_temperature_from_adc:
        DS8 2

        RSEG DATA16_Z:DATA:SORT:NOROOT(1)
        REQUIRE ?cstart_init_zero
//   72 int temperature_sequence = 0;
temperature_sequence:
        DS8 2
//   73     #if defined(TRNG_SUPPORT)
//   74 uint16_t random_value;
//   75 int new_random_value = FALSE;
//   76 uint16_t rolling_random;
//   77 int rand_bits = 0;
//   78     #endif
//   79 #endif
//   80 
//   81 #if defined(POWER_DOWN_SUPPORT)  &&  defined(POWER_UP_BY_SUPPLY_SENSING)
//   82 int8_t power_down_debounce;
//   83 #endif
//   84 
//   85 #if NUM_PHASES > 1  &&  defined(__MSP430_HAS_SD24_B3__)  &&  defined(__MSP430_HAS_ADC10_A__)
//   86 /* This is a 3-phase meter, using the ADC10A for the voltage channels. These channels must be
//   87    read through DMA. */
//   88 int16_t dma_adc_buffer[6];
//   89 //int16_t dma_adc_buffer[NUM_PHASES];
//   90 #endif
//   91 
//   92 #if defined(TRNG_SUPPORT)
//   93 int trng(uint16_t *val)
//   94 {
//   95     if (!new_random_value)
//   96         return -1;
//   97     /* We now know the random value has been refreshed, so we can pick up a new one. */
//   98     *val = random_value;
//   99     /* There is a race here, where we may loose a generated number, but there will be more
//  100        along fairly soon, so its fairly harmless if we loose one. */
//  101     new_random_value = FALSE;
//  102     return 0;
//  103 }
//  104 
//  105 uint16_t trng_wait(void)
//  106 {
//  107     uint16_t val;
//  108 
//  109     while (!new_random_value)
//  110         __no_operation();
//  111     /* We now know the random value has been refreshed, so we can pick up a new one. */
//  112     val = random_value;
//  113     /* There is a race here, where we may loose a generated number, but there will be more
//  114        along fairly soon, so its fairly harmless if we loose one. */
//  115     new_random_value = FALSE;
//  116     return val;
//  117 }
//  118 #endif
//  119 
//  120 #if NUM_PHASES == 1

        RSEG CODE:CODE:REORDER:NOROOT(1)
//  121 static void __inline__ log_parameters(void)
log_parameters:
          CFI Block cfiBlock0 Using cfiCommon0
          CFI Function log_parameters
//  122 #else
//  123 static void __inline__ log_parameters(struct phase_parms_s *phase, int ph)
//  124 #endif
//  125 {
//  126 #if NUM_PHASES == 1  &&  defined(NEUTRAL_MONITOR_SUPPORT)
//  127     int ch;
//  128     static const uint16_t current_overrange_masks[PER_PHASE_CURRENT_CHANNELS] = {PHASE_STATUS_I_OVERRANGE, PHASE_STATUS_I_NEUTRAL_OVERRANGE};
//  129 #else
//  130     static const uint16_t current_overrange_masks[PER_PHASE_CURRENT_CHANNELS] = {PHASE_STATUS_I_OVERRANGE};
//  131 #endif
//  132 
//  133     /* Take a snapshot of various values for logging purposes; tell the
//  134        foreground to deal with them; and clear the working values ready
//  135        for the next analysis period. */
//  136     if (phase->metrology.V_endstops <= 0)
        FUNCALL log_parameters, dc_filter16_estimate
        LOCFRAME CSTACK, 2, STACK
        FUNCALL log_parameters, dc_filter24_estimate
        LOCFRAME CSTACK, 2, STACK
        CMP.B   #0x1, &working_data + 358
        JGE     ??log_parameters_0
//  137         phase->status |= PHASE_STATUS_V_OVERRANGE;
        BIS.W   #0x10, &working_data + 360
        JMP     ??log_parameters_1
//  138     else
//  139         phase->status &= ~PHASE_STATUS_V_OVERRANGE;
??log_parameters_0:
        BIC.W   #0x10, &working_data + 360
//  140     phase->metrology.V_endstops = ENDSTOP_HITS_FOR_OVERLOAD;
??log_parameters_1:
        MOV.B   #0x14, &working_data + 358
//  141     /* Snapshot the DC estimate here, near a zero crossing */
//  142 //    phase->metrology.V_dc_estimate_logged = ((dc_filter_voltage_estimate(phase->metrology.V_dc_estimate[normal_limp])));
//  143     phase->metrology.V_dc_estimate_logged = (phase->metrology.V_dc_estimate_temp + dc_filter_voltage_estimate(phase->metrology.V_dc_estimate[normal_limp]))>> 1; 
        MOV.W   #working_data + 78, R12
        CALL    #dc_filter16_estimate
        ADD.W   &working_data + 86, R12
        ADDC.W  &working_data + 88, R13
        RRA.W   R13
        RRC.W   R12
        MOV.W   R12, &working_data + 82
        MOV.W   R13, &working_data + 84
//  144 #if NUM_PHASES > 1  &&  defined(FUNDAMENTAL_VRMS_SUPPORT)
//  145     /* Point ph at the previous phase, for differencing */
//  146     if (--ph < 0)
//  147         ph = 2;
//  148     phase->readings.phase_to_phase_angle = (phase->metrology.pure_phase >> 16) - (working_data.phases[ph].metrology.pure_phase >> 16);
//  149 #endif
//  150 
//  151 #if NUM_PHASES == 1  &&  defined(NEUTRAL_MONITOR_SUPPORT)
//  152     for (ch = 0;  ch < 2;  ch++)
//  153 #endif
//  154     {
//  155         if (phase->metrology.current[ch].I_endstops <= 0)
        CMP.B   #0x1, &working_data + 346
        JGE     ??log_parameters_2
//  156             phase->status |= current_overrange_masks[ch];
        BIS.W   #0x20, &working_data + 360
        JMP     ??log_parameters_3
//  157         else
//  158             phase->status &= ~current_overrange_masks[ch];
??log_parameters_2:
        BIC.W   #0x20, &working_data + 360
//  159         phase->metrology.current[ch].I_endstops = ENDSTOP_HITS_FOR_OVERLOAD;
??log_parameters_3:
        MOV.B   #0x14, &working_data + 346
//  160         /* Snapshot the DC estimate here, near a zero crossing */
//  161 //        phase->metrology.current[ch].I_dc_estimate_logged = dc_filter_current_estimate(phase->metrology.current[ch].I_dc_estimate[normal_limp]);
//  162         phase->metrology.current[ch].I_dc_estimate_logged = (phase->metrology.current[ch].I_dc_estimate_temp  + dc_filter_current_estimate (phase->metrology.current[ch].I_dc_estimate[normal_limp])) >> 1;
        MOV.W   #working_data + 230, R12
        CALL    #dc_filter24_estimate
        ADD.W   &working_data + 240, R12
        ADDC.W  &working_data + 242, R13
        RRA.W   R13
        RRC.W   R12
        MOV.W   R12, &working_data + 236
        MOV.W   R13, &working_data + 238
//  163     }
//  164 
//  165     /* Tell the foreground there are things to process, and swap the dot product sets. */
//  166     phase->metrology.dp_set ^= 1;
        XOR.B   #0x1, &working_data + 359
//  167     phase->status |= PHASE_STATUS_NEW_LOG;
        BIS.W   #0x1, &working_data + 360
//  168 }
        RET
          CFI EndBlock cfiBlock0
//  169 
//  170 #if NUM_PHASES > 1  &&  defined(NEUTRAL_MONITOR_SUPPORT)  &&  defined(IRMS_SUPPORT)
//  171 /* This routine logs neutral lead information for poly-phase meters. It is
//  172    not used for single phase meters with neutral monitoring. */
//  173 static void __inline__ log_neutral_parameters(void)
//  174 {
//  175     if (working_data.neutral.metrology.I_endstops <= 0)
//  176         working_data.neutral.status |= PHASE_STATUS_I_OVERRANGE;
//  177     else
//  178         working_data.neutral.status &= ~PHASE_STATUS_I_OVERRANGE;
//  179     working_data.neutral.metrology.I_endstops = ENDSTOP_HITS_FOR_OVERLOAD;
//  180     working_data.neutral.metrology.I_dc_estimate_logged = dc_filter_current_estimate(working_data.neutral.metrology.I_dc_estimate[normal_limp]);
//  181     /* Tell the foreground there are things to process, and swap the dot product sets. */
//  182     working_data.neutral.metrology.dp_set ^= 1;
//  183     working_data.neutral.status |= PHASE_STATUS_NEW_LOG;
//  184 }
//  185 #endif
//  186 
//  187 #if defined(__HAS_SD_ADC__)
//  188     #if defined(VOLTAGE_SIGNAL_IS_COMMON)
//  189 #define VOLTAGE_CHANNELS 1
//  190     #else
//  191 #define VOLTAGE_CHANNELS NUM_PHASES
//  192     #endif
//  193     #if defined(NEUTRAL_MONITOR_SUPPORT)
//  194 #define CURRENT_CHANNELS (NUM_PHASES + 1)
//  195     #else
//  196 #define CURRENT_CHANNELS NUM_PHASES
//  197     #endif
//  198 #endif
//  199 
//  200 /* These are the buffers for one set of samples */

        RSEG DATA16_Z:DATA:SORT:NOROOT(1)
        REQUIRE ?cstart_init_zero
//  201 static voltage_sample_t adc_v_buffer[VOLTAGE_CHANNELS];
adc_v_buffer:
        DS8 2

        RSEG DATA16_Z:DATA:SORT:NOROOT(1)
        REQUIRE ?cstart_init_zero
//  202 static current_sample_t adc_i_buffer[CURRENT_CHANNELS];
adc_i_buffer:
        DS8 4
//  203 

        RSEG CODE:CODE:REORDER:NOROOT(1)
//  204 int8_t adjust_v_history_index (int8_t index)
adjust_v_history_index:
          CFI Block cfiBlock1 Using cfiCommon0
          CFI Function adjust_v_history_index
//  205 {
        PUSH.W  R10
          CFI R10 Frame(CFA, -4)
          CFI CFA SP+4
        MOV.B   R12, R10
//  206     if (index >= 0)
        CMP.B   #0x0, R12
        JL      ??adjust_v_history_index_0
        CMP.B   #0x30, R12
        JNC     ??adjust_v_history_index_1
        MOV.B   #0x30, R14
        CALL    #?DivMod8u
        RLA.B   R12
        RLA.B   R12
        RLA.B   R12
        RLA.B   R12
        MOV.B   R12, R14
        RLA.B   R12
        RLA.B   R12
        ADD.B   R12, R14
        RLA.B   R12
        ADD.B   R14, R12
        ADD.B   R12, R10
        JMP     ??adjust_v_history_index_1
//  207     {
//  208         while (index >= (sizeof(phase->metrology.V_history)/sizeof(phase->metrology.V_history[0])))
//  209         {
//  210             index -= (sizeof(phase->metrology.V_history)/sizeof(phase->metrology.V_history[0]));
//  211         }
//  212     }
//  213     else
//  214     {
//  215         while (index < 0)
//  216         {
//  217             index += (sizeof(phase->metrology.V_history)/sizeof(phase->metrology.V_history[0]));
??adjust_v_history_index_0:
        ADD.B   #0x30, R10
//  218         }
        CMP.B   #0x0, R10
        JL      ??adjust_v_history_index_0
//  219     }
//  220     return index;
??adjust_v_history_index_1:
        MOV.B   R10, R12
        POP.W   R10
          CFI R10 SameValue
          CFI CFA SP+2
        RET
          CFI EndBlock cfiBlock1
//  221 }
//  222 

        RSEG CODE:CODE:REORDER:NOROOT(1)
//  223 static __inline__ int per_sample_dsp(void)
per_sample_dsp:
          CFI Block cfiBlock2 Using cfiCommon0
          CFI Function per_sample_dsp
//  224 {
        FUNCALL per_sample_dsp, dc_filter16_no_update
        LOCFRAME CSTACK, 30, STACK
        FUNCALL per_sample_dsp, dc_filter16
        LOCFRAME CSTACK, 30, STACK
        FUNCALL per_sample_dsp, sqac48_16
        LOCFRAME CSTACK, 30, STACK
        FUNCALL per_sample_dsp, dds_lookup
        LOCFRAME CSTACK, 30, STACK
        FUNCALL per_sample_dsp, mac48_16
        LOCFRAME CSTACK, 30, STACK
        FUNCALL per_sample_dsp, dds_lookup
        LOCFRAME CSTACK, 30, STACK
        FUNCALL per_sample_dsp, imul16
        LOCFRAME CSTACK, 30, STACK
        FUNCALL per_sample_dsp, dc_filter24_no_update
        LOCFRAME CSTACK, 30, STACK
        FUNCALL per_sample_dsp, dc_filter24
        LOCFRAME CSTACK, 30, STACK
        FUNCALL per_sample_dsp, sqac64_24
        LOCFRAME CSTACK, 30, STACK
        FUNCALL per_sample_dsp, mac64_16_24
        LOCFRAME CSTACK, 30, STACK
        FUNCALL per_sample_dsp, q1_15_mul
        LOCFRAME CSTACK, 30, STACK
        FUNCALL per_sample_dsp, mac64_16_24
        LOCFRAME CSTACK, 30, STACK
        FUNCALL per_sample_dsp, mac64_16_24
        LOCFRAME CSTACK, 30, STACK
        FUNCALL per_sample_dsp, mac64_16_24
        LOCFRAME CSTACK, 30, STACK
        FUNCALL per_sample_dsp, ZERO_CROSS_ON
        LOCFRAME CSTACK, 30, STACK
        FUNCALL per_sample_dsp, dc_filter24_estimate
        LOCFRAME CSTACK, 30, STACK
        FUNCALL per_sample_dsp, dc_filter16_estimate
        LOCFRAME CSTACK, 30, STACK
        FUNCALL per_sample_dsp, ZERO_CROSS_OFF
        LOCFRAME CSTACK, 30, STACK
        FUNCALL per_sample_dsp, log_parameters
        LOCFRAME CSTACK, 30, STACK
        FUNCALL per_sample_dsp, metrology_init_from_nv_data
        LOCFRAME CSTACK, 30, STACK
        FUNCALL per_sample_dsp, DC_MODE_OFF
        LOCFRAME CSTACK, 30, STACK
        FUNCALL per_sample_dsp, AC_MODE_ON
        LOCFRAME CSTACK, 30, STACK
        FUNCALL per_sample_dsp, log_parameters
        LOCFRAME CSTACK, 30, STACK
        FUNCALL per_sample_dsp, metrology_init_from_nv_data
        LOCFRAME CSTACK, 30, STACK
        FUNCALL per_sample_dsp, AC_MODE_OFF
        LOCFRAME CSTACK, 30, STACK
        FUNCALL per_sample_dsp, DC_MODE_ON
        LOCFRAME CSTACK, 30, STACK
        PUSH.W  R10
          CFI R10 Frame(CFA, -4)
          CFI CFA SP+4
        PUSH.W  R11
          CFI R11 Frame(CFA, -6)
          CFI CFA SP+6
        PUSH.W  R8
          CFI R8 Frame(CFA, -8)
          CFI CFA SP+8
        PUSH.W  R9
          CFI R9 Frame(CFA, -10)
          CFI CFA SP+10
        PUSH.W  R6
          CFI R6 Frame(CFA, -12)
          CFI CFA SP+12
        PUSH.W  R7
          CFI R7 Frame(CFA, -14)
          CFI CFA SP+14
        PUSH.W  R4
          CFI R4 Frame(CFA, -16)
          CFI CFA SP+16
        PUSH.W  R5
          CFI R5 Frame(CFA, -18)
          CFI CFA SP+18
        SUB.W   #0xc, SP
          CFI CFA SP+30
//  225     int kick;
//  226     voltage_sample_t V_sample;
//  227     voltage_sample_t V_corrected;
//  228 #if defined(REACTIVE_POWER_BY_QUADRATURE_SUPPORT)
//  229     voltage_sample_t V_quad_corrected;
//  230 #endif
//  231 #if defined(FUNDAMENTAL_POWER_SUPPORT)
//  232     voltage_sample_t V_pure;
//  233     voltage_sample_t V_quad_pure;
//  234     int32_t summy;
//  235 #endif
//  236     current_sample_t I_sample[PER_PHASE_CURRENT_CHANNELS];
//  237     current_sample_t I_corrected;
//  238 
//  239 #if defined (WIRE_RESISTANCE_COMPENSATE)
//  240     // ----- resistance compensation
//  241     static int16_t Last_I_sample;
//  242     // -----
//  243 #endif
//  244     
//  245 #if defined(RESIDUAL_IRMS_SUPPORT)
//  246     int32_t I_residue;
//  247 #endif
//  248     
//  249 #if NUM_PHASES > 1
//  250     struct phase_parms_s *phase;
//  251     int ph;
//  252 #endif
//  253 #if NUM_PHASES == 1  &&  defined(NEUTRAL_MONITOR_SUPPORT)
//  254     static const uint16_t current_pos_masks[PER_PHASE_CURRENT_CHANNELS] = {PHASE_STATUS_I_POS, PHASE_STATUS_I_NEUTRAL_POS};
//  255     int ch;
//  256 #else
//  257 //    static const uint16_t current_pos_masks[PER_PHASE_CURRENT_CHANNELS] = {PHASE_STATUS_I_POS};
//  258 #endif
//  259     int k;
//  260 #if defined(MAINS_FREQUENCY_SUPPORT)
//  261     int x;
//  262     int y;
//  263     int z;
//  264 #endif
//  265     struct phase_dot_prod_set_s *phase_dot_products;
//  266     struct current_sensor_dot_prod_set_s *sensor_dot_products;
//  267 #if NUM_PHASES > 1  &&  defined(NEUTRAL_MONITOR_SUPPORT)
//  268     struct neutral_dot_prod_set_s *neutral_dot_products;
//  269 #endif
//  270     int dp;
//  271     /* Filter away the DC bias.
//  272     
//  273        Do the phase lag compensation. Use a simple FIR approach,
//  274        and absorb the non-unity gain of the filter in the overall
//  275        current/power scaling later on. This is OK for the small
//  276        phase shifts we expect to get. It would cause dynamic
//  277        range problems for larger shifts. Note the some of this
//  278        phase shift is due to the operation of the ADC itself. It
//  279        performs sequential conversions of its 8 inputs, so there is
//  280        some time delay between sampling of the various sensors.
//  281     
//  282        Accumulate power for each of the channels. These will
//  283        be divided by the number of samples at the end of the
//  284        measurement cycles, resulting in an average power
//  285        value for each source.
//  286 
//  287        If RMS voltage and/or current readings are required, calculate the
//  288        dot products needed to evaluate these. */
//  289 
//  290     kick = FALSE;
        MOV.W   #0x0, R7
//  291 #if defined(RESIDUAL_IRMS_SUPPORT)
//  292     I_residue = 0;
//  293 #endif
//  294 
//  295 #if NUM_PHASES > 1
//  296     for (ph = 0, phase = working_data.phases;  ph < NUM_PHASES;  ph++, phase++)
//  297 #endif
//  298     {
//  299         dp = phase->metrology.dp_set ^ 1;
        MOV.B   &working_data + 359, R8
        SXT     R8
        XOR.W   #0x1, R8
//  300         phase_dot_products = &phase->metrology.dot_prod[dp];
        MOV.W   R8, R6
        RLA.W   R6
        MOV.W   R6, R15
        RLA.W   R6
        ADD.W   R6, R15
        RLA.W   R6
        ADD.W   R15, R6
        ADD.W   #working_data + 202, R6
//  301 
//  302 #if defined(VOLTAGE_SIGNAL_IS_COMMON)
//  303         V_sample = adc_v_buffer[0];
//  304 #else
//  305         V_sample = adc_v_buffer[ph];
        MOV.W   &adc_v_buffer, R10
//  306 #endif
//  307         if ((V_sample >= V_ADC_MAX  ||  V_sample <= V_ADC_MIN)  &&  phase->metrology.V_endstops)
        MOV.W   R10, R15
        ADD.W   #0x7917, R15
        CMP.W   #0xf22f, R15
        JNC     ??per_sample_dsp_9
        CMP.B   #0x0, &working_data + 358
        JEQ     ??per_sample_dsp_9
//  308             phase->metrology.V_endstops--;
        ADD.B   #0xff, &working_data + 358
//  309 
//  310         if (phase->status & PHASE_STATUS_DC_MODE)
??per_sample_dsp_9:
        CMP.W   #0x0, &working_data + 360
        MOV.W   R10, R13
        MOV.W   #working_data + 78, R12
        JGE     ??per_sample_dsp_10
//  311         {
//  312             V_sample = dc_filter_voltage_no_update(phase->metrology.V_dc_estimate[normal_limp], V_sample);      // d.c. mode
        CALL    #dc_filter16_no_update
        JMP     ??per_sample_dsp_11
//  313         }
//  314         else
//  315         {
//  316             V_sample = dc_filter_voltage(phase->metrology.V_dc_estimate[normal_limp], V_sample);    // a.c. mode
??per_sample_dsp_10:
        CALL    #dc_filter16
??per_sample_dsp_11:
        MOV.W   R12, R10
//  317         }
//  318         
//  319         
//  320 #if defined (WIRE_RESISTANCE_COMPENSATE)
//  321         // ----- resistance compensation
//  322         V_sample += ((Last_I_sample * resistance_scaling) >> 16);
        MOV.W   &??Last_I_sample, R4
        MOV.W   R4, R5
        XOR.W   #0xffff, R5
        RLA.W   R5
        SUBC.W  R5, R5
        MOV.W   &resistance_scaling, R14
        MOV.W   &resistance_scaling + 2, R15
        PUSH.W  SR
          CFI CFA SP+32
        DINT
        NOP
        MOV.W   R4, &0x130
        MOV.W   R14, &0x138
        MOV.W   R4, &0x134
        MOV.W   &0x13a, R4
        MOV.W   &0x13c, &0x13a
        MOV.W   R15, &0x138
        MOV.W   R5, &0x134
        MOV.W   R14, &0x138
        MOV.W   &0x13a, R5
        POP.W   SR
          CFI CFA SP+30
        ADD.W   R5, R10
//  323         // ----- end of block
//  324 #endif
//  325 
//  326 #if defined(VRMS_SUPPORT)  ||  defined(POWER_FACTOR_SUPPORT)
//  327     #if defined(SAG_SWELL_SUPPORT)
//  328         sqac_voltage(phase->metrology.V_sq_cycle, V_sample);
//  329     #else
//  330         sqac_voltage(phase_dot_products->V_sq, V_sample);
        MOV.W   R10, R13
        MOV.W   R6, R12
        CALL    #sqac48_16
//  331     #endif
//  332 #endif
//  333         ++phase_dot_products->sample_count;
        ADD.W   #0x1, 0xc(R6)
//  334 
//  335         /* We need to save the history of the voltage signal if we are performing phase correction, and/or
//  336            measuring the quadrature shifted power (to obtain an accurate measure of one form of the reactive power). */
//  337         phase->metrology.V_history[(int) phase->metrology.V_history_index] = V_sample;
        MOV.W   #working_data + 186, R9
        MOV.B   @R9, R15
        SXT     R15
        RLA.W   R15
        MOV.W   R10, working_data + 90(R15)
//  338 
//  339         if (operating_mode == OPERATING_MODE_NORMAL)
        CMP.B   #0x0, &operating_mode
        JNE     ??per_sample_dsp_12
        MOV.B   @R9, R12
        SUB.B   &working_data + 328, R12
        MOV.B   R12, R11
//  340         {
//  341             /* Perform bulk delay (i.e. integer sample times) of the voltage signal. */
//  342              V_corrected = phase->metrology.V_history[adjust_v_history_index (phase->metrology.V_history_index - phase->metrology.current[0].in_phase_correction.step)];
        CMP.B   #0x0, R12
        JL      ??per_sample_dsp_0
        CMP.B   #0x30, R12
        JNC     ??per_sample_dsp_13
        MOV.B   #0x30, R14
        CALL    #?DivMod8u
        RLA.B   R12
        RLA.B   R12
        RLA.B   R12
        RLA.B   R12
        MOV.B   R12, R14
        RLA.B   R12
        RLA.B   R12
        ADD.B   R12, R14
        RLA.B   R12
        ADD.B   R14, R12
        ADD.B   R12, R11
        JMP     ??per_sample_dsp_13
??per_sample_dsp_0:
        ADD.B   #0x30, R11
        CMP.B   #0x0, R11
        JL      ??per_sample_dsp_0
??per_sample_dsp_13:
        SXT     R11
        RLA.W   R11
        MOV.W   working_data + 90(R11), R11
//  343 #if defined(FUNDAMENTAL_POWER_SUPPORT)
//  344             /* The dot product of the raw and the pure voltage signals allows us to precisely estimate
//  345                the amplitude of the fundamental component of the mains voltage waveform. This is needed,
//  346                during the foreground processing, to correctly scale the answer from the dot product of the
//  347                full scale pure voltage waveform and the current signal.
//  348                The answer from this estimator will only be correct once the pure waveform is properly phase
//  349                locked. */
//  350             V_pure = dds_lookup(phase->metrology.pure_phase);
        MOV.W   &working_data + 188, R12
        MOV.W   &working_data + 190, R13
        CALL    #dds_lookup
        MOV.W   R12, 0x6(SP)
//  351             mac_voltage(phase_dot_products->V_fundamental, V_corrected, V_pure);
        MOV.W   R12, R14
        MOV.W   R11, R13
        MOV.W   R6, R12
        ADD.W   #0x6, R12
        CALL    #mac48_16
//  352 
//  353             /* If we look for maximum correlation when the real and synthetic waveforms are in sync:
//  354                     - the sensitivity to errors is not that big around the match
//  355                     - we don't know what the peak should be
//  356                     - we don't know which side of the peak we are.
//  357                If we look for minimum correlation in quadrature signals we solve all three issues in one go. */
//  358             /* Cross correlate the real voltage signal with the synthesised quadrature one, and tune the phase to
//  359                minimise the correlation. This assumes the phase rate is being accurately derived from the mains
//  360                frequency measurement, and we only need to adjust the phase here. This is a sort of PLL, with the
//  361                frequency and phase aspects of the lock being seperately evaluated. */
//  362             V_quad_pure = dds_lookup(phase->metrology.pure_phase + 0x40000000);
        MOV.W   &working_data + 188, R12
        MOV.W   &working_data + 190, R13
        ADD.W   #0x4000, R13
        CALL    #dds_lookup
        MOV.W   R12, 0x4(SP)
//  363             summy = imul16(V_corrected, V_quad_pure);
        MOV.W   R12, R13
        MOV.W   R11, R12
        CALL    #imul16
//  364             /* We need to filter hard at this point, to massively suppress the harmonics. We do this with a single
//  365                pole with a very low turnover point. Obviously, this only tails off at 6dB/octave, so the downside
//  366                it a very slow pull-in during the initial phase locking. */
//  367             phase->metrology.cross_sum += ((summy - phase->metrology.cross_sum) >> 13);
        SUB.W   &working_data + 196, R12
        SUBC.W  &working_data + 198, R13
        SWPB    R12
        SWPB    R13
        XOR.B   R13, R12
        XOR.W   R13, R12
        SXT     R13
        CALL    #?ShiftRight32s_5
        ADD.W   R12, &working_data + 196
        ADDC.W  R13, &working_data + 198
//  368             phase->metrology.pure_phase += (phase->metrology.cross_sum >> 5);
        MOV.W   &working_data + 196, R12
        MOV.W   &working_data + 198, R13
        CALL    #?ShiftRight32s_5
        ADD.W   R12, &working_data + 188
        ADDC.W  R13, &working_data + 190
//  369             phase->metrology.pure_phase += phase->metrology.pure_phase_rate;
        ADD.W   &working_data + 192, &working_data + 188
        ADDC.W  &working_data + 194, &working_data + 190
//  370 #endif
//  371         }
//  372 
//  373 #if NUM_PHASES == 1  &&  defined(NEUTRAL_MONITOR_SUPPORT)
//  374         for (ch = 0;  ch < 2;  ch++)
//  375         {
//  376             I_corrected = adc_i_buffer[ch];
//  377 #else
//  378         {
//  379             I_corrected = adc_i_buffer[ph];
??per_sample_dsp_12:
        MOV.W   &adc_i_buffer, 0x8(SP)
        MOV.W   &adc_i_buffer + 2, 0xa(SP)
//  380 #endif
//  381             sensor_dot_products = &phase->metrology.current[ch].dot_prod[dp];
        RLA.W   R8
        MOV.W   R8, R15
        RLA.W   R8
        RLA.W   R8
        ADD.W   R8, R15
        RLA.W   R8
        RLA.W   R8
        ADD.W   R15, R8
        ADD.W   #working_data + 244, R8
//  382             if ((I_corrected >= I_ADC_MAX  ||  I_corrected <= I_ADC_MIN)  &&  phase->metrology.current[0].I_endstops)
        MOV.W   0x8(SP), R14
        MOV.W   0xa(SP), R15
        ADD.W   #0x17ff, R14
        ADDC.W  #0x79, R15
        CMP.W   #0xf2, R15
        JNC     ??per_sample_dsp_14
        JNE     ??per_sample_dsp_15
        CMP.W   #0x2fff, R14
        JNC     ??per_sample_dsp_14
??per_sample_dsp_15:
        CMP.B   #0x0, &working_data + 346
        JEQ     ??per_sample_dsp_14
//  383                 phase->metrology.current[ch].I_endstops--;
        ADD.B   #0xff, &working_data + 346
//  384             
//  385             if (phase->status & PHASE_STATUS_DC_MODE)
??per_sample_dsp_14:
        CMP.W   #0x0, &working_data + 360
        MOV.W   &working_data + 338, R14
        MOV.W   &working_data + 340, R15
        MOV.W   #working_data + 230, R12
        JGE     ??per_sample_dsp_16
//  386             {
//  387                 I_sample[ch] = dc_filter_current_no_update(phase->metrology.current[ch].I_dc_estimate[normal_limp], phase->metrology.current[ch].I_history[0]);   // D.C. mode
        CALL    #dc_filter24_no_update
        MOV.W   R12, 0(SP)
        MOV.W   R13, 0x2(SP)
        JMP     ??per_sample_dsp_17
//  388             }
//  389             else
//  390             {
//  391                 I_sample[ch] = dc_filter_current(phase->metrology.current[ch].I_dc_estimate[normal_limp], phase->metrology.current[ch].I_history[0]); // a.c. mode
??per_sample_dsp_16:
        CALL    #dc_filter24
        MOV.W   R12, R4
        MOV.W   R13, R5
//  392 
//  393 #if defined (CAPACITOR_COMPENSATE_ON)
//  394             I_sample[ch] += ((V_sample - phase->metrology.V_history[adjust_v_history_index (phase->metrology.V_history_index - 1)]) * capacitance_scaling);
        MOV.B   @R9, R12
        ADD.B   #0xff, R12
        MOV.B   R12, R14
        CMP.B   #0x0, R12
        JL      ??per_sample_dsp_1
        CMP.B   #0x30, R12
        JNC     ??per_sample_dsp_18
        PUSH.B  R12
          CFI CFA SP+32
        MOV.B   #0x30, R14
        CALL    #?DivMod8u
        RLA.B   R12
        RLA.B   R12
        RLA.B   R12
        RLA.B   R12
        MOV.B   R12, R14
        RLA.B   R12
        RLA.B   R12
        ADD.B   R12, R14
        RLA.B   R12
        ADD.B   R14, R12
        POP.B   R14
          CFI CFA SP+30
        ADD.B   R12, R14
        JMP     ??per_sample_dsp_18
??per_sample_dsp_1:
        ADD.B   #0x30, R14
        CMP.B   #0x0, R14
        JL      ??per_sample_dsp_1
//  395 #endif            
//  396             
//  397             }
??per_sample_dsp_18:
        MOV.W   R4, R12
        MOV.W   R5, R13
        SXT     R14
        RLA.W   R14
        SUB.W   working_data + 90(R14), R10
        MOV.W   R10, R5
        XOR.W   #0xffff, R5
        RLA.W   R5
        SUBC.W  R5, R5
        MOV.W   &capacitance_scaling, R14
        MOV.W   &capacitance_scaling + 2, R15
        PUSH.W  SR
          CFI CFA SP+32
        DINT
        NOP
        MOV.W   R10, &0x130
        MOV.W   R14, &0x138
        MOV.W   R10, &0x134
        MOV.W   &0x13a, R4
        MOV.W   &0x13c, &0x13a
        MOV.W   R15, &0x138
        MOV.W   R5, &0x134
        MOV.W   R14, &0x138
        MOV.W   &0x13a, R5
        POP.W   SR
          CFI CFA SP+30
        MOV.W   R12, R14
        MOV.W   R13, R15
        ADD.W   R4, R14
        ADDC.W  R5, R15
        MOV.W   R14, 0(SP)
        MOV.W   R15, 0x2(SP)
//  398 
//  399 #if defined (WIRE_RESISTANCE_COMPENSATE)            
//  400             // ----- resistance compensation
//  401             Last_I_sample = (I_sample[ch] >> 8);
??per_sample_dsp_17:
        MOV.W   @SP, R14
        MOV.W   0x2(SP), R15
        SWPB    R14
        SWPB    R15
        XOR.B   R15, R14
        XOR.W   R15, R14
        MOV.W   R14, &??Last_I_sample
//  402             // -----
//  403 #endif
//  404             
//  405 #if I_HISTORY_STEPS > 2
//  406             for (k = 0;  k < I_HISTORY_STEPS - 1;  k++)
//  407                 phase->metrology.current[ch].I_history[k] = phase->metrology.current[ch].I_history[k + 1];
//  408 #else
//  409             phase->metrology.current[ch].I_history[0] = phase->metrology.current[ch].I_history[1];
        MOV.W   &working_data + 342, &working_data + 338
        MOV.W   &working_data + 344, &working_data + 340
//  410 #endif
//  411             phase->metrology.current[ch].I_history[I_HISTORY_STEPS - 1] = I_corrected;
        MOV.W   0x8(SP), &working_data + 342
        MOV.W   0xa(SP), &working_data + 344
//  412 #if defined(RESIDUAL_IRMS_SUPPORT)
//  413             I_residue += I_sample[ch];
//  414 #endif
//  415 #if defined(IRMS_SUPPORT)  ||  defined(POWER_FACTOR_SUPPORT)
//  416             sqac_current(sensor_dot_products->I_sq, I_sample[ch]);
        MOV.W   @SP, R14
        MOV.W   0x2(SP), R15
        MOV.W   R8, R12
        ADD.W   #0x20, R12
        CALL    #sqac64_24
//  417 #endif
//  418             if (operating_mode == OPERATING_MODE_NORMAL)
        CMP.B   #0x0, &operating_mode
        JNE     ??per_sample_dsp_19
        MOV.B   @R9, R12
        SUB.B   &working_data + 328, R12
        MOV.B   R12, R10
//  419             {
//  420                 /* Perform bulk delay (i.e. integer sample times) of the voltage signal. */
//  421                 V_corrected = phase->metrology.V_history[adjust_v_history_index (phase->metrology.V_history_index - phase->metrology.current[ch].in_phase_correction.step)];
        CMP.B   #0x0, R12
        JL      ??per_sample_dsp_2
        CMP.B   #0x30, R12
        JNC     ??per_sample_dsp_20
        MOV.B   #0x30, R14
        CALL    #?DivMod8u
        RLA.B   R12
        RLA.B   R12
        RLA.B   R12
        RLA.B   R12
        MOV.B   R12, R14
        RLA.B   R12
        RLA.B   R12
        ADD.B   R12, R14
        RLA.B   R12
        ADD.B   R14, R12
        ADD.B   R12, R10
        JMP     ??per_sample_dsp_20
??per_sample_dsp_2:
        ADD.B   #0x30, R10
        CMP.B   #0x0, R10
        JL      ??per_sample_dsp_2
??per_sample_dsp_20:
        SXT     R10
        RLA.W   R10
        MOV.W   working_data + 90(R10), R11
//  422                 mac_power(sensor_dot_products->P_active, V_corrected, I_sample[ch]);
        MOV.W   #mac64_16_24, R10
        MOV.W   @SP, R14
        MOV.W   0x2(SP), R15
        MOV.W   R11, R13
        MOV.W   R8, R12
        CALL    R10
        MOV.B   @R9, R12
        SUB.B   &working_data + 332, R12
        ADD.B   #0xff, R12
        MOV.B   R12, R4
//  423 #if defined(REACTIVE_POWER_BY_QUADRATURE_SUPPORT)
//  424                 V_quad_corrected = (q1_15_mul(phase->metrology.V_history[adjust_v_history_index (phase->metrology.V_history_index - phase->metrology.current[ch].quadrature_correction.step - 1)], phase->metrology.current[ch].quadrature_correction.fir_beta) >> 1)
//  425                                   + (phase->metrology.V_history[adjust_v_history_index (phase->metrology.V_history_index - phase->metrology.current[ch].quadrature_correction.step)] >> 1);
        CMP.B   #0x0, R12
        JL      ??per_sample_dsp_3
        CMP.B   #0x30, R12
        JNC     ??per_sample_dsp_21
        MOV.B   #0x30, R14
        CALL    #?DivMod8u
        RLA.B   R12
        RLA.B   R12
        RLA.B   R12
        RLA.B   R12
        MOV.B   R12, R14
        RLA.B   R12
        RLA.B   R12
        ADD.B   R12, R14
        RLA.B   R12
        ADD.B   R14, R12
        ADD.B   R12, R4
        JMP     ??per_sample_dsp_21
??per_sample_dsp_3:
        ADD.B   #0x30, R4
        CMP.B   #0x0, R4
        JL      ??per_sample_dsp_3
??per_sample_dsp_21:
        MOV.W   &working_data + 334, R13
        SXT     R4
        RLA.W   R4
        MOV.W   working_data + 90(R4), R12
        CALL    #q1_15_mul
        MOV.W   R12, R4
        MOV.B   @R9, R12
        SUB.B   &working_data + 332, R12
        MOV.B   R12, R5
        CMP.B   #0x0, R12
        JL      ??per_sample_dsp_4
        CMP.B   #0x30, R12
        JNC     ??per_sample_dsp_22
        MOV.B   #0x30, R14
        CALL    #?DivMod8u
        RLA.B   R12
        RLA.B   R12
        RLA.B   R12
        RLA.B   R12
        MOV.B   R12, R14
        RLA.B   R12
        RLA.B   R12
        ADD.B   R12, R14
        RLA.B   R12
        ADD.B   R14, R12
        ADD.B   R12, R5
        JMP     ??per_sample_dsp_22
??per_sample_dsp_4:
        ADD.B   #0x30, R5
        CMP.B   #0x0, R5
        JL      ??per_sample_dsp_4
//  426                 mac_power(sensor_dot_products->P_reactive, V_quad_corrected, I_sample[ch]);
??per_sample_dsp_22:
        MOV.W   @SP, R14
        MOV.W   0x2(SP), R15
        RRA.W   R4
        SXT     R5
        RLA.W   R5
        MOV.W   working_data + 90(R5), R13
        RRA.W   R13
        ADD.W   R4, R13
        MOV.W   R8, R12
        ADD.W   #0x8, R12
        CALL    R10
//  427 #endif
//  428 #if defined(FUNDAMENTAL_ACTIVE_POWER_SUPPORT)
//  429                 mac_power(sensor_dot_products->P_fundamental_active, V_pure, I_sample[ch]);
        MOV.W   @SP, R14
        MOV.W   0x2(SP), R15
        MOV.W   0x6(SP), R13
        MOV.W   R8, R12
        ADD.W   #0x10, R12
        CALL    R10
//  430 #endif
//  431 #if defined(FUNDAMENTAL_REACTIVE_POWER_SUPPORT)
//  432                 mac_power(sensor_dot_products->P_fundamental_reactive, -V_quad_pure, I_sample[ch]);
        MOV.W   @SP, R14
        MOV.W   0x2(SP), R15
        MOV.W   0x4(SP), R13
        XOR.W   #0xffff, R13
        ADD.W   #0x1, R13
        MOV.W   R8, R12
        ADD.W   #0x18, R12
        CALL    R10
//  433 #endif
//  434             }
//  435             ++sensor_dot_products->sample_count;
??per_sample_dsp_19:
        ADD.W   #0x1, 0x28(R8)
//  436         }
//  437 
//  438 #ifdef TEAGER_KAISER_TEST_SUPPORT    
//  439          
//  440         phase->metrology.V_good_history <<= 1;
//  441         if (((int32_t)(phase->metrology.V_history[adjust_v_history_index (phase->metrology.V_history_index - 1)])
//  442            * (phase->metrology.V_history[adjust_v_history_index (phase->metrology.V_history_index - 1)])) 
//  443             - ((int32_t)(V_sample) * phase->metrology.V_history[adjust_v_history_index (phase->metrology.V_history_index - 2)])
//  444               > ((P1OUT & BIT0) ? (170000) : (135000)))
//  445         {
//  446             phase->metrology.V_good_history |= 1;
//  447         }  
//  448         else
//  449         {  
//  450             phase->metrology.V_good_history &= ~0x01;
//  451         }
//  452         
//  453         if (phase->metrology.V_good_history == 0xffff)
//  454         {
//  455             V_GOOD_ON ();
//  456         }
//  457         if (phase->metrology.V_good_history == 0x0000)
//  458         {
//  459             V_GOOD_OFF ();
//  460         }
//  461 #endif       
//  462         phase->metrology.V_history_index = adjust_v_history_index (phase->metrology.V_history_index + 1);
        MOV.B   @R9, R12
        ADD.B   #0x1, R12
        MOV.B   R12, R10
        CMP.B   #0x0, R12
        JL      ??per_sample_dsp_5
        CMP.B   #0x30, R12
        JNC     ??per_sample_dsp_23
        MOV.B   #0x30, R14
        CALL    #?DivMod8u
        RLA.B   R12
        RLA.B   R12
        RLA.B   R12
        RLA.B   R12
        MOV.B   R12, R14
        RLA.B   R12
        RLA.B   R12
        ADD.B   R12, R14
        RLA.B   R12
        ADD.B   R14, R12
        ADD.B   R12, R10
        JMP     ??per_sample_dsp_23
??per_sample_dsp_5:
        ADD.B   #0x30, R10
        CMP.B   #0x0, R10
        JL      ??per_sample_dsp_5
??per_sample_dsp_23:
        MOV.B   R10, &working_data + 186
//  463 
//  464         /* Do the power cycle start detection */
//  465         /* There is no hysteresis used here, but since the signal is
//  466            changing rapidly at the zero crossings, and is always of
//  467            large amplitude, miscounting cycles due to general noise
//  468            should not occur. Spikes are another matter. A large spike
//  469            could cause the power cycles to be miscounted, but does not
//  470            matter very much. The cycle counting is not critical to power
//  471            or energy measurement. */
//  472 #if defined(MAINS_FREQUENCY_SUPPORT)
//  473     #if defined(LIMP_MODE_SUPPORT)
//  474         if (operating_mode == OPERATING_MODE_LIMP)
//  475             phase->metrology.cycle_sample_count += LIMP_SAMPLING_RATIO*256;
//  476         else
//  477     #endif
//  478             phase->metrology.cycle_sample_count += 256;
        ADD.W   #0x100, &working_data + 348
//  479 #endif
//  480         if (abs(V_corrected - phase->metrology.last_V_sample) <= phase->metrology.since_last*MAX_PER_SAMPLE_VOLTAGE_SLEW)
        MOV.W   R11, R15
        SUB.W   &working_data + 356, R15
        CMP.W   #0x0, R15
        JGE     ??per_sample_dsp_8
        XOR.W   #0xffff, R15
        ADD.W   #0x1, R15
??per_sample_dsp_8:
        PUSH.W  SR
          CFI CFA SP+32
        DINT
        NOP
        MOV.W   &working_data + 354, &0x130
        MOV.W   #0xfa0, &0x138
        MOV.W   &0x13a, R14
        POP.W   SR
          CFI CFA SP+30
        CMP.W   R15, R14
        JL      ??per_sample_dsp_24
//  481         {
//  482             /* This doesn't look like a spike - do mains cycle detection, and
//  483                estimate the precise mains period */
//  484             if (V_corrected < 0)
        CMP.W   #0x0, R11
        JGE     ??per_sample_dsp_25
//  485             {
//  486                 /* We just crossed from positive to negative */
//  487                 /* Log the sign of the signal */
//  488                 if (phase->status & PHASE_STATUS_V_POS)
        BIT.W   #0x2, &working_data + 360
        JNC     ??per_sample_dsp_26
//  489                 {
//  490                     phase->status &= ~PHASE_STATUS_V_POS;
        BIC.W   #0x2, &working_data + 360
//  491                     ZERO_CROSS_ON ();
        CALL    #ZERO_CROSS_ON
//  492                     phase->metrology.current[ch].I_dc_estimate_temp  = dc_filter_current_estimate (phase->metrology.current[ch].I_dc_estimate[normal_limp]);
        MOV.W   #working_data + 230, R12
        CALL    #dc_filter24_estimate
        MOV.W   R12, &working_data + 240
        MOV.W   R13, &working_data + 242
//  493                     phase->metrology.V_dc_estimate_temp = dc_filter_voltage_estimate(phase->metrology.V_dc_estimate[normal_limp]); 
        MOV.W   #working_data + 78, R12
        CALL    #dc_filter16_estimate
        MOV.W   R12, &working_data + 86
        MOV.W   R13, &working_data + 88
        JMP     ??per_sample_dsp_26
//  494                 }
//  495             }
//  496             else
//  497             {
//  498                 /* We just crossed from negative to positive */
//  499                 if (!(phase->status & PHASE_STATUS_V_POS))
??per_sample_dsp_25:
        BIT.W   #0x2, &working_data + 360
        JC      ??per_sample_dsp_26
//  500                 {
//  501                     /* Log the sign of the signal */
//  502                     phase->status |= PHASE_STATUS_V_POS;
        BIS.W   #0x2, &working_data + 360
//  503                     ZERO_CROSS_OFF ();
        CALL    #ZERO_CROSS_OFF
//  504 #if defined(MAINS_FREQUENCY_SUPPORT)
//  505                     /* Apply limits to the sample count, to avoid spikes or dying power lines disturbing the
//  506                        frequency reading too much */
//  507                     /* The mains should be <40Hz or >70Hz to fail this test! */
//  508                     if (((256*SAMPLES_PER_10_SECONDS)/700) <= phase->metrology.cycle_sample_count  &&  phase->metrology.cycle_sample_count <= (((256*SAMPLES_PER_10_SECONDS)/400)))
        MOV.W   &working_data + 348, R15
        ADD.W   #0x8db7, R15
        CMP.W   #0x55b8, R15
        JC      ??per_sample_dsp_27
//  509                     {
//  510                         /* A mains frequency measurement procedure based on interpolating zero crossings,
//  511                            to get a fast update rate for step changes in the mains frequency */
//  512     #if defined(SAG_SWELL_SUPPORT)
//  513                         accum48_48(phase_dot_products->V_sq, phase->metrology.V_sq_cycle);
//  514                         decum48_48(phase->metrology.V_sq_window, phase->metrology.V_sq_prev_cycle[phase->metrology.prev_cycle_ptr]);
//  515                         accum48_48(phase->metrology.V_sq_window, phase->metrology.V_sq_cycle);
//  516                         transfer48(phase->metrology.V_sq_prev_cycle[phase->metrology.prev_cycle_ptr], phase->metrology.V_sq_cycle);
//  517                         if (++phase->metrology.prev_cycle_ptr >= SAG_SWELL_WINDOW_LEN)
//  518                             phase->metrology.prev_cycle_ptr = 0;
//  519                         if (phase->metrology.V_sq_window[2] < phase->metrology.sag_threshold[2]
//  520                             ||
//  521                             (phase->metrology.V_sq_window[2] == phase->metrology.sag_threshold[2]  &&  (uint16_t) phase->metrology.V_sq_window[1] < (uint16_t) phase->metrology.sag_threshold[1]))
//  522                         {
//  523                             if (phase->metrology.sag_status != -1)
//  524                             {
//  525                                 phase->metrology.sag_status = -1;
//  526                                 phase->sag_events++;
//  527                             }
//  528                             phase->sag_duration++;
//  529                         }
//  530                         else if (phase->metrology.V_sq_window[2] > phase->metrology.swell_threshold[2]
//  531                                  ||
//  532                                  (phase->metrology.V_sq_window[2] == phase->metrology.swell_threshold[2]  &&  (uint16_t) phase->metrology.V_sq_window[1] > (uint16_t) phase->metrology.swell_threshold[1]))
//  533                         {
//  534                             if (phase->metrology.sag_status != 1)
//  535                             {
//  536                                 phase->metrology.sag_status = 1;
//  537                                 phase->swell_events++;
//  538                             }
//  539                             phase->swell_duration++;
//  540                         }
//  541                         else
//  542                         {
//  543                             phase->metrology.sag_status = 0;
//  544                         }
//  545     #endif
//  546                         /* Interpolate the zero crossing by successive approx. */
//  547                         z = V_corrected - phase->metrology.last_V_sample;
        MOV.W   R11, R13
        SUB.W   &working_data + 356, R13
//  548                         x = 0;
        MOV.W   #0x0, R15
//  549                         y = 0;
        MOV.W   #0x0, R14
//  550                         for (k = 0;  k < 8;  k++)
        MOV.B   #0x8, R10
//  551                         {
//  552                             y <<= 1;
??per_sample_dsp_6:
        RLA.W   R14
//  553                             z >>= 1;
        RRA.W   R13
//  554                             x += z;
        ADD.W   R13, R15
//  555                             if (x > V_corrected)
        CMP.W   R15, R11
        JGE     ??per_sample_dsp_28
//  556                                 x -= z;
        SUB.W   R13, R15
        JMP     ??per_sample_dsp_29
//  557                             else
//  558                                 y |= 1;
??per_sample_dsp_28:
        BIS.W   #0x1, R14
//  559                         }
??per_sample_dsp_29:
        ADD.B   #0xff, R10
        JNE     ??per_sample_dsp_6
//  560                         /* Now we need to allow for skipped samples, due to spike detection */
//  561                         z = y;
        MOV.W   R14, R13
//  562                         while (phase->metrology.since_last > 1)
        CMP.W   #0x2, &working_data + 354
        JL      ??per_sample_dsp_30
//  563                         {
//  564                             z += y;
??per_sample_dsp_7:
        ADD.W   R14, R13
//  565                             phase->metrology.since_last--;
        ADD.W   #0xffff, &working_data + 354
        CMP.W   #0x2, &working_data + 354
        JL      ??per_sample_dsp_30
        ADD.W   R14, R13
        ADD.W   #0xffff, &working_data + 354
        CMP.W   #0x2, &working_data + 354
        JL      ??per_sample_dsp_30
        ADD.W   R14, R13
        ADD.W   #0xffff, &working_data + 354
        CMP.W   #0x2, &working_data + 354
        JL      ??per_sample_dsp_30
        ADD.W   R14, R13
        ADD.W   #0xffff, &working_data + 354
        CMP.W   #0x2, &working_data + 354
        JGE     ??per_sample_dsp_7
//  566                         }
//  567                         /* z is now the fraction of a sample interval between the zero
//  568                            crossing and the current sample, in units of 1/256 of a sample */
//  569                         /* A lightly damped single pole filter should now be enough to remove noise and get a
//  570                            stable value for the frequency */
//  571 //                        phase->metrology.mains_period += ((uint32_t) (phase->metrology.cycle_sample_count - z) << 12) - (phase->metrology.mains_period >> 4);
//  572                         phase->metrology.mains_period = (((uint32_t) (phase->metrology.cycle_sample_count - z) << 16));
??per_sample_dsp_30:
        MOV.W   &working_data + 348, R15
        SUB.W   R13, R15
        MOV.W   #0x0, &working_data + 350
        MOV.W   R15, &working_data + 352
//  573                         /* Start the next cycle with the residual fraction of a sample */
//  574                         phase->metrology.cycle_sample_count = z;
        MOV.W   R13, &working_data + 348
//  575 
//  576                         phase->metrology.cycle_count++;
        ADD.W   #0x1, &working_data + 200
        JMP     ??per_sample_dsp_26
//  577                     }
//  578                     else
//  579                     {
//  580                         phase->metrology.cycle_sample_count = 0;
??per_sample_dsp_27:
        MOV.W   #0x0, &working_data + 348
//  581                     }
//  582 #endif
//  583 #if defined(POWER_FACTOR_SUPPORT)  &&  !defined(REACTIVE_POWER_BY_QUADRATURE_SUPPORT)
//  584                     /* If we are not measuring the reactive power in a quadrature manner, we
//  585                        need to work out if the current leads or lags the voltage in another way. */
//  586                     /* Determine whether the current leads or lags, in a noise tolerant manner.
//  587                        Testing 50 cycles means we will respond in about one second to a genuine
//  588                        swap between lead and lag. Since that is also about the length of our
//  589                        measurement blocks, this seems a sensible response time. */
//  590 #if NUM_PHASES == 1  &&  defined(NEUTRAL_MONITOR_SUPPORT)
//  591                     for (ch = 0;  ch < 2;  ch++)
//  592 #endif
//  593                     {
//  594                         if (I_sample[ch] < V_corrected)
//  595                         {
//  596                             if (phase->metrology.current[ch].leading > -50)
//  597                                 phase->metrology.current[ch].leading--;
//  598                         }
//  599                         else
//  600                         {
//  601                             if (phase->metrology.current[ch].leading < 50)
//  602                                 phase->metrology.current[ch].leading++;
//  603                         }
//  604                     }
//  605 #endif
//  606                     /* See if a sufficiently long measurement interval has been
//  607                        recorded, and catch the start of the next cycle. We do not
//  608                        really care how many cycles there are, as long as the block
//  609                        is a reasonable length. Setting a minimum of 1 second is
//  610                        better than counting cycles, as it is not affected by noise
//  611                        spikes. Synchronising to a whole number of cycles reduces
//  612                        block to block jitter, though it doesn't affect the long
//  613                        term accuracy of the measurements. */
//  614 //                    if (phase_dot_products->sample_count >= samples_per_second)
//  615                 }
//  616             }
//  617             phase->metrology.since_last = 0;
??per_sample_dsp_26:
        MOV.W   #0x0, &working_data + 354
//  618             phase->metrology.last_V_sample = V_corrected;
        MOV.W   R11, &working_data + 356
//  619         }
//  620         phase->metrology.since_last++;
??per_sample_dsp_24:
        ADD.W   #0x1, &working_data + 354
//  621 
//  622         if (phase->metrology.cycle_count >= REPORT_CYCLE)
        CMP.W   #0x4, &working_data + 200
        JNC     ??per_sample_dsp_31
//  623         {
//  624 #if NUM_PHASES == 1
//  625             log_parameters();
        CALL    #log_parameters
//  626 #else
//  627             log_parameters(phase, ph);
//  628 #endif
//  629 
//  630             if (phase->status & PHASE_STATUS_DC_MODE)
        CMP.W   #0x0, &working_data + 360
        JGE     ??per_sample_dsp_32
//  631             {
//  632                 phase->status &= ~PHASE_STATUS_DC_MODE;
        BIC.W   #0x8000, &working_data + 360
//  633                 metrology_init_from_nv_data ();
        CALL    #metrology_init_from_nv_data
//  634             }
//  635             phase->metrology.cycle_count = 0;
??per_sample_dsp_32:
        MOV.W   #0x0, &working_data + 200
//  636             kick = TRUE;
        MOV.W   #0x1, R7
//  637             DC_MODE_OFF ();
        CALL    #DC_MODE_OFF
//  638             AC_MODE_ON ();
        CALL    #AC_MODE_ON
        JMP     ??per_sample_dsp_33
//  639         }
//  640 //        else if ((phase_dot_products->sample_count >= ((REPORT_CYCLE*samples_per_second)/MAINS_NOMINAL_FREQUENCY)))
//  641         else if ((phase_dot_products->sample_count >= ((REPORT_CYCLE*SAMPLE_RATE)/MAINS_NOMINAL_FREQUENCY)))
??per_sample_dsp_31:
        CMP.W   #0x280, 0xc(R6)
        JL      ??per_sample_dsp_33
//  642         {
//  643             if (phase->metrology.cycle_count < (REPORT_CYCLE - 1))
        CMP.W   #0x3, &working_data + 200
        JC      ??per_sample_dsp_33
//  644             {
//  645             #if NUM_PHASES == 1
//  646                 log_parameters();
        CALL    #log_parameters
//  647             #else
//  648                 log_parameters(phase, ph);
//  649             #endif
//  650                 if (!(phase->status & PHASE_STATUS_DC_MODE))
        CMP.W   #0x0, &working_data + 360
        JL      ??per_sample_dsp_34
//  651                 {
//  652                     phase->status |= PHASE_STATUS_DC_MODE;
        BIS.W   #0x8000, &working_data + 360
//  653                     metrology_init_from_nv_data ();
        CALL    #metrology_init_from_nv_data
//  654 //                    phase->metrology.V_dc_estimate_logged =  ((int32_t)phase_cal->initial_v_dc_estimate[0] * 256);
//  655                     phase->metrology.V_dc_estimate_logged =  ((int32_t)cal_info->phases[ph].initial_v_dc_estimate[0] * 256);
        MOV.W   &nv_parms + 16, R14
        MOV.W   R14, R15
        XOR.W   #0xffff, R15
        RLA.W   R15
        SUBC.B  R15, R15
        XOR.B   R14, R15
        XOR.W   R14, R15
        SWPB    R15
        AND.B   #0xff, R14
        SWPB    R14
        MOV.W   R14, &working_data + 82
        MOV.W   R15, &working_data + 84
//  656 //                    phase->metrology.current[ch].I_dc_estimate_logged = phase_cal->current[0].initial_dc_estimate[0];
//  657                     phase->metrology.current[ch].I_dc_estimate_logged = cal_info->phases[ph].current[0].initial_dc_estimate[0];
        MOV.W   &nv_parms + 2, &working_data + 236
        MOV.W   &nv_parms + 4, &working_data + 238
//  658                 }
//  659                 phase->metrology.cycle_count = 0;
??per_sample_dsp_34:
        MOV.W   #0x0, &working_data + 200
//  660                 kick = TRUE;
        MOV.W   #0x1, R7
//  661                 AC_MODE_OFF ();
        CALL    #AC_MODE_OFF
//  662                 DC_MODE_ON ();
        CALL    #DC_MODE_ON
//  663             }
//  664         }
//  665         
//  666 #if NUM_PHASES == 1  &&  defined(NEUTRAL_MONITOR_SUPPORT)
//  667         for (ch = 0;  ch < 2;  ch++)
//  668 #endif
//  669         {
//  670 #if defined(MAINS_FREQUENCY_SUPPORT)
//  671             /* Monitor the cycles and frequency of the current sensors, as limp
//  672                mode is based on these. */
//  673     #if defined(LIMP_MODE_SUPPORT)
//  674             if (operating_mode == OPERATING_MODE_LIMP)
//  675                 phase->metrology.current[ch].cycle_sample_count += 256*LIMP_SAMPLING_RATIO;
//  676             else
//  677     #endif
//  678 //                phase->metrology.current[ch].cycle_sample_count += 256;
//  679 #endif
//  680 //            if (I_sample[ch] < 0)
//  681 //            {
//  682                 /* Log the sign of the signal */
//  683 //                phase->status &= ~current_pos_masks[ch];
//  684 //            }
//  685 //            else
//  686 //            {
//  687 //                if (!(phase->status & current_pos_masks[ch]))
//  688 //                {
//  689                     /* A negative to positive transition has occurred. Trust it
//  690                        blindly as a genuine zero crossing/start of cycle, even
//  691                        though it might really be due to a noise spike. */
//  692 #if defined(MAINS_FREQUENCY_SUPPORT)
//  693 //                    if (SAMPLES_PER_10_SECONDS/700 <= phase->metrology.current[ch].cycle_sample_count  &&  phase->metrology.current[ch].cycle_sample_count <= SAMPLES_PER_10_SECONDS/400)
//  694 //                        phase->metrology.current[ch].mains_period += ((uint32_t) phase->metrology.current[ch].cycle_sample_count << 16) - (phase->metrology.current[ch].mains_period >> 8);
//  695 //                    phase->metrology.current[ch].cycle_sample_count = 0;
//  696 #endif
//  697 //                }
//  698                 /* Log the sign of the signal */
//  699 //                phase->status |= current_pos_masks[ch];
//  700 //            }
//  701         }
//  702     }
//  703 
//  704 #if NUM_PHASES > 1  &&  defined(NEUTRAL_MONITOR_SUPPORT)  &&  defined(IRMS_SUPPORT)
//  705     /* For multi-phase meters, neutral monitoring is limited to measuring the
//  706        neutral RMS current, and the residual RMS current. */
//  707     dp = working_data.neutral.metrology.dp_set ^ 1;
//  708     neutral_dot_products = &working_data.neutral.metrology.dot_prod[dp];
//  709     I_corrected = adc_i_buffer[NUM_PHASES];
//  710     #if defined(TEMPERATURE_SUPPORT)  &&  !defined(__MSP430_HAS_ADC10_A__)
//  711     if (temperature_sequence)
//  712     {
//  713         temperature_sequence++;
//  714         if (temperature_sequence == 6)
//  715         {
//  716             /* We are in temperature measurement mode */
//  717             raw_temperature_from_adc += I_corrected - (raw_temperature_from_adc >> 3);
//  718         #if defined(TRNG_SUPPORT)
//  719             rolling_random = (rolling_random << 1) | (I_corrected & 1);
//  720             if (++rand_bits == 16)
//  721             {
//  722                 random_value = rolling_random;
//  723                 new_random_value = TRUE;
//  724                 rand_bits = 0;
//  725             }
//  726         #endif
//  727             /* Select the current input */
//  728             sd_xxxx_reg(SD_INCTL_, NEUTRAL_CURRENT_ADC_CHANNEL) = SD_INCH_CURRENT | SD_NEUTRAL_CURRENT_GAIN;
//  729         }
//  730         else if (temperature_sequence == 11)
//  731         {
//  732             /* We have waited long enough to be back on good current samples */
//  733             temperature_sequence = 0;
//  734         }
//  735         /* TODO: Can't we do better than just stalling on the last value? */
//  736         I_corrected = working_data.neutral.metrology.I_history[I_HISTORY_STEPS - 1];
//  737     }
//  738     else
//  739     #endif
//  740     {
//  741         if ((I_corrected >= I_ADC_MAX  ||  I_corrected <= I_ADC_MIN)  &&  working_data.neutral.metrology.I_endstops)
//  742             working_data.neutral.metrology.I_endstops--;
//  743         I_sample[0] = dc_filter_current(working_data.neutral.metrology.I_dc_estimate[normal_limp], working_data.neutral.metrology.I_history[0]);
//  744         sqac_current(neutral_dot_products->I_sq, I_sample[0]);
//  745     #if defined(RESIDUAL_IRMS_SUPPORT)
//  746         /* Scale the current from the neutral by 1/sqrt(2) */
//  747         I_sample[0] = q1_15_mul(I_sample[0], 21790);
//  748         I_sample[0] -= I_residue;
//  749         sqac_current(neutral_dot_products->residual_I_sq, I_sample[0]);
//  750     #endif
//  751     }
//  752 //    if (++neutral_dot_products->sample_count >= samples_per_second)
//  753     if (++neutral_dot_products->sample_count >= SAMPLE_RATE)
//  754     {
//  755         log_neutral_parameters();
//  756     #if defined(TEMPERATURE_SUPPORT)  &&  !defined(__MSP430_HAS_ADC10_A__)
//  757         temperature_sequence = 1;
//  758         /* Select the temperature diode */
//  759         sd_xxxx_reg(SD_INCTL_, NEUTRAL_CURRENT_ADC_CHANNEL) = SD_INCH_TEMPERATURE | SD_GAIN_TEMPERATURE;
//  760     #endif
//  761     }
//  762     #if I_HISTORY_STEPS > 2
//  763     for (k = 0;  k < I_HISTORY_STEPS - 1;  k++)
//  764         working_data.neutral.metrology.I_history[k] = working_data.neutral.metrology.I_history[k + 1];
//  765     #else
//  766     working_data.neutral.metrology.I_history[0] = working_data.neutral.metrology.I_history[1];
//  767     #endif
//  768     working_data.neutral.metrology.I_history[I_HISTORY_STEPS - 1] = I_corrected;
//  769 #endif
//  770     return kick;
??per_sample_dsp_33:
        MOV.W   R7, R12
        ADD.W   #0xc, SP
          CFI CFA SP+18
        BR      #?Epilogue8
          CFI EndBlock cfiBlock2
//  771 }

        RSEG DATA16_Z:DATA:SORT:NOROOT(1)
        REQUIRE ?cstart_init_zero
??Last_I_sample:
        DS8 2
//  772 
//  773 #if defined(ENERGY_PULSE_SUPPORT)  ||  defined(TOTAL_ENERGY_PULSE_SUPPORT)
//  774 static __inline__ void per_sample_energy_pulse_processing(void)
//  775 {
//  776 #if defined(ENERGY_PULSE_SUPPORT)  &&  NUM_PHASES > 1
//  777     struct phase_parms_s *phase;
//  778     int ph;
//  779 #endif
//  780     power_t pow;
//  781 
//  782     /* We now play the last measurement interval's power level, evaluated
//  783        in the foreground, through this measurement interval. In this way
//  784        we can evenly pace the pulsing of the LED. The only error produced
//  785        by this is the ambiguity in the number of samples per measurement.
//  786        This should not exceed 1 or 2 in over 4000. */
//  787 
//  788 #if defined(TOTAL_ACTIVE_ENERGY_PULSES_PER_KW_HOUR)
//  789     pow = working_data.totals.readings.active_power;
//  790     #if defined(LIMP_MODE_SUPPORT)
//  791     if (operating_mode == OPERATING_MODE_LIMP)
//  792         pow *= LIMP_SAMPLING_RATIO;
//  793     #endif
//  794     #if defined(INHIBIT_NEGATIVE_TOTAL_POWER_ACCUMULATION)
//  795     if (pow > 0)
//  796     #endif
//  797     {
//  798         if ((working_data.totals.energy.active_energy_pulse.energy_integrator += pow) >= TOTAL_ACTIVE_ENERGY_PULSE_THRESHOLD)
//  799         {
//  800             working_data.totals.energy.active_energy_pulse.energy_integrator -= TOTAL_ACTIVE_ENERGY_PULSE_THRESHOLD;
//  801             working_data.totals.energy.active_energy_pulse.pulse_remaining_time = ENERGY_PULSE_DURATION;
//  802             total_active_energy_pulse_start();
//  803         }
//  804     }
//  805     if (working_data.totals.energy.active_energy_pulse.pulse_remaining_time  &&  --working_data.totals.energy.active_energy_pulse.pulse_remaining_time == 0)
//  806         total_active_energy_pulse_end();
//  807 #endif
//  808 
//  809 #if defined(TOTAL_REACTIVE_ENERGY_PULSES_PER_KVAR_HOUR)
//  810     pow = working_data.totals.readings.reactive_power;
//  811     #if defined(LIMP_MODE_SUPPORT)
//  812     if (operating_mode == OPERATING_MODE_LIMP)
//  813         pow *= LIMP_SAMPLING_RATIO;
//  814     #endif
//  815     #if defined(INHIBIT_NEGATIVE_TOTAL_POWER_ACCUMULATION)
//  816     if (pow > 0)
//  817     #endif
//  818     {
//  819         if ((working_data.totals.energy.reactive_energy_pulse.energy_integrator += pow) >= TOTAL_REACTIVE_ENERGY_PULSE_THRESHOLD)
//  820         {
//  821             working_data.totals.energy.reactive_energy_pulse.energy_integrator -= TOTAL_REACTIVE_ENERGY_PULSE_THRESHOLD;
//  822             working_data.totals.energy.reactive_energy_pulse.pulse_remaining_time = ENERGY_PULSE_DURATION;
//  823             total_reactive_energy_pulse_start();
//  824         }
//  825     }
//  826     if (working_data.totals.energy.reactive_energy_pulse.pulse_remaining_time  &&  --working_data.totals.energy.reactive_energy_pulse.pulse_remaining_time == 0)
//  827         total_reactive_energy_pulse_end();
//  828 #endif
//  829 
//  830 #if defined(TOTAL_APPARENT_ENERGY_PULSES_PER_KVA_HOUR)
//  831     pow = working_data.totals.readings.apparent_power;
//  832     #if defined(LIMP_MODE_SUPPORT)
//  833     if (operating_mode == OPERATING_MODE_LIMP)
//  834         pow *= LIMP_SAMPLING_RATIO;
//  835     #endif
//  836     #if defined(INHIBIT_NEGATIVE_TOTAL_POWER_ACCUMULATION)
//  837     if (pow > 0)
//  838     #endif
//  839     {
//  840         if ((working_data.totals.energy.reactive_energy_pulse.energy_integrator += pow) >= TOTAL_APPARENT_ENERGY_PULSE_THRESHOLD)
//  841         {
//  842             working_data.totals.energy.reactive_energy_pulse.energy_integrator -= TOTAL_APPARENT_ENERGY_PULSE_THRESHOLD;
//  843             working_data.totals.energy.reactive_energy_pulse.pulse_remaining_time = ENERGY_PULSE_DURATION;
//  844             total_apparent_energy_pulse_start();
//  845         }
//  846     }
//  847     if (working_data.totals.energy.reactive_energy_pulse.pulse_remaining_time  &&  --working_data.totals.energy.reactive_energy_pulse.pulse_remaining_time == 0)
//  848         total_apparent_energy_pulse_end();
//  849 #endif
//  850 
//  851 #if defined(ENERGY_PULSE_SUPPORT)
//  852     #if NUM_PHASES == 1
//  853 #undef ph
//  854 #define ph /**/
//  855     #else
//  856     for (ph = 0, phase = working_data.phases;  ph < NUM_PHASES;  ph++, phase++)
//  857     #endif
//  858     {
//  859     #if defined(ACTIVE_ENERGY_PULSES_PER_KW_HOUR)
//  860         pow = phase->readings.active_power;
//  861         #if defined(LIMP_MODE_SUPPORT)
//  862         if (operating_mode == OPERATING_MODE_LIMP)
//  863             pow *= LIMP_SAMPLING_RATIO;
//  864         #endif
//  865         #if defined(INHIBIT_NEGATIVE_POWER_ACCUMULATION)
//  866         if (pow > 0)
//  867         #endif
//  868         {
//  869             if ((phase->energy.active_energy_pulse.energy_integrator += pow) >= ACTIVE_ENERGY_PULSE_THRESHOLD)
//  870             {
//  871                 phase->energy.active_energy_pulse.energy_integrator -= ACTIVE_ENERGY_PULSE_THRESHOLD;
//  872                 phase->energy.active_energy_pulse.pulse_remaining_time = ENERGY_PULSE_DURATION;
//  873                 active_energy_pulse_start(ph);
//  874             }
//  875         }
//  876         if (phase->energy.active_energy_pulse.pulse_remaining_time  &&  --phase->energy.active_energy_pulse.pulse_remaining_time == 0)
//  877             active_energy_pulse_end(ph);
//  878     #endif
//  879 
//  880     #if defined(REACTIVE_ENERGY_PULSES_PER_KVAR_HOUR)
//  881         pow = phase->readings.reactive_power;
//  882         #if defined(LIMP_MODE_SUPPORT)
//  883         if (operating_mode == OPERATING_MODE_LIMP)
//  884             pow *= LIMP_SAMPLING_RATIO;
//  885         #endif
//  886         #if defined(INHIBIT_NEGATIVE_POWER_ACCUMULATION)
//  887         if (pow > 0)
//  888         #endif
//  889         {
//  890             if ((phase->energy.reactive_energy_pulse.energy_integrator += pow) >= REACTIVE_ENERGY_PULSE_THRESHOLD)
//  891             {
//  892                 phase->energy.reactive_energy_pulse.energy_integrator -= REACTIVE_ENERGY_PULSE_THRESHOLD;
//  893                 phase->energy.reactive_energy_pulse.pulse_remaining_time = ENERGY_PULSE_DURATION;
//  894                 reactive_energy_pulse_start(ph);
//  895             }
//  896         }
//  897         if (phase->energy.reactive_energy_pulse.pulse_remaining_time  &&  --phase->energy.reactive_energy_pulse.pulse_remaining_time == 0)
//  898             reactive_energy_pulse_end(ph);
//  899     #endif
//  900 
//  901     #if defined(APPARENT_ENERGY_PULSES_PER_KVA_HOUR)
//  902         pow = phase->readings.apparent_power;
//  903         #if defined(LIMP_MODE_SUPPORT)
//  904         if (operating_mode == OPERATING_MODE_LIMP)
//  905             pow *= LIMP_SAMPLING_RATIO;
//  906         #endif
//  907         #if defined(INHIBIT_NEGATIVE_POWER_ACCUMULATION)
//  908         if (pow > 0)
//  909         #endif
//  910         {
//  911             if ((phase->energy.apparent_energy_pulse.energy_integrator += pow) >= APPARENT_ENERGY_PULSE_THRESHOLD)
//  912             {
//  913                 phase->energy.apparent_energy_pulse.energy_integrator -= APPARENT_ENERGY_PULSE_THRESHOLD;
//  914                 phase->energy.apparent_energy_pulse.pulse_remaining_time = ENERGY_PULSE_DURATION;
//  915                 apparent_energy_pulse_start(ph);
//  916             }
//  917         }
//  918         if (phase->energy.reactive_energy_pulse.pulse_remaining_time  &&  --phase->energy.apparent_energy_pulse.pulse_remaining_time == 0)
//  919             apparent_energy_pulse_end(ph);
//  920     #endif
//  921     }
//  922     #if NUM_PHASES == 1
//  923 #undef ph
//  924     #endif
//  925 #endif
//  926 }
//  927 #endif
//  928 
//  929 /*-----------------------------------------------------------------------------------
//  930   This is the main interrupt routine where the samples are gathered into a set, with
//  931   allowance for the staggered times at which the samples become available.
//  932   -----------------------------------------------------------------------------------*/
//  933 #if defined(__MSP430__)
//  934     #if defined(__MSP430_HAS_SD16_2__)  ||  defined(__MSP430_HAS_SD16_3__)
//  935 ISR(SD16, adc_interrupt)
//  936     #endif
//  937     #if defined(__MSP430_HAS_SD16_A3__)  ||  defined(__MSP430_HAS_SD16_A4__)  ||  defined(__MSP430_HAS_SD16_A6__)  ||  defined(__MSP430_HAS_SD16_A7__)
//  938 ISR(SD16A, adc_interrupt)
//  939     #endif
//  940     #if defined(__MSP430_HAS_SD24_2__)  ||  defined(__MSP430_HAS_SD24_A2__)  \ 
//  941         || defined(__MSP430_HAS_SD24_3__) ||  defined(__MSP430_HAS_SD24_A3__) \ 
//  942         || defined(__MSP430_HAS_SD24_4__) ||  defined(__MSP430_HAS_SD24_A4__)

        RSEG CODE:CODE:REORDER:NOROOT(1)
//  943 ISR(SD24, adc_interrupt)
adc_interrupt:
          CFI Block cfiBlock3 Using cfiCommon1
          CFI Function adc_interrupt
//  944     #endif
//  945     #if defined(__MSP430_HAS_SD24_B__) 
//  946         #if 0 //NUM_PHASES > 1  &&  defined(__MSP430_HAS_SD24_B3__)  &&  defined(__MSP430_HAS_ADC10_A__)
//  947 ISR(DMA, adc_interrupt)
//  948         #else
//  949 ISR(SD24B, adc_interrupt)
//  950         #endif
//  951     #endif
//  952 #else
//  953 void adc_interrupt(void)
//  954 #endif
//  955 {
        FUNCALL adc_interrupt, BACKGROUND_PROCESS_ON
        LOCFRAME CSTACK, 16, STACK
        FUNCALL adc_interrupt, per_sample_dsp
        LOCFRAME CSTACK, 16, STACK
        FUNCALL adc_interrupt, active_energy_pulse_start
        LOCFRAME CSTACK, 16, STACK
        FUNCALL adc_interrupt, active_energy_pulse_end
        LOCFRAME CSTACK, 16, STACK
        FUNCALL adc_interrupt, BACKGROUND_PROCESS_OFF
        LOCFRAME CSTACK, 16, STACK
        PUSH.W  R13
          CFI R13 Frame(CFA, -6)
          CFI CFA SP+6
        PUSH.W  R12
          CFI R12 Frame(CFA, -8)
          CFI CFA SP+8
        PUSH.W  R15
          CFI R15 Frame(CFA, -10)
          CFI CFA SP+10
        PUSH.W  R14
          CFI R14 Frame(CFA, -12)
          CFI CFA SP+12
        SUB.W   #0x4, SP
          CFI CFA SP+16
//  956     BACKGROUND_PROCESS_ON();
        CALL    #BACKGROUND_PROCESS_ON
//  957 #if defined(__HAS_SD_ADC__)
//  958     if (!ADC_VOLTAGE_PENDING(PHASE_1_VOLTAGE_ADC_CHANNEL))
        BIT.W   #0x4, &0x102
        JC      ??adc_interrupt_2
//  959     {
//  960         /* We do not have a complete set of samples yet, but we may need to pick
//  961            up some current values at this time */
//  962         if (ADC_CURRENT_PENDING(PHASE_1_CURRENT_ADC_CHANNEL))
        BIT.W   #0x4, &0x104
        JNC     ??adc_interrupt_1
//  963         {
//  964             adc_i_buffer[0] = ADC_CURRENT(PHASE_1_CURRENT_ADC_CHANNEL);
        BIC.W   #0x40, &0x104
        MOV.W   &0x112, R15
        SWPB    R15
        SXT     R15
        MOV.W   R15, 0x2(SP)
        BIS.W   #0x40, &0x104
        MOV.W   &0x112, R15
        RLA.W   R15
        RLA.W   R15
        RLA.W   R15
        MOV.W   R15, 0(SP)
        MOV.W   R15, &adc_i_buffer
        MOV.W   0x2(SP), &adc_i_buffer + 2
//  965             ADC_CURRENT_CLEAR(PHASE_1_CURRENT_ADC_CHANNEL);
        BIC.W   #0x4, &0x104
//  966         }
//  967     #if NUM_PHASES >= 2
//  968         if (ADC_CURRENT_PENDING(PHASE_2_CURRENT_ADC_CHANNEL))
//  969         {
//  970             adc_i_buffer[1] = ADC_CURRENT(PHASE_2_CURRENT_ADC_CHANNEL);
//  971             ADC_CURRENT_CLEAR(PHASE_2_CURRENT_ADC_CHANNEL);
//  972         }
//  973     #endif
//  974     #if NUM_PHASES >= 3
//  975         if (ADC_CURRENT_PENDING(PHASE_3_CURRENT_ADC_CHANNEL))
//  976         {
//  977             adc_i_buffer[2] = ADC_CURRENT(PHASE_3_CURRENT_ADC_CHANNEL);
//  978             ADC_CURRENT_CLEAR(PHASE_3_CURRENT_ADC_CHANNEL);
//  979         }
//  980     #endif
//  981     #if NUM_PHASES >= 4
//  982         if (ADC_CURRENT_PENDING(PHASE_4_CURRENT_ADC_CHANNEL))
//  983         {
//  984             adc_i_buffer[3] = ADC_CURRENT(PHASE_4_CURRENT_ADC_CHANNEL);
//  985             ADC_CURRENT_CLEAR(PHASE_4_CURRENT_ADC_CHANNEL);
//  986         }
//  987     #endif
//  988     #if NUM_PHASES >= 5
//  989         if (ADC_CURRENT_PENDING(PHASE_5_CURRENT_ADC_CHANNEL))
//  990         {
//  991             adc_i_buffer[4] = ADC_CURRENT(PHASE_5_CURRENT_ADC_CHANNEL);
//  992             ADC_CURRENT_CLEAR(PHASE_5_CURRENT_ADC_CHANNEL);
//  993         }
//  994     #endif
//  995     #if NUM_PHASES >= 6
//  996         if (ADC_CURRENT_PENDING(PHASE_6_CURRENT_ADC_CHANNEL))
//  997         {
//  998             adc_i_buffer[5] = ADC_CURRENT(PHASE_6_CURRENT_ADC_CHANNEL);
//  999             ADC_CURRENT_CLEAR(PHASE_6_CURRENT_ADC_CHANNEL);
// 1000         }
// 1001     #endif
// 1002     #if defined(NEUTRAL_MONITOR_SUPPORT)
// 1003         if (ADC_CURRENT_PENDING(NEUTRAL_CURRENT_ADC_CHANNEL))
// 1004         {
// 1005             adc_i_buffer[NUM_PHASES] = ADC_CURRENT(NEUTRAL_CURRENT_ADC_CHANNEL);
// 1006             ADC_CURRENT_CLEAR(NEUTRAL_CURRENT_ADC_CHANNEL);
// 1007         }
// 1008     #endif
// 1009         return;
        JMP     ??adc_interrupt_1
// 1010     }
// 1011     /* Voltage is available on all phases (guaranteed, as the voltage ADCs always run in sync). */
// 1012     adc_v_buffer[0] = ADC_VOLTAGE(PHASE_1_VOLTAGE_ADC_CHANNEL);
??adc_interrupt_2:
        MOV.W   &0x110, &adc_v_buffer
// 1013     ADC_VOLTAGE_CLEAR(PHASE_1_VOLTAGE_ADC_CHANNEL);
        BIC.W   #0x4, &0x102
// 1014     #if !defined(VOLTAGE_SIGNAL_IS_COMMON)
// 1015         #if NUM_PHASES >= 2
// 1016     adc_v_buffer[1] = ADC_VOLTAGE(PHASE_2_VOLTAGE_ADC_CHANNEL);
// 1017     ADC_VOLTAGE_CLEAR(PHASE_2_VOLTAGE_ADC_CHANNEL);
// 1018         #endif
// 1019         #if NUM_PHASES >= 3
// 1020     adc_v_buffer[2] = ADC_VOLTAGE(PHASE_3_VOLTAGE_ADC_CHANNEL);
// 1021     ADC_VOLTAGE_CLEAR(PHASE_3_VOLTAGE_ADC_CHANNEL);
// 1022         #endif
// 1023     #endif
// 1024     /* Pick up any current samples which may have occurred a little before the
// 1025        voltage sample, but not those which may have occurred just after the
// 1026        voltage sample. */
// 1027     if (working_data.phases[0].metrology.current[0].in_phase_correction.sd_preloaded_offset < 128  &&  ADC_CURRENT_PENDING(PHASE_1_CURRENT_ADC_CHANNEL))
        CMP.W   #0x80, &working_data + 330
        JGE     ??adc_interrupt_3
        BIT.W   #0x4, &0x104
        JNC     ??adc_interrupt_3
// 1028     {
// 1029         adc_i_buffer[0] = ADC_CURRENT(PHASE_1_CURRENT_ADC_CHANNEL);
        BIC.W   #0x40, &0x104
        MOV.W   &0x112, R15
        SWPB    R15
        SXT     R15
        MOV.W   R15, 0x2(SP)
        BIS.W   #0x40, &0x104
        MOV.W   &0x112, R15
        RLA.W   R15
        RLA.W   R15
        RLA.W   R15
        MOV.W   R15, 0(SP)
        MOV.W   R15, &adc_i_buffer
        MOV.W   0x2(SP), &adc_i_buffer + 2
// 1030         ADC_CURRENT_CLEAR(PHASE_1_CURRENT_ADC_CHANNEL);
        BIC.W   #0x4, &0x104
// 1031     }
// 1032     #if NUM_PHASES >= 2
// 1033     if (working_data.phases[1].metrology.current[0].in_phase_correction.sd_preloaded_offset < 128  &&  ADC_CURRENT_PENDING(PHASE_2_CURRENT_ADC_CHANNEL))
// 1034     {
// 1035         adc_i_buffer[1] = ADC_CURRENT(PHASE_2_CURRENT_ADC_CHANNEL);
// 1036         ADC_CURRENT_CLEAR(PHASE_2_CURRENT_ADC_CHANNEL);
// 1037     }
// 1038     #endif
// 1039     #if NUM_PHASES >= 3
// 1040     if (working_data.phases[2].metrology.current[0].in_phase_correction.sd_preloaded_offset < 128  &&  ADC_CURRENT_PENDING(PHASE_3_CURRENT_ADC_CHANNEL))
// 1041     {
// 1042         adc_i_buffer[2] = ADC_CURRENT(PHASE_3_CURRENT_ADC_CHANNEL);
// 1043         ADC_CURRENT_CLEAR(PHASE_3_CURRENT_ADC_CHANNEL);
// 1044     }
// 1045     #endif
// 1046     #if NUM_PHASES >= 4
// 1047     if (working_data.phases[3].metrology.current[0].in_phase_correction.sd_preloaded_offset < 128  &&  ADC_CURRENT_PENDING(PHASE_4_CURRENT_ADC_CHANNEL))
// 1048     {
// 1049         adc_i_buffer[3] = ADC_CURRENT(PHASE_4_CURRENT_ADC_CHANNEL);
// 1050         ADC_CURRENT_CLEAR(PHASE_4_CURRENT_ADC_CHANNEL);
// 1051     }
// 1052     #endif
// 1053     #if NUM_PHASES >= 5
// 1054     if (working_data.phases[4].metrology.current[0].in_phase_correction.sd_preloaded_offset < 128  &&  ADC_CURRENT_PENDING(PHASE_5_CURRENT_ADC_CHANNEL))
// 1055     {
// 1056         adc_i_buffer[4] = ADC_CURRENT(PHASE_5_CURRENT_ADC_CHANNEL);
// 1057         ADC_CURRENT_CLEAR(PHASE_5_CURRENT_ADC_CHANNEL);
// 1058     }
// 1059     #endif
// 1060     #if NUM_PHASES >= 6
// 1061     if (working_data.phases[5].metrology.current[0].in_phase_correction.sd_preloaded_offset < 128  &&  ADC_CURRENT_PENDING(PHASE_6_CURRENT_ADC_CHANNEL))
// 1062     {
// 1063         adc_i_buffer[5] = ADC_CURRENT(PHASE_6_CURRENT_ADC_CHANNEL);
// 1064         ADC_CURRENT_CLEAR(PHASE_6_CURRENT_ADC_CHANNEL);
// 1065     }
// 1066     #endif
// 1067     #if defined(NEUTRAL_MONITOR_SUPPORT)
// 1068         #if NUM_PHASES == 1
// 1069     if (working_data.phases[0].metrology.current[1].in_phase_correction.sd_preloaded_offset < 128  &&  ADC_CURRENT_PENDING(NEUTRAL_CURRENT_ADC_CHANNEL))
// 1070         #else
// 1071     if (working_data.neutral.metrology.in_phase_correction.sd_preloaded_offset < 128  &&  ADC_CURRENT_PENDING(NEUTRAL_CURRENT_ADC_CHANNEL))
// 1072         #endif
// 1073     {
// 1074         adc_i_buffer[NUM_PHASES] = ADC_CURRENT(NEUTRAL_CURRENT_ADC_CHANNEL);
// 1075         ADC_CURRENT_CLEAR(NEUTRAL_CURRENT_ADC_CHANNEL);
// 1076     }
// 1077     #endif
// 1078 #endif
// 1079 
// 1080 #if NUM_PHASES > 1  &&  defined(__MSP430_HAS_SD24_B3__)  &&  defined(__MSP430_HAS_ADC10_A__)
// 1081     ADC10CTL0 &= ~ADC10ENC;
// 1082     ADC10CTL0 |=  ADC10ENC;
// 1083     DMA0CTL &= ~DMAIFG;
// 1084 #endif
// 1085 
// 1086 #if defined (TEMPERATURE_SUPPORT) &&  !defined(__MSP430_HAS_ADC10_A__)
// 1087     if (ADC_TEMPERATURE_PENDING(TEMPERATURE_ADC_CHANNEL))
??adc_interrupt_3:
        BIT.W   #0x4, &0x106
        JNC     ??adc_interrupt_4
// 1088     {
// 1089         raw_temperature_from_adc += ((ADC_TEMPERATURE(TEMPERATURE_ADC_CHANNEL) - raw_temperature_from_adc) >> 3);
        MOV.W   &0x114, R15
        SUB.W   &raw_temperature_from_adc, R15
        RRA.W   R15
        RRA.W   R15
        RRA.W   R15
        ADD.W   R15, &raw_temperature_from_adc
// 1090         ADC_TEMPERATURE_CLEAR(TEMPERATURE_ADC_CHANNEL);
        BIC.W   #0x4, &0x106
// 1091     }
// 1092 #endif    
// 1093 
// 1094     /* We have a complete set of samples. Process them. */
// 1095     if (per_sample_dsp())
??adc_interrupt_4:
        CALL    #per_sample_dsp
        CMP.W   #0x0, R12
        JEQ     ??adc_interrupt_5
// 1096     {
// 1097 #if defined(__MSP430__)
// 1098         /* The foreground may be conserving power (e.g. in limp mode), so we need to kick it. */
// 1099         _BIC_SR_IRQ(LPM0_bits);
        BIC.W   #0x10, 0xc(SP)
// 1100 #endif
// 1101     }
// 1102 
// 1103 #if defined(ENERGY_PULSE_SUPPORT)  ||  defined(TOTAL_ENERGY_PULSE_SUPPORT)
// 1104     per_sample_energy_pulse_processing();
??adc_interrupt_5:
        MOV.W   &working_data + 20, R12
        MOV.W   &working_data + 22, R13
        MOV.W   R13, R14
        XOR.W   #0xffff, R14
        RLA.W   R14
        SUBC.W  R14, R14
        ADD.W   R12, &working_data + 44
        ADDC.W  R13, &working_data + 46
        ADDC.W  R14, &working_data + 48
        ADDC.W  R14, &working_data + 50
        CMP.W   &operating_parameter + 8, &working_data + 50
        JL      ??adc_interrupt_6
        JNE     ??adc_interrupt_7
        CMP.W   &operating_parameter + 6, &working_data + 48
        JNC     ??adc_interrupt_6
        JNE     ??adc_interrupt_7
        CMP.W   &operating_parameter + 4, &working_data + 46
        JNC     ??adc_interrupt_6
        JNE     ??adc_interrupt_7
        CMP.W   &operating_parameter + 2, &working_data + 44
        JNC     ??adc_interrupt_6
??adc_interrupt_7:
        MOV.W   #operating_parameter + 2, R15
        SUB.W   @R15+, &working_data + 44
        SUBC.W  @R15+, &working_data + 46
        SUBC.W  @R15+, &working_data + 48
        SUBC.W  @R15+, &working_data + 50
        MOV.B   &operating_parameter, &working_data + 52
        CALL    #active_energy_pulse_start
??adc_interrupt_6:
        CMP.B   #0x0, &working_data + 52
        JEQ     ??adc_interrupt_8
        ADD.B   #0xff, &working_data + 52
        JNE     ??adc_interrupt_8
        CALL    #active_energy_pulse_end
// 1105 #endif
// 1106 
// 1107 #if defined(__HAS_SD_ADC__)
// 1108     /* There may be some current samples available, which we need to pick up */
// 1109     if (ADC_CURRENT_PENDING(PHASE_1_CURRENT_ADC_CHANNEL))
??adc_interrupt_8:
        BIT.W   #0x4, &0x104
        JNC     ??adc_interrupt_9
// 1110     {
// 1111         adc_i_buffer[0] = ADC_CURRENT(PHASE_1_CURRENT_ADC_CHANNEL);
        BIC.W   #0x40, &0x104
        MOV.W   &0x112, R15
        SWPB    R15
        SXT     R15
        MOV.W   R15, 0x2(SP)
        BIS.W   #0x40, &0x104
        MOV.W   &0x112, R15
        RLA.W   R15
        RLA.W   R15
        RLA.W   R15
        MOV.W   R15, 0(SP)
        MOV.W   R15, &adc_i_buffer
        MOV.W   0x2(SP), &adc_i_buffer + 2
// 1112         ADC_CURRENT_CLEAR(PHASE_1_CURRENT_ADC_CHANNEL);
        BIC.W   #0x4, &0x104
// 1113     }
// 1114     #if NUM_PHASES >= 2
// 1115     if (ADC_CURRENT_PENDING(PHASE_2_CURRENT_ADC_CHANNEL))
// 1116     {
// 1117         adc_i_buffer[1] = ADC_CURRENT(PHASE_2_CURRENT_ADC_CHANNEL);
// 1118         ADC_CURRENT_CLEAR(PHASE_2_CURRENT_ADC_CHANNEL);
// 1119     }
// 1120     #endif
// 1121     #if NUM_PHASES >= 3
// 1122     if (ADC_CURRENT_PENDING(PHASE_3_CURRENT_ADC_CHANNEL))
// 1123     {
// 1124         adc_i_buffer[2] = ADC_CURRENT(PHASE_3_CURRENT_ADC_CHANNEL);
// 1125         ADC_CURRENT_CLEAR(PHASE_3_CURRENT_ADC_CHANNEL);
// 1126     }
// 1127     #endif
// 1128     #if NUM_PHASES >= 4
// 1129     if (ADC_CURRENT_PENDING(PHASE_4_CURRENT_ADC_CHANNEL))
// 1130     {
// 1131         adc_i_buffer[3] = ADC_CURRENT(PHASE_4_CURRENT_ADC_CHANNEL);
// 1132         ADC_CURRENT_CLEAR(PHASE_4_CURRENT_ADC_CHANNEL);
// 1133     }
// 1134     #endif
// 1135     #if NUM_PHASES >= 5
// 1136     if (ADC_CURRENT_PENDING(PHASE_5_CURRENT_ADC_CHANNEL))
// 1137     {
// 1138         adc_i_buffer[4] = ADC_CURRENT(PHASE_5_CURRENT_ADC_CHANNEL);
// 1139         ADC_CURRENT_CLEAR(PHASE_5_CURRENT_ADC_CHANNEL);
// 1140     }
// 1141     #endif
// 1142     #if NUM_PHASES >= 6
// 1143     if (ADC_CURRENT_PENDING(PHASE_6_CURRENT_ADC_CHANNEL))
// 1144     {
// 1145         adc_i_buffer[5] = ADC_CURRENT(PHASE_6_CURRENT_ADC_CHANNEL);
// 1146         ADC_CURRENT_CLEAR(PHASE_6_CURRENT_ADC_CHANNEL);
// 1147     }
// 1148     #endif
// 1149     #if defined(NEUTRAL_MONITOR_SUPPORT)
// 1150     if (ADC_CURRENT_PENDING(NEUTRAL_CURRENT_ADC_CHANNEL))
// 1151     {
// 1152         adc_i_buffer[NUM_PHASES] = ADC_CURRENT(NEUTRAL_CURRENT_ADC_CHANNEL);
// 1153         ADC_CURRENT_CLEAR(NEUTRAL_CURRENT_ADC_CHANNEL);
// 1154     }
// 1155     #endif
// 1156 #endif
// 1157 
// 1158     custom_adc_interrupt();
// 1159     BACKGROUND_PROCESS_OFF ();
??adc_interrupt_9:
        CALL    #BACKGROUND_PROCESS_OFF
// 1160 }
??adc_interrupt_1:
        ADD.W   #0x4, SP
          CFI CFA SP+12
        POP.W   R14
          CFI R14 SameValue
          CFI CFA SP+10
        POP.W   R15
          CFI R15 SameValue
          CFI CFA SP+8
        POP.W   R12
          CFI R12 SameValue
          CFI CFA SP+6
        POP.W   R13
          CFI R13 SameValue
          CFI CFA SP+4
        RETI
          CFI EndBlock cfiBlock3
        REQUIRE SD24CCTL2
        REQUIRE SD24MEM2
        REQUIRE SD24CCTL0
        REQUIRE SD24MEM0
        REQUIRE SD24CCTL1
        REQUIRE SD24MEM1

        COMMON INTVEC:CONST:ROOT(1)
        ORG 14
`??adc_interrupt??INTVEC 14`:
        DC16    adc_interrupt

        RSEG CODE:CODE:REORDER:NOROOT(1)
?setjmp_save_r4:
        REQUIRE ?setjmp_r4
        REQUIRE ?longjmp_r4

        RSEG CODE:CODE:REORDER:NOROOT(1)
?setjmp_save_r5:
        REQUIRE ?setjmp_r5
        REQUIRE ?longjmp_r5

        END
// 1161 
// 1162 #if defined(__MSP430__)  &&  defined(__HAS_SD_ADC__)  &&  NUM_PHASES == 1  &&  defined(LIMP_MODE_SUPPORT)
// 1163 /* Interrupt to trigger the SD16 ADC in limp mode */
// 1164 #if defined(TIMER0_A0_VECTOR)
// 1165 ISR(TIMER0_A0, limp_trigger_interrupt)
// 1166 #else
// 1167 ISR(TIMERA0, limp_trigger_interrupt)
// 1168 #endif
// 1169 {
// 1170     /* Trigger the ADC to perform a single conversion from all inputs. */
// 1171     sd_xxxx_reg(SD_PRE_, PHASE_1_VOLTAGE_ADC_CHANNEL) = 0;
// 1172     sd_xxxx_reg(SD_PRE_, PHASE_1_CURRENT_ADC_CHANNEL) = 0;
// 1173     #if defined(NEUTRAL_MONITOR_SUPPORT)
// 1174     sd_xxxx_reg(SD_PRE_, NEUTRAL_CURRENT_ADC_CHANNEL) = 0;
// 1175     #endif
// 1176     SD_CCTL_TRIGGER |= SD_SC;
// 1177 }
// 1178 #endif
// 1179 
// 1180 #if defined(__MSP430__)  &&  defined(__MSP430_HAS_ADC10_A__)
// 1181 /* Interrupt to handle the ADC10A in the 6xx family devices. */
// 1182 ISR(ADC10, adc10_interrupt)
// 1183 {
// 1184     int16_t corrected;
// 1185 
// 1186     if (operating_mode == OPERATING_MODE_NORMAL)
// 1187     {
// 1188     #if defined(TEMPERATURE_SUPPORT)
// 1189         if ((ADC10MCTL0 & ADC10INCH_15) == ADC10INCH_10)
// 1190         {
// 1191             corrected = ADC10MEM0;
// 1192             raw_temperature_from_adc += corrected - (raw_temperature_from_adc >> 3);
// 1193         }
// 1194     #endif
// 1195     #if defined(VCC_MEASURE_SUPPORT)
// 1196         if ((ADC10MCTL0 & ADC10INCH_15) == ADC10INCH_11)
// 1197             vcc = ADC10MEM0;
// 1198     #endif
// 1199     }
// 1200     /* Clear ADC10IFG by reading ADC10MEM0 */
// 1201     ADC10IFG = 0x00;
// 1202 }
// 1203 #endif
// 
// 2 024 bytes in segment CODE
//    12 bytes in segment DATA16_AN
//    20 bytes in segment DATA16_Z
//     2 bytes in segment INTVEC
// 
// 2 024 bytes of CODE  memory
//     0 bytes of CONST memory (+  2 bytes shared)
//    20 bytes of DATA  memory (+ 12 bytes shared)
//
//Errors: none
//Warnings: none
