###############################################################################
#                                                                             #
# IAR C/C++ Compiler V5.52.1.50724/W32 for MSP430       07/Jul/2014  17:16:18 #
# Copyright 1996-2013 IAR Systems AB.                                         #
#                                                                             #
#    __rt_version  =  3                                                       #
#    __double_size =  32                                                      #
#    __reg_r4      =  free                                                    #
#    __reg_r5      =  free                                                    #
#    __pic         =  no                                                      #
#    __core        =  430                                                     #
#    Source file   =  C:\Users\a0283112\Desktop\Submeter i2040                #
#                     8k_DC_THD_AUTO_OSR_IAR5.5\emeter-metrology\src\metrolog #
#                     y-foreground.c                                          #
#    Command line  =  "C:\Users\a0283112\Desktop\Submeter i2040               #
#                     8k_DC_THD_AUTO_OSR_IAR5.5\emeter-metrology\src\metrolog #
#                     y-foreground.c" -D __MSP430__ -lCN                      #
#                     "C:\Users\a0283112\Desktop\Submeter i2040               #
#                     8k_DC_THD_AUTO_OSR_IAR5.5\emeter-metrology\emeter-metro #
#                     logy-i2041\Debug\List\" -lA                             #
#                     "C:\Users\a0283112\Desktop\Submeter i2040               #
#                     8k_DC_THD_AUTO_OSR_IAR5.5\emeter-metrology\emeter-metro #
#                     logy-i2041\Debug\List\" -o                              #
#                     "C:\Users\a0283112\Desktop\Submeter i2040               #
#                     8k_DC_THD_AUTO_OSR_IAR5.5\emeter-metrology\emeter-metro #
#                     logy-i2041\Debug\Obj\" --debug -D__MSP430I2041__ -e     #
#                     --double=32 --dlib_config "C:\Program Files (x86)\IAR   #
#                     Systems\Embedded Workbench                              #
#                     6.5_0\430\LIB\DLIB\dl430fn.h" --library_module -I       #
#                     "C:\Users\a0283112\Desktop\Submeter i2040               #
#                     8k_DC_THD_AUTO_OSR_IAR5.5\emeter-metrology\emeter-metro #
#                     logy-i2041/../../emeter-toolkit/include\" -I            #
#                     "C:\Users\a0283112\Desktop\Submeter i2040               #
#                     8k_DC_THD_AUTO_OSR_IAR5.5\emeter-metrology\emeter-metro #
#                     logy-i2041/../include\" -I                              #
#                     "C:\Users\a0283112\Desktop\Submeter i2040               #
#                     8k_DC_THD_AUTO_OSR_IAR5.5\emeter-metrology\emeter-metro #
#                     logy-i2041\" -Ohs --multiplier=16s                      #
#    List file     =  C:\Users\a0283112\Desktop\Submeter i2040                #
#                     8k_DC_THD_AUTO_OSR_IAR5.5\emeter-metrology\emeter-metro #
#                     logy-i2041\Debug\List\metrology-foreground.lst          #
#    Object file   =  C:\Users\a0283112\Desktop\Submeter i2040                #
#                     8k_DC_THD_AUTO_OSR_IAR5.5\emeter-metrology\emeter-metro #
#                     logy-i2041\Debug\Obj\metrology-foreground.r43           #
#                                                                             #
#                                                                             #
###############################################################################

C:\Users\a0283112\Desktop\Submeter i2040 8k_DC_THD_AUTO_OSR_IAR5.5\emeter-metrology\src\metrology-foreground.c
      1          /*******************************************************************************
      2           *  metrology-foreground.c -
      3           *
      4           *  Copyright (C) 2011 Texas Instruments Incorporated - http://www.ti.com/
      5           * 
      6           *  Redistribution and use in source and binary forms, with or without 
      7           *  modification, are permitted provided that the following conditions 
      8           *  are met:
      9           *
     10           *    Redistributions of source code must retain the above copyright 
     11           *    notice, this list of conditions and the following disclaimer.
     12           *
     13           *    Redistributions in binary form must reproduce the above copyright
     14           *    notice, this list of conditions and the following disclaimer in the 
     15           *    documentation and/or other materials provided with the   
     16           *    distribution.
     17           *
     18           *    Neither the name of Texas Instruments Incorporated nor the names of
     19           *    its contributors may be used to endorse or promote products derived
     20           *    from this software without specific prior written permission.
     21           *
     22           *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
     23           *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
     24           *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
     25           *  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT 
     26           *  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, 
     27           *  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
     28           *  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
     29           *  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
     30           *  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
     31           *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
     32           *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
     33           *
     34           ******************************************************************************/
     35          
     36          /*! \file emeter-metrology.h */
     37          
     38          /*--------------------------------------------------------------------------
     39              MSP430 foreground (non-interrupt) routines for e-meters
     40          
     41              This software is appropriate for single phase and three phase e-meters
     42              using a voltage sensor plus a CT or shunt resistor current sensors, or
     43              a combination of a CT plus a shunt.
     44           
     45              Foreground process includes:
     46              -Using timer tick to wait
     47              -Calculating the power per channel
     48              -Determine if current channel needs scaling.
     49              -Determine if needs to be in low power modes.
     50              -Compensate reference from temperature sensor */
     51          
     52          #include <inttypes.h>
     53          #include <stdlib.h>
     54          #if !defined(__MSP430__)
     55          #include <stdio.h>
     56          #include <fcntl.h>
     57          #include <unistd.h>
     58          #endif
     59          #if defined(__GNUC__)
     60          #include <signal.h>
     61          #endif
     62          #include <string.h>
     63          
     64          #include <emeter-toolkit.h>

   \                                 In  segment DATA16_AN, at 0xb9
   \   unsigned char volatile SD24PRE1
   \                     SD24PRE1:
   \   000000                DS8 1
     65          
     66          #include "emeter-metrology.h"
     67          #include "metrology-structs.h"
     68          #include "metrology-nv-structs.h"
     69          
     70          #if NUM_PHASES == 1  &&  defined(NEUTRAL_MONITOR_SUPPORT)
     71          static const uint16_t current_overrange_masks[PER_PHASE_CURRENT_CHANNELS] = {PHASE_STATUS_I_OVERRANGE, PHASE_STATUS_I_NEUTRAL_OVERRANGE};
     72          #endif
     73          
     74          /* Meter status flag bits. */

   \                                 In  segment DATA16_Z, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
     75          uint16_t metrology_state;
   \                     metrology_state:
   \   000000                DS8 2
     76          
     77          /* Current operating mode - normal, limp, power down, etc. */

   \                                 In  segment DATA16_Z, align 1, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
     78          int8_t operating_mode;
   \                     operating_mode:
   \   000000                DS8 1
     79          #if defined(LIMP_MODE_SUPPORT)
     80          int normal_limp;
     81          #endif
     82          
     83          #if defined(WIRE_RESISTANCE_COMPENSATE)
     84          extern uint32_t resistance_scaling;
     85          #endif
     86          
     87          #if defined(CAPACITOR_COMPENSATE_ON)
     88          extern uint32_t capacitance_scaling;
     89          #endif
     90          
     91          /* The main per-phase working parameter structure */

   \                                 In  segment DATA16_Z, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
     92          struct metrology_data_s working_data;
   \                     working_data:
   \   000000                DS8 362
     93          
     94          static __inline__ int32_t abs32(int32_t x)
     95          {
     96              return (x < 0)  ?  -x  :  x;
     97          }
     98          

   \                                 In  segment CODE, align 2
     99          void set_phase_correction(struct phase_correction_s *s, int correction)
   \                     set_phase_correction:
    100          {
    101              correction += 128;
   \   000000   3D508000     ADD.W   #0x80, R13
    102              s->step = I_HISTORY_STEPS + (correction >> 8);
   \   000004   0F4D         MOV.W   R13, R15
   \   000006   8F10         SWPB    R15
   \   000008   8F11         SXT     R15
   \   00000A   2F53         ADD.W   #0x2, R15
   \   00000C   8C4F0000     MOV.W   R15, 0(R12)
    103              correction = 127 - ((correction & 0xFF) >> 1);
   \   000010   3E407F00     MOV.W   #0x7f, R14
   \   000014   4D11         RRA.B   R13
   \   000016   4F4D         MOV.B   R13, R15
   \   000018   8F11         SXT     R15
   \   00001A   0FFE         AND.W   R14, R15
   \   00001C   0D4E         MOV.W   R14, R13
   \   00001E   0D8F         SUB.W   R15, R13
    104              s->fir_beta = fir_coeffs[correction][0];
   \   000020   0D5D         RLA.W   R13
   \   000022   0D5D         RLA.W   R13
   \   000024   9C4D....0200 MOV.W   fir_coeffs(R13), 0x2(R12)
    105              s->fir_gain = fir_coeffs[correction][1];
   \   00002A   9C4D....0400 MOV.W   fir_coeffs + 2(R13), 0x4(R12)
    106          }
   \   000030   3041         RET
    107          
    108          #if defined(DYNAMIC_PHASE_CORRECTION_SUPPORT)
    109          static void set_phase_gain_correction(struct phase_correction_s *s, int correction, int gain)
    110          {
    111              correction += 128;
    112              s->step = I_HISTORY_STEPS + (correction >> 8);
    113              correction = 127 - ((correction & 0xFF) >> 1);
    114              s->fir_beta = fir_coeffs[correction][0];
    115              s->fir_gain = q1_15_mul(gain, fir_coeffs[correction][1]);
    116          }
    117          #endif
    118          
    119          #if defined(__HAS_SD_ADC__)

   \                                 In  segment CODE, align 2
    120          void set_sd_phase_correction(struct phase_correction_sd_s *s, int phx, int correction)
   \                     set_sd_phase_correction:
    121          {
    122          #if defined(__MSP430_HAS_SD24_B__)
    123              uint16_t bump;
    124              #if defined(__IAR_SYSTEMS_ICC__)
    125              static unsigned short int volatile * const sd_locations[NUM_CURRENT_CHANNELS] =
    126              #else
    127              static unsigned int volatile * const sd_locations[NUM_CURRENT_CHANNELS] =
    128              #endif
    129          #else
    130              uint8_t bump;
    131              static unsigned char volatile * const sd_locations[NUM_CURRENT_CHANNELS] =
    132          #endif
    133              {
    134                  &sd_xxxx_reg(SD_PRE_, PHASE_1_CURRENT_ADC_CHANNEL),
    135              #if NUM_PHASES >= 2
    136                  &sd_xxxx_reg(SD_PRE_, PHASE_2_CURRENT_ADC_CHANNEL),
    137              #endif
    138              #if NUM_PHASES >= 3
    139                  &sd_xxxx_reg(SD_PRE_, PHASE_3_CURRENT_ADC_CHANNEL),
    140              #endif
    141              #if NUM_PHASES >= 4
    142                  &sd_xxxx_reg(SD_PRE_, PHASE_4_CURRENT_ADC_CHANNEL),
    143              #endif
    144              #if NUM_PHASES >= 5
    145                  &sd_xxxx_reg(SD_PRE_, PHASE_5_CURRENT_ADC_CHANNEL),
    146              #endif
    147              #if NUM_PHASES >= 6
    148                  &sd_xxxx_reg(SD_PRE_, PHASE_6_CURRENT_ADC_CHANNEL),
    149              #endif
    150              #if defined(NEUTRAL_MONITOR_SUPPORT)
    151                  &sd_xxxx_reg(SD_PRE_, NEUTRAL_CURRENT_ADC_CHANNEL),
    152              #endif
    153              };
    154          
    155              /* Only try to nudge the converter's timing when in normal operating mode. */
    156              if (operating_mode == OPERATING_MODE_NORMAL)
   \   000000   C293....     CMP.B   #0x0, &operating_mode
   \   000004   0920         JNE     ??set_sd_phase_correction_0
    157              {
    158                  if ((bump = (s->sd_preloaded_offset - correction) & 0xFF))
   \   000006   5F4C0200     MOV.B   0x2(R12), R15
   \   00000A   4F8E         SUB.B   R14, R15
   \   00000C   0524         JEQ     ??set_sd_phase_correction_0
    159                      *sd_locations[phx] = bump;
   \   00000E   0D5D         RLA.W   R13
   \   000010   1D4D....     MOV.W   ??sd_locations(R13), R13
   \   000014   CD4F0000     MOV.B   R15, 0(R13)
    160              }
    161              /* Always store the required correction. */
    162              s->step = I_HISTORY_STEPS - (correction >> 8);
   \                     ??set_sd_phase_correction_0:
   \   000018   2D43         MOV.W   #0x2, R13
   \   00001A   0F4E         MOV.W   R14, R15
   \   00001C   8F10         SWPB    R15
   \   00001E   8F11         SXT     R15
   \   000020   0D8F         SUB.W   R15, R13
   \   000022   8C4D0000     MOV.W   R13, 0(R12)
    163              s->sd_preloaded_offset = correction & 0xFF;
   \   000026   7EF3         AND.B   #0xff, R14
   \   000028   8C4E0200     MOV.W   R14, 0x2(R12)
    164          }
   \   00002C   3041         RET

   \                                 In  segment DATA16_C, align 2, align-sorted
   \                     ??sd_locations:
   \   000000   ....         DC16 SD24PRE1
    165          #endif
    166          
    167          #if defined(PHASE_UNBALANCED_DETECTION_SUPPORT)
    168          static int32_t test_phase_balance(int32_t live_signal, int32_t neutral_signal, const int32_t thresholds[2])
    169          {
    170              int permitted_imbalance_fraction;
    171          
    172              /* This may be testing between two currents, or between two powers. In normal mode it
    173                 is testing between two power readings. In limp mode it is testing between two
    174                 current readings. */
    175          
    176              /* If both signals are very small, it is not practical to make a meaningful assessment of phase
    177                 balance, so we just declare that balance is OK. */
    178              if (live_signal <= thresholds[0]  &&  neutral_signal <= thresholds[0])
    179              {
    180                  /* Clear the unbalanced condition. */
    181                  phase->metrology.current_unbalanced_persistence_check = 0;
    182                  phase->status &= ~(PHASE_STATUS_UNBALANCED | PHASE_STATUS_CURRENT_FROM_NEUTRAL);
    183              }
    184          
    185              /* See which signal is bigger, with some tolerance built in.
    186              
    187                 If the signal measured from the neutral is more than some fraction different from
    188                 the signal measured from the live there is something wrong (maybe fraudulent tampering,
    189                 or just something faulty). In this case we use the signal measured from the
    190                 channel with the higher signal. When the channel is reasonably balanced, we use
    191                 the signal from the live lead.
    192          
    193                 If the signals are big we can use a fairly small fractional difference safely. If we
    194                 use the same small fraction for small signals we are likely to have false detection
    195                 problems under high EMI and transient conditions, so we use a larger fraction. For efficent
    196                 computation we limit ourselves to "power of 2" type fractions - 1/2, 1/4, 1/8, 1/16, 1/32, etc.
    197          
    198                 Balance assessments are persistence checked, to further reduce the chances of EMI and transient
    199                 conditions causing false detections. */
    200              if (live_signal <= thresholds[1]  &&  neutral_signal <= thresholds[1])
    201                  permitted_imbalance_fraction = PHASE_UNBALANCED_RELAXED_FRACTION;
    202              else
    203                  permitted_imbalance_fraction = PHASE_UNBALANCED_PERMITTED_FRACTION;
    204          
    205              if ((live_signal - (live_signal >> permitted_imbalance_fraction)) > neutral_signal
    206                  ||
    207                  (neutral_signal - (neutral_signal >> permitted_imbalance_fraction)) > live_signal)
    208              {
    209                  /* The phase appears UNBALANCED at this instant, but we need to persistence check to avoid
    210                     false detection on noise spikes, EMI hits, etc. */
    211                  if ((phase->status & PHASE_STATUS_UNBALANCED))
    212                  {
    213                      phase->metrology.current_unbalanced_persistence_check = 0;
    214                  }
    215                  else
    216                  {
    217                      if (++phase->metrology.current_unbalanced_persistence_check >= PHASE_UNBALANCED_PERSISTENCE_CHECK)
    218                      {
    219                          /* Things look genuinely unbalanced. */
    220                          phase->metrology.current_unbalanced_persistence_check = 0;
    221                          phase->status |= PHASE_STATUS_UNBALANCED;
    222                          if (neutral_signal > live_signal)
    223                              phase->status |= PHASE_STATUS_CURRENT_FROM_NEUTRAL;
    224                          else
    225                              phase->status &= ~PHASE_STATUS_CURRENT_FROM_NEUTRAL;
    226                      }
    227                  }
    228              }
    229              else
    230              {
    231                  /* The phase appears BALANCED at this instant, but we need to persistence check to avoid
    232                     false detection on noise spikes, EMI hits, etc. */
    233                  if ((phase->status & PHASE_STATUS_UNBALANCED))
    234                  {
    235                      if (--phase->metrology.current_unbalanced_persistence_check <= -PHASE_UNBALANCED_PERSISTENCE_CHECK)
    236                      {
    237                          /* Things look genuinely balanced. */
    238                          phase->metrology.current_unbalanced_persistence_check = 0;
    239                          phase->status &= ~(PHASE_STATUS_UNBALANCED | PHASE_STATUS_CURRENT_FROM_NEUTRAL);
    240                      }
    241                  }
    242                  else
    243                  {
    244                      phase->metrology.current_unbalanced_persistence_check = 0;
    245                  }
    246              }
    247          
    248              if ((phase->status & PHASE_STATUS_CURRENT_FROM_NEUTRAL))
    249                  return  neutral_signal;
    250              return live_signal;
    251          }
    252          #endif
    253          
    254          #if defined(MAINS_FREQUENCY_SUPPORT)
    255          #if NUM_PHASES == 1
    256          static int16_t evaluate_mains_frequency(void)
    257          #else
    258          static int16_t evaluate_mains_frequency(struct phase_parms_s *phase, struct phase_calibration_data_s const *phase_cal)
    259          #endif
    260          {
    261              uint32_t x;
    262              #if NUM_PHASES == 1  &&  defined(NEUTRAL_MONITOR_SUPPORT)
    263              int ch;
    264              #endif
    265          
    266              /* Calculate the mains frequency in 1/100Hz increments, based on the mains
    267                 period assessment from the background activity. */
    268          
    269              #if defined(LIMP_MODE_SUPPORT)
    270              if (operating_mode == OPERATING_MODE_LIMP)
    271              {
    272                  /* In limp mode there is no voltage waveform, so we get the frequency from
    273                     the current in the active lead. This may fail to measure frequency
    274                     correctly for very low currents, and very distorted current waveforms. */
    275                  #if NUM_PHASES == 1  &&  defined(NEUTRAL_MONITOR_SUPPORT)
    276                  ch = (phase->status & PHASE_STATUS_CURRENT_FROM_NEUTRAL)  ?  1  :  0;
    277                  #endif
    278          
    279                  x = phase->metrology.current[ch].mains_period;
    280              }
    281              else
    282              #endif
    283              {
    284                  /* Normally we get the mains frequency from the voltage. Voltage is always
    285                     present, and is not subject to the same level of distortion as the current
    286                     waveform with difficult loads. */
    287              #if defined(REACTIVE_POWER_BY_QUADRATURE_SUPPORT)
    288                  /* We have a whole cycle period in the upper 16 bits, but we want the delay for 90 degrees, so we shift 2
    289                     extra bits for that. */
    290                  x = (phase->metrology.mains_period >> 18);
    291                  #if defined(__HAS_SD_ADC__)
    292                  set_phase_correction(&phase->metrology.current[0].quadrature_correction, x);
    293                      #if NUM_PHASES == 1  &&  defined(NEUTRAL_MONITOR_SUPPORT)
    294                  set_phase_correction(&phase->metrology.current[1].quadrature_correction, x);
    295                      #endif
    296                  #else
    297                  set_phase_correction(&phase->metrology.current[0].quadrature_correction, x + phase_cal->current[0].phase_correction);
    298                      #if NUM_PHASES == 1  &&  defined(NEUTRAL_MONITOR_SUPPORT)
    299                  set_phase_correction(&phase->metrology.current[1].quadrature_correction, x + phase_cal->current[1].phase_correction);
    300                      #endif
    301                  #endif
    302              #endif
    303                  x = phase->metrology.mains_period;
    304              }
    305              #if defined(FUNDAMENTAL_POWER_SUPPORT)
    306              phase->metrology.pure_phase_rate = (int64_t) 0x100000000000000LL/(int64_t) x;
    307              #endif
    308              x = (uint32_t) SAMPLES_PER_10_SECONDS*256L*10L/(x >> 16);
    309              return x;
    310          }
    311          #endif
    312          
    313          #if defined(VRMS_SUPPORT)
    314              #if NUM_PHASES == 1

   \                                 In  segment CODE, align 2
    315          static rms_voltage_t evaluate_rms_voltage(void)
   \                     evaluate_rms_voltage:
    316              #else
    317          static rms_voltage_t evaluate_rms_voltage(struct phase_parms_s *phase, struct phase_calibration_data_s const *phase_cal)
    318              #endif
    319          {
    320              rms_voltage_t x;
    321              int32_t tmp;
    322              int dp;
    323          
    324              if ((phase->status & PHASE_STATUS_V_OVERRANGE))
   \   000000   B2B01000.... BIT.W   #0x10, &working_data + 360
   \   000006   0428         JNC     ??evaluate_rms_voltage_0
    325                  return RMS_VOLTAGE_OVERRANGE;
   \   000008   3C43         MOV.W   #0xffff, R12
   \   00000A   3D40FF7F     MOV.W   #0x7fff, R13
   \   00000E   3041         RET
    326          
    327              dp = phase->metrology.dp_set;
   \                     ??evaluate_rms_voltage_0:
   \   000010   5C42....     MOV.B   &working_data + 359, R12
   \   000014   8C11         SXT     R12
    328              /* The accumulated voltage is 16bitsx16bits*(~4096). So its a 43/44 bit number.
    329                 After dividing by (~4096) its a 31/32 bit number.
    330                 After we take the square root of the 32 bit number its a 16.16 bit number. */
    331              tmp = div_ac_voltage(phase->metrology.dot_prod[dp].V_sq, phase->metrology.dot_prod[dp].sample_count);
   \   000016   0C5C         RLA.W   R12
   \   000018   0F4C         MOV.W   R12, R15
   \   00001A   0C5C         RLA.W   R12
   \   00001C   0F5C         ADD.W   R12, R15
   \   00001E   0C5C         RLA.W   R12
   \   000020   0C5F         ADD.W   R15, R12
   \   000022   1D4C....     MOV.W   working_data + 214(R12), R13
   \   000026   3C50....     ADD.W   #working_data + 202, R12
   \   00002A   B012....     CALL    #div48
    332              if (tmp < phase_cal->v_ac_offset)
   \   00002E   1D92....     CMP.W   &nv_parms + 24, R13
   \   000032   0438         JL      ??evaluate_rms_voltage_1
   \   000034   0620         JNE     ??evaluate_rms_voltage_2
   \   000036   1C92....     CMP.W   &nv_parms + 22, R12
   \   00003A   032C         JC      ??evaluate_rms_voltage_2
    333                  return 0;
   \                     ??evaluate_rms_voltage_1:
   \   00003C   0C43         MOV.W   #0x0, R12
   \   00003E   0D43         MOV.W   #0x0, R13
   \   000040   3041         RET
    334          
    335              /* The ac_offset removes the effect of the AWGN from the ADC front end. AWGN is orthogonal to everything but a true copy
    336                 of itself. This means means we need to subtract the ac_offset in a "Pythagoras" manner", while still squared. */
    337              x = isqrt32(tmp - phase_cal->v_ac_offset);
   \                     ??evaluate_rms_voltage_2:
   \   000042   1C82....     SUB.W   &nv_parms + 22, R12
   \   000046   1D72....     SUBC.W  &nv_parms + 24, R13
   \   00004A   B012....     CALL    #isqrt32
    338              /* If we multiply the 16.16 bit number by a 15 bit scaling factor we get a 31.16 bit number.
    339                 Dropping the last 16 bits gives us a */
    340              x = mul48u_32_16(x, phase_cal->V_rms_scale_factor[normal_limp]) >> 10;
    341          #if defined(TEMPERATURE_CORRECTION_SUPPORT)
    342              x = mul48u_32_16(x, working_data.temperature_correction.amplitude_factor);
    343          #endif
    344              return x;
   \   00004E   1E42....     MOV.W   &nv_parms + 26, R14
   \   000052   B012....     CALL    #mul48u_32_16
   \   000056   8C10         SWPB    R12
   \   000058   8D10         SWPB    R13
   \   00005A   4CED         XOR.B   R13, R12
   \   00005C   0CED         XOR.W   R13, R12
   \   00005E   7DF3         AND.B   #0xff, R13
   \   000060   0D11         RRA.W   R13
   \   000062   0C10         RRC.W   R12
   \   000064   0D11         RRA.W   R13
   \   000066   0C10         RRC.W   R12
   \   000068   3041         RET
    345          }
    346          #endif
    347          
    348          #if defined(FUNDAMENTAL_VRMS_SUPPORT)
    349              #if NUM_PHASES == 1

   \                                 In  segment CODE, align 2
    350          static rms_voltage_t evaluate_fundamental_rms_voltage(void)
   \                     evaluate_fundamental_rms_voltage:
    351              #else
    352          static rms_voltage_t evaluate_fundamental_rms_voltage(struct phase_parms_s *phase, struct phase_calibration_data_s const *phase_cal)
    353              #endif
    354          {
   \   000000   0A12         PUSH.W  R10
   \   000002   0B12         PUSH.W  R11
    355              int16_t i;
    356              rms_voltage_t x;
    357              int8_t dp;
    358          
    359              if ((phase->status & PHASE_STATUS_V_OVERRANGE))
   \   000004   B2B01000.... BIT.W   #0x10, &working_data + 360
   \   00000A   0428         JNC     ??evaluate_fundamental_rms_voltage_0
    360                  return RMS_VOLTAGE_OVERRANGE;
   \   00000C   3C43         MOV.W   #0xffff, R12
   \   00000E   3D40FF7F     MOV.W   #0x7fff, R13
   \   000012   263C         JMP     ??evaluate_fundamental_rms_voltage_1
    361          
    362              dp = phase->metrology.dp_set;
   \                     ??evaluate_fundamental_rms_voltage_0:
   \   000014   5C42....     MOV.B   &working_data + 359, R12
    363              /* Scale by the voltage gain */
    364              x = div_ac_voltage(phase->metrology.dot_prod[dp].V_fundamental, phase->metrology.dot_prod[dp].sample_count);
   \   000018   8C11         SXT     R12
   \   00001A   0C5C         RLA.W   R12
   \   00001C   0F4C         MOV.W   R12, R15
   \   00001E   0C5C         RLA.W   R12
   \   000020   0F5C         ADD.W   R12, R15
   \   000022   0C5C         RLA.W   R12
   \   000024   0C5F         ADD.W   R15, R12
   \   000026   1D4C....     MOV.W   working_data + 214(R12), R13
   \   00002A   3C50....     ADD.W   #working_data + 208, R12
   \   00002E   B012....     CALL    #div48
   \   000032   0A4C         MOV.W   R12, R10
   \   000034   0B4D         MOV.W   R13, R11
    365              /* A negative value indicates the voltage correlation is completely unsynced. */
    366              if (x < 0)
   \   000036   0D93         CMP.W   #0x0, R13
   \   000038   0334         JGE     ??evaluate_fundamental_rms_voltage_2
    367                  return 0;
   \   00003A   0C43         MOV.W   #0x0, R12
   \   00003C   0D43         MOV.W   #0x0, R13
   \   00003E   103C         JMP     ??evaluate_fundamental_rms_voltage_1
    368          
    369              /* Scale by 1/sqrt(2). Nudge the scaling factor up a little, to avoid losses due to rounding. */
    370              i = q1_15_mul(phase_cal->V_rms_scale_factor[normal_limp], 23171 + 3);
   \                     ??evaluate_fundamental_rms_voltage_2:
   \   000040   3D40865A     MOV.W   #0x5a86, R13
   \   000044   1C42....     MOV.W   &nv_parms + 26, R12
   \   000048   B012....     CALL    #q1_15_mul
   \   00004C   0E4C         MOV.W   R12, R14
    371              /* Scale by the voltage calibration factor */
    372              x = mul48u_32_16(x, i) >> 8;
    373          #if defined(TEMPERATURE_CORRECTION_SUPPORT)
    374              x = mul48u_32_16(x, working_data.temperature_correction.amplitude_factor);
    375          #endif
    376              return x;
   \   00004E   0C4A         MOV.W   R10, R12
   \   000050   0D4B         MOV.W   R11, R13
   \   000052   B012....     CALL    #mul48u_32_16
   \   000056   8C10         SWPB    R12
   \   000058   8D10         SWPB    R13
   \   00005A   4CED         XOR.B   R13, R12
   \   00005C   0CED         XOR.W   R13, R12
   \   00005E   7DF3         AND.B   #0xff, R13
   \                     ??evaluate_fundamental_rms_voltage_1:
   \   000060   3B41         POP.W   R11
   \   000062   3A41         POP.W   R10
   \   000064   3041         RET
    377          }
    378          #endif
    379          
    380          #if defined(VOLTAGE_THD_SUPPORT)
    381              #if NUM_PHASES == 1

   \                                 In  segment CODE, align 2
    382          static thd_t evaluate_voltage_thd(void)
   \                     evaluate_voltage_thd:
    383              #else
    384          static thd_t evaluate_voltage_thd(struct phase_parms_s *phase, struct phase_calibration_data_s const *phase_cal)
    385              #endif
    386          {
   \   000000   0A12         PUSH.W  R10
   \   000002   0B12         PUSH.W  R11
   \   000004   0812         PUSH.W  R8
   \   000006   0912         PUSH.W  R9
   \   000008   0612         PUSH.W  R6
   \   00000A   0712         PUSH.W  R7
   \   00000C   0412         PUSH.W  R4
   \   00000E   0512         PUSH.W  R5
   \   000010   9292........ CMP.W   &working_data + 6, &working_data + 2
   \   000016   5038         JL      ??evaluate_voltage_thd_1
   \   000018   0420         JNE     ??evaluate_voltage_thd_2
   \   00001A   9292........ CMP.W   &working_data + 4, &working_data
   \   000020   4B28         JNC     ??evaluate_voltage_thd_1
    387              int64_t x;
    388              int64_t y;
    389              int64_t z;
    390          
    391          #if defined(VOLTAGE_THD_MEASUREMENT_CUTOFF)
    392              /* Don't evaluate the voltage THD if the voltage is too small, as we can get some REALLY low accuracy answers
    393                 from the weak signals. */
    394              if (phase->readings.V_rms < VOLTAGE_THD_MEASUREMENT_CUTOFF)
    395                  return 0;
    396          #endif
    397          
    398              /* Avoid silly results if the fundamental appears to exceed the total, either transiently or
    399                 due to rounding issues. */
    400              if (phase->readings.fundamental_V_rms > phase->readings.V_rms)
    401                  return 0;
    402              x = (int64_t) phase->readings.fundamental_V_rms*phase->readings.fundamental_V_rms;
   \                     ??evaluate_voltage_thd_2:
   \   000022   1842....     MOV.W   &working_data + 4, R8
   \   000026   1942....     MOV.W   &working_data + 6, R9
   \   00002A   0A49         MOV.W   R9, R10
   \   00002C   3AE3         XOR.W   #0xffff, R10
   \   00002E   0A5A         RLA.W   R10
   \   000030   0A7A         SUBC.W  R10, R10
   \   000032   0B4A         MOV.W   R10, R11
   \   000034   0C48         MOV.W   R8, R12
   \   000036   0D49         MOV.W   R9, R13
   \   000038   0E4A         MOV.W   R10, R14
   \   00003A   0F4A         MOV.W   R10, R15
   \   00003C   B012....     CALL    #_Mul64i
   \   000040   044C         MOV.W   R12, R4
   \   000042   054D         MOV.W   R13, R5
   \   000044   064E         MOV.W   R14, R6
   \   000046   074F         MOV.W   R15, R7
    403              y = (int64_t) phase->readings.V_rms*phase->readings.V_rms;
   \   000048   1842....     MOV.W   &working_data, R8
   \   00004C   1942....     MOV.W   &working_data + 2, R9
   \   000050   0A49         MOV.W   R9, R10
   \   000052   3AE3         XOR.W   #0xffff, R10
   \   000054   0A5A         RLA.W   R10
   \   000056   0A7A         SUBC.W  R10, R10
   \   000058   0B4A         MOV.W   R10, R11
   \   00005A   0C48         MOV.W   R8, R12
   \   00005C   0D49         MOV.W   R9, R13
   \   00005E   0E4A         MOV.W   R10, R14
   \   000060   0F4A         MOV.W   R10, R15
   \   000062   B012....     CALL    #_Mul64i
    404              /* Prevent tiny errors in x and y from leading to tiny negative values for THD */
    405              if (x >= y)
   \   000066   079F         CMP.W   R15, R7
   \   000068   0938         JL      ??evaluate_voltage_thd_3
   \   00006A   2620         JNE     ??evaluate_voltage_thd_1
   \   00006C   069E         CMP.W   R14, R6
   \   00006E   0628         JNC     ??evaluate_voltage_thd_3
   \   000070   2320         JNE     ??evaluate_voltage_thd_1
   \   000072   059D         CMP.W   R13, R5
   \   000074   0328         JNC     ??evaluate_voltage_thd_3
   \   000076   2020         JNE     ??evaluate_voltage_thd_1
   \   000078   049C         CMP.W   R12, R4
   \   00007A   1E2C         JC      ??evaluate_voltage_thd_1
    406                  return 0;
    407              z = y - x;
    408          #if defined(IEC_THD_SUPPORT)
    409              z = isqrt64(z);
   \                     ??evaluate_voltage_thd_3:
   \   00007C   0C84         SUB.W   R4, R12
   \   00007E   0D75         SUBC.W  R5, R13
   \   000080   0E76         SUBC.W  R6, R14
   \   000082   0F77         SUBC.W  R7, R15
   \   000084   B012....     CALL    #isqrt64
    410              z /= phase->readings.fundamental_V_rms;
    411              z *= 10000;
    412              y = z >> 32;
   \   000088   1842....     MOV.W   &working_data + 4, R8
   \   00008C   1942....     MOV.W   &working_data + 6, R9
   \   000090   0A49         MOV.W   R9, R10
   \   000092   3AE3         XOR.W   #0xffff, R10
   \   000094   0A5A         RLA.W   R10
   \   000096   0A7A         SUBC.W  R10, R10
   \   000098   0B4A         MOV.W   R10, R11
   \   00009A   B012....     CALL    #_Div64s
   \   00009E   38401027     MOV.W   #0x2710, R8
   \   0000A2   0943         MOV.W   #0x0, R9
   \   0000A4   0A43         MOV.W   #0x0, R10
   \   0000A6   0B43         MOV.W   #0x0, R11
   \   0000A8   B012....     CALL    #_Mul64i
   \   0000AC   0C4E         MOV.W   R14, R12
   \   0000AE   0F5F         RLA.W   R15
   \   0000B0   0F7F         SUBC.W  R15, R15
   \   0000B2   3FE3         XOR.W   #0xffff, R15
    413          #else
    414              z *= 10000;
    415              z /= x;
    416              y = z;
    417          #endif
    418              if (y < 0)
   \   0000B4   0F93         CMP.W   #0x0, R15
   \   0000B6   0134         JGE     ??evaluate_voltage_thd_0
    419                  return 0;
   \                     ??evaluate_voltage_thd_1:
   \   0000B8   0C43         MOV.W   #0x0, R12
    420              return y;
   \                     ??evaluate_voltage_thd_0:
   \   0000BA   3040....     BR      #?Epilogue8
    421          }
    422          #endif
    423          
    424          #if defined(IRMS_SUPPORT)
    425              #if NUM_PHASES == 1

   \                                 In  segment CODE, align 2
    426          static rms_current_t evaluate_rms_current(void)
   \                     evaluate_rms_current:
    427              #else
    428          static rms_current_t evaluate_rms_current(struct phase_parms_s *phase, struct phase_calibration_data_s const *phase_cal, int ph)
    429              #endif
    430          {
   \   000000   0A12         PUSH.W  R10
   \   000002   0B12         PUSH.W  R11
   \   000004   0812         PUSH.W  R8
   \   000006   0912         PUSH.W  R9
   \   000008   2182         SUB.W   #0x4, SP
    431              rms_current_t x[PER_PHASE_CURRENT_CHANNELS];
    432              #if defined(TWENTYFOUR_BIT)
    433              int64_t tmp;
    434              #else
    435              int32_t tmp;
    436              #endif
    437              #if NUM_PHASES == 1  &&  defined(NEUTRAL_MONITOR_SUPPORT)
    438              int ch;
    439              #endif
    440              #if defined(LIMP_MODE_SUPPORT)  &&  defined(PHASE_UNBALANCED_DETECTION_SUPPORT)
    441              static const int32_t thresholds[2] = {PHASE_UNBALANCED_CUTOFF_THRESHOLD_CURRENT, PHASE_UNBALANCED_TIGHT_THRESHOLD_CURRENT};
    442              #endif
    443              int dp;
    444          
    445              dp = phase->metrology.dp_set;
   \   00000A   5F42....     MOV.B   &working_data + 359, R15
   \   00000E   8F11         SXT     R15
    446              /* Calculate the RMS current. Return RMS_CURRENT_OVERRANGE for overrange
    447                 (i.e. ADC clip). A side effect of this routine is it updates the dynamic
    448                 phase correction settings, based on the newly calculated current. */
    449              /* We always have to work out the properly scaled current from both leads, in
    450                 order to work out the FIR coeffs for the next block. */
    451              #if NUM_PHASES == 1  &&  defined(NEUTRAL_MONITOR_SUPPORT)
    452              for (ch = 0;  ch < 2;  ch++)
    453              #endif
    454              {
    455              #if NUM_PHASES == 1  &&  defined(NEUTRAL_MONITOR_SUPPORT)
    456                  if ((phase->status & current_overrange_masks[ch]))
    457              #else
    458                  if ((phase->status & PHASE_STATUS_I_OVERRANGE))
   \   000010   B2B02000.... BIT.W   #0x20, &working_data + 360
   \   000016   0628         JNC     ??evaluate_rms_current_0
    459              #endif
    460                  {
    461                      x[ch] = RMS_CURRENT_OVERRANGE;
   \   000018   B1430000     MOV.W   #0xffff, 0(SP)
   \   00001C   B140FF7F0200 MOV.W   #0x7fff, 0x2(SP)
   \   000022   553C         JMP     ??evaluate_rms_current_1
    462                  }
    463                  else
    464                  {
    465                      tmp = div_ac_current(phase->metrology.current[ch].dot_prod[dp].I_sq, phase->metrology.current[ch].dot_prod[dp].sample_count);
   \                     ??evaluate_rms_current_0:
   \   000024   0F5F         RLA.W   R15
   \   000026   0B4F         MOV.W   R15, R11
   \   000028   0F5F         RLA.W   R15
   \   00002A   0F5F         RLA.W   R15
   \   00002C   0B5F         ADD.W   R15, R11
   \   00002E   0F5F         RLA.W   R15
   \   000030   0F5F         RLA.W   R15
   \   000032   0F5B         ADD.W   R11, R15
   \   000034   184F....     MOV.W   working_data + 284(R15), R8
   \   000038   0948         MOV.W   R8, R9
   \   00003A   39E3         XOR.W   #0xffff, R9
   \   00003C   0959         RLA.W   R9
   \   00003E   0979         SUBC.W  R9, R9
   \   000040   0A49         MOV.W   R9, R10
   \   000042   3AE3         XOR.W   #0xffff, R10
   \   000044   0A5A         RLA.W   R10
   \   000046   0A7A         SUBC.W  R10, R10
   \   000048   0B4A         MOV.W   R10, R11
   \   00004A   3F50....     ADD.W   #working_data + 276, R15
   \   00004E   3C4F         MOV.W   @R15+, R12
   \   000050   3D4F         MOV.W   @R15+, R13
   \   000052   3E4F         MOV.W   @R15+, R14
   \   000054   3F4F         MOV.W   @R15+, R15
   \   000056   B012....     CALL    #_Div64s
    466                      if (tmp < phase_cal->current[ch].ac_offset)
   \   00005A   1842....     MOV.W   &nv_parms + 6, R8
   \   00005E   1942....     MOV.W   &nv_parms + 8, R9
   \   000062   0A49         MOV.W   R9, R10
   \   000064   3AE3         XOR.W   #0xffff, R10
   \   000066   0A5A         RLA.W   R10
   \   000068   0A7A         SUBC.W  R10, R10
   \   00006A   0F9A         CMP.W   R10, R15
   \   00006C   0938         JL      ??evaluate_rms_current_2
   \   00006E   0D20         JNE     ??evaluate_rms_current_3
   \   000070   0E9A         CMP.W   R10, R14
   \   000072   0628         JNC     ??evaluate_rms_current_2
   \   000074   0A20         JNE     ??evaluate_rms_current_3
   \   000076   0D99         CMP.W   R9, R13
   \   000078   0328         JNC     ??evaluate_rms_current_2
   \   00007A   0720         JNE     ??evaluate_rms_current_3
   \   00007C   0C98         CMP.W   R8, R12
   \   00007E   052C         JC      ??evaluate_rms_current_3
    467                      {
    468                          x[ch] = 0;
   \                     ??evaluate_rms_current_2:
   \   000080   81430000     MOV.W   #0x0, 0(SP)
   \   000084   81430200     MOV.W   #0x0, 0x2(SP)
   \   000088   223C         JMP     ??evaluate_rms_current_1
    469                      }
    470                      else
    471                      {
    472                          /* The ac_offset removes the effect of the AWGN from the ADC front end. AWGN is orthogonal to everything but a true copy
    473                             of itself. This means means we need to subtract the ac_offset in a "Pythagoras" manner", while still squared. */
    474                  #if defined(TWENTYFOUR_BIT)
    475                          x[ch] = isqrt64(tmp - phase_cal->current[ch].ac_offset) >> 26;
   \                     ??evaluate_rms_current_3:
   \   00008A   0C88         SUB.W   R8, R12
   \   00008C   0D79         SUBC.W  R9, R13
   \   00008E   0E7A         SUBC.W  R10, R14
   \   000090   0F7A         SUBC.W  R10, R15
   \   000092   B012....     CALL    #isqrt64
   \   000096   0C4D         MOV.W   R13, R12
   \   000098   0D4E         MOV.W   R14, R13
   \   00009A   0B4F         MOV.W   R15, R11
    476                  #else
    477                          x[ch] = isqrt32(tmp - phase_cal->current[ch].ac_offset) >> 2;
    478                  #endif
    479                          x[ch] = mul48u_32_16(x[ch], phase_cal->current[ch].I_rms_scale_factor[normal_limp]);
   \   00009C   1E42....     MOV.W   &nv_parms + 12, R14
   \   0000A0   8B10         SWPB    R11
   \   0000A2   8D10         SWPB    R13
   \   0000A4   8C10         SWPB    R12
   \   0000A6   4CED         XOR.B   R13, R12
   \   0000A8   0CED         XOR.W   R13, R12
   \   0000AA   4DEB         XOR.B   R11, R13
   \   0000AC   0DEB         XOR.W   R11, R13
   \   0000AE   4A4B         MOV.B   R11, R10
   \   0000B0   0B43         MOV.W   #0x0, R11
   \   0000B2   12C3         CLRC
   \   0000B4   0A10         RRC.W   R10
   \   0000B6   0D10         RRC.W   R13
   \   0000B8   0C10         RRC.W   R12
   \   0000BA   0B11         RRA.W   R11
   \   0000BC   0A10         RRC.W   R10
   \   0000BE   0D10         RRC.W   R13
   \   0000C0   0C10         RRC.W   R12
   \   0000C2   B012....     CALL    #mul48u_32_16
   \   0000C6   814C0000     MOV.W   R12, 0(SP)
   \   0000CA   814D0200     MOV.W   R13, 0x2(SP)
    480                      }
    481                  }
    482                  #if defined(PER_SENSOR_PRECALCULATED_PARAMETER_SUPPORT)
    483                  phase->metrology.current[ch].readings.I_rms = x[ch];
    484                  #endif
    485          
    486                  #if defined(DYNAMIC_PHASE_CORRECTION_SUPPORT)
    487                      #if NUM_PHASES == 1
    488                          #if defined(NEUTRAL_MONITOR_SUPPORT)
    489                      dynamic_phase_correction(ch);
    490                          #else
    491                      dynamic_phase_correction();
    492                          #endif
    493                      #else
    494                  dynamic_phase_correction(phase, phase_cal, ph);
    495                      #endif
    496                  #endif
    497              }
    498          
    499              #if defined(LIMP_MODE_SUPPORT)
    500              if (operating_mode == OPERATING_MODE_LIMP)
    501              {
    502                  /* We need to work out which is the relevant current to use. */
    503                  #if defined(PHASE_UNBALANCED_DETECTION_SUPPORT)
    504                  x[0] = test_phase_balance(x[0], x[1], thresholds);
    505                  /* In limp mode we have no way to determine if the phase is reversed,
    506                     so just say it is not. */
    507                  phase->status &= ~PHASE_STATUS_REVERSED;
    508                  #endif
    509              }
    510              else
    511              #endif
    512              {
    513                  /* The power calculation has provided us which is the appropriate
    514                     current to use. */
    515              #if NUM_PHASES == 1  &&  defined(NEUTRAL_MONITOR_SUPPORT)
    516                  if ((phase->status & PHASE_STATUS_CURRENT_FROM_NEUTRAL))
    517                      x[0] = x[1];
    518              #endif
    519              }
    520          #if defined(TEMPERATURE_CORRECTION_SUPPORT)
    521              x[0] = mul48u_32_16(x[0], working_data.temperature_correction.amplitude_factor);
    522          #endif
    523              return x[0];
   \                     ??evaluate_rms_current_1:
   \   0000CE   2C41         MOV.W   @SP, R12
   \   0000D0   1D410200     MOV.W   0x2(SP), R13
   \   0000D4   2152         ADD.W   #0x4, SP
   \   0000D6   3040....     BR      #?Epilogue4
    524          }
    525          #endif
    526          
    527          #if defined(FUNDAMENTAL_IRMS_SUPPORT)
    528              #if NUM_PHASES == 1

   \                                 In  segment CODE, align 2
    529          static rms_current_t evaluate_fundamental_rms_current(void)
   \                     evaluate_fundamental_rms_current:
    530              #else
    531          static rms_current_t evaluate_fundamental_rms_current(struct phase_parms_s *phase, struct phase_calibration_data_s const *phase_cal)
    532              #endif
    533          {
   \   000000   0A12         PUSH.W  R10
   \   000002   0B12         PUSH.W  R11
   \   000004   0812         PUSH.W  R8
   \   000006   0912         PUSH.W  R9
   \   000008   0612         PUSH.W  R6
   \   00000A   0712         PUSH.W  R7
   \   00000C   0412         PUSH.W  R4
   \   00000E   0512         PUSH.W  R5
    534              rms_current_t x;
    535              int64_t z;
    536          
    537              if ((phase->status & (PHASE_STATUS_I_OVERRANGE | PHASE_STATUS_I_NEUTRAL_OVERRANGE)))
   \   000010   F2B0A000.... BIT.B   #0xa0, &working_data + 360
   \   000016   0424         JEQ     ??evaluate_fundamental_rms_current_0
    538                  return RMS_CURRENT_OVERRANGE;
   \   000018   3C43         MOV.W   #0xffff, R12
   \   00001A   3D40FF7F     MOV.W   #0x7fff, R13
   \   00001E   613C         JMP     ??evaluate_fundamental_rms_current_1
    539          
    540          #if defined(__TI_COMPILER_VERSION__)
    541              /* TODO: We seem to need to calculate this way to get the right answer with CCS 5.1 */
    542              {
    543                  int64_t y;
    544          
    545                  z = (int64_t)phase->readings.fundamental_active_power;
    546                  z *= phase->readings.fundamental_active_power;
    547                  y = (int64_t)phase->readings.fundamental_reactive_power;
    548                  y *= phase->readings.fundamental_reactive_power;
    549                  z += y;
    550              }
    551          #else
    552              z = (int64_t) phase->readings.fundamental_active_power*phase->readings.fundamental_active_power
    553                + (int64_t) phase->readings.fundamental_reactive_power*phase->readings.fundamental_reactive_power;
   \                     ??evaluate_fundamental_rms_current_0:
   \   000020   1442....     MOV.W   &working_data + 32, R4
   \   000024   1542....     MOV.W   &working_data + 34, R5
   \   000028   0645         MOV.W   R5, R6
   \   00002A   36E3         XOR.W   #0xffff, R6
   \   00002C   0656         RLA.W   R6
   \   00002E   0676         SUBC.W  R6, R6
   \   000030   1842....     MOV.W   &working_data + 24, R8
   \   000034   1942....     MOV.W   &working_data + 26, R9
   \   000038   0A49         MOV.W   R9, R10
   \   00003A   3AE3         XOR.W   #0xffff, R10
   \   00003C   0A5A         RLA.W   R10
   \   00003E   0A7A         SUBC.W  R10, R10
   \   000040   0B4A         MOV.W   R10, R11
   \   000042   0C48         MOV.W   R8, R12
   \   000044   0D49         MOV.W   R9, R13
   \   000046   0E4A         MOV.W   R10, R14
   \   000048   0F4A         MOV.W   R10, R15
   \   00004A   B012....     CALL    #_Mul64i
   \   00004E   0F12         PUSH.W  R15
   \   000050   0E12         PUSH.W  R14
   \   000052   0D12         PUSH.W  R13
   \   000054   0C12         PUSH.W  R12
   \   000056   0C44         MOV.W   R4, R12
   \   000058   0D45         MOV.W   R5, R13
   \   00005A   0E46         MOV.W   R6, R14
   \   00005C   0F46         MOV.W   R6, R15
   \   00005E   0844         MOV.W   R4, R8
   \   000060   0945         MOV.W   R5, R9
   \   000062   0A46         MOV.W   R6, R10
   \   000064   0B46         MOV.W   R6, R11
   \   000066   B012....     CALL    #_Mul64i
   \   00006A   3841         POP.W   R8
   \   00006C   3941         POP.W   R9
   \   00006E   3A41         POP.W   R10
   \   000070   3B41         POP.W   R11
   \   000072   085C         ADD.W   R12, R8
   \   000074   096D         ADDC.W  R13, R9
   \   000076   0A6E         ADDC.W  R14, R10
   \   000078   0B6F         ADDC.W  R15, R11
    554          #endif
    555              /* Prevent tiny errors leading to tiny negative values for the fundamental RMS current */
    556              if (z < 0)
   \   00007A   0B93         CMP.W   #0x0, R11
   \   00007C   0334         JGE     ??evaluate_fundamental_rms_current_2
    557                  return 0;
   \   00007E   0C43         MOV.W   #0x0, R12
   \   000080   0D43         MOV.W   #0x0, R13
   \   000082   2F3C         JMP     ??evaluate_fundamental_rms_current_1
    558              z = isqrt64(z)/phase->readings.fundamental_V_rms;
   \                     ??evaluate_fundamental_rms_current_2:
   \   000084   0C48         MOV.W   R8, R12
   \   000086   0D49         MOV.W   R9, R13
   \   000088   0E4A         MOV.W   R10, R14
   \   00008A   0F4B         MOV.W   R11, R15
   \   00008C   B012....     CALL    #isqrt64
    559              /* We need to scale by 1000000. Multiply by 1000000/(2^6), and then shift down by 6 bits
    560                 less than the 32 need to get the fraction out of the sqrt answer */
    561              z *= 15625LL;
    562              x = z >> (32 - 6);
    563          #if defined(TEMPERATURE_CORRECTION_SUPPORT)
    564              x = mul48u_32_16(x, working_data.temperature_correction.amplitude_factor);
    565          #endif
    566              return x;
   \   000090   1842....     MOV.W   &working_data + 4, R8
   \   000094   1942....     MOV.W   &working_data + 6, R9
   \   000098   0A49         MOV.W   R9, R10
   \   00009A   3AE3         XOR.W   #0xffff, R10
   \   00009C   0A5A         RLA.W   R10
   \   00009E   0A7A         SUBC.W  R10, R10
   \   0000A0   0B4A         MOV.W   R10, R11
   \   0000A2   B012....     CALL    #_Div64u
   \   0000A6   3840093D     MOV.W   #0x3d09, R8
   \   0000AA   0943         MOV.W   #0x0, R9
   \   0000AC   0A43         MOV.W   #0x0, R10
   \   0000AE   0B43         MOV.W   #0x0, R11
   \   0000B0   B012....     CALL    #_Mul64i
   \   0000B4   8F10         SWPB    R15
   \   0000B6   8E10         SWPB    R14
   \   0000B8   8D10         SWPB    R13
   \   0000BA   4DEE         XOR.B   R14, R13
   \   0000BC   0DEE         XOR.W   R14, R13
   \   0000BE   0C4D         MOV.W   R13, R12
   \   0000C0   4EEF         XOR.B   R15, R14
   \   0000C2   0EEF         XOR.W   R15, R14
   \   0000C4   0D4E         MOV.W   R14, R13
   \   0000C6   4E4F         MOV.B   R15, R14
   \   0000C8   8E11         SXT     R14
   \   0000CA   8F10         SWPB    R15
   \   0000CC   0F5F         RLA.W   R15
   \   0000CE   0F7F         SUBC.W  R15, R15
   \   0000D0   3FE3         XOR.W   #0xffff, R15
   \   0000D2   0F11         RRA.W   R15
   \   0000D4   0E10         RRC.W   R14
   \   0000D6   0D10         RRC.W   R13
   \   0000D8   0C10         RRC.W   R12
   \   0000DA   0F11         RRA.W   R15
   \   0000DC   0E10         RRC.W   R14
   \   0000DE   0D10         RRC.W   R13
   \   0000E0   0C10         RRC.W   R12
   \                     ??evaluate_fundamental_rms_current_1:
   \   0000E2   3040....     BR      #?Epilogue8
    567          }
    568          #endif
    569          
    570          #if defined(CURRENT_THD_SUPPORT)
    571              #if NUM_PHASES == 1

   \                                 In  segment CODE, align 2
    572          static thd_t evaluate_current_thd(void)
   \                     evaluate_current_thd:
    573              #else
    574          static thd_t evaluate_current_thd(struct phase_parms_s *phase, struct phase_calibration_data_s const *phase_cal)
    575              #endif
    576          {
   \   000000   0A12         PUSH.W  R10
   \   000002   0B12         PUSH.W  R11
   \   000004   0812         PUSH.W  R8
   \   000006   0912         PUSH.W  R9
   \   000008   0612         PUSH.W  R6
   \   00000A   0712         PUSH.W  R7
   \   00000C   0412         PUSH.W  R4
   \   00000E   0512         PUSH.W  R5
   \   000010   9292........ CMP.W   &working_data + 16, &working_data + 12
   \   000016   5038         JL      ??evaluate_current_thd_2
   \   000018   0420         JNE     ??evaluate_current_thd_4
   \   00001A   9292........ CMP.W   &working_data + 14, &working_data + 10
   \   000020   4B28         JNC     ??evaluate_current_thd_2
    577              int64_t x;
    578              int64_t y;
    579              int64_t z;
    580          
    581              #if defined(CURRENT_THD_MEASUREMENT_CUTOFF)
    582              /* Don't calculate the THD when the current is small, as the results are too noisy */
    583              if (phase->readings.I_rms < CURRENT_THD_MEASUREMENT_CUTOFF)
    584                  return 0;
    585              #endif
    586          
    587              /* Avoid silly results if the fundamental appears to exceed the total, either transiently or
    588                 due to rounding issues. */
    589              if (phase->readings.fundamental_I_rms > phase->readings.I_rms)
    590                  return 0;
    591          
    592              x = (int64_t) phase->readings.fundamental_I_rms*phase->readings.fundamental_I_rms;
   \                     ??evaluate_current_thd_4:
   \   000022   1842....     MOV.W   &working_data + 14, R8
   \   000026   1942....     MOV.W   &working_data + 16, R9
   \   00002A   0A49         MOV.W   R9, R10
   \   00002C   3AE3         XOR.W   #0xffff, R10
   \   00002E   0A5A         RLA.W   R10
   \   000030   0A7A         SUBC.W  R10, R10
   \   000032   0B4A         MOV.W   R10, R11
   \   000034   0C48         MOV.W   R8, R12
   \   000036   0D49         MOV.W   R9, R13
   \   000038   0E4A         MOV.W   R10, R14
   \   00003A   0F4A         MOV.W   R10, R15
   \   00003C   B012....     CALL    #_Mul64i
   \   000040   044C         MOV.W   R12, R4
   \   000042   054D         MOV.W   R13, R5
   \   000044   064E         MOV.W   R14, R6
   \   000046   074F         MOV.W   R15, R7
    593              y = (int64_t) phase->readings.I_rms*phase->readings.I_rms;
   \   000048   1842....     MOV.W   &working_data + 10, R8
   \   00004C   1942....     MOV.W   &working_data + 12, R9
   \   000050   0A49         MOV.W   R9, R10
   \   000052   3AE3         XOR.W   #0xffff, R10
   \   000054   0A5A         RLA.W   R10
   \   000056   0A7A         SUBC.W  R10, R10
   \   000058   0B4A         MOV.W   R10, R11
   \   00005A   0C48         MOV.W   R8, R12
   \   00005C   0D49         MOV.W   R9, R13
   \   00005E   0E4A         MOV.W   R10, R14
   \   000060   0F4A         MOV.W   R10, R15
   \   000062   B012....     CALL    #_Mul64i
    594              /* Prevent tiny errors in x and y from leading to tiny negative values for THD */
    595              if (x >= y)
   \   000066   079F         CMP.W   R15, R7
   \   000068   0938         JL      ??evaluate_current_thd_3
   \   00006A   2620         JNE     ??evaluate_current_thd_2
   \   00006C   069E         CMP.W   R14, R6
   \   00006E   0628         JNC     ??evaluate_current_thd_3
   \   000070   2320         JNE     ??evaluate_current_thd_2
   \   000072   059D         CMP.W   R13, R5
   \   000074   0328         JNC     ??evaluate_current_thd_3
   \   000076   2020         JNE     ??evaluate_current_thd_2
   \   000078   049C         CMP.W   R12, R4
   \   00007A   1E2C         JC      ??evaluate_current_thd_2
    596                  return 0;
    597              z = y - x;
    598              #if defined(IEC_THD_SUPPORT)
    599              z = isqrt64(z);
   \                     ??evaluate_current_thd_3:
   \   00007C   0C84         SUB.W   R4, R12
   \   00007E   0D75         SUBC.W  R5, R13
   \   000080   0E76         SUBC.W  R6, R14
   \   000082   0F77         SUBC.W  R7, R15
   \   000084   B012....     CALL    #isqrt64
    600              z /= phase->readings.fundamental_I_rms;
    601              z *= 10000;
    602              z >>= 32;
   \   000088   1842....     MOV.W   &working_data + 14, R8
   \   00008C   1942....     MOV.W   &working_data + 16, R9
   \   000090   0A49         MOV.W   R9, R10
   \   000092   3AE3         XOR.W   #0xffff, R10
   \   000094   0A5A         RLA.W   R10
   \   000096   0A7A         SUBC.W  R10, R10
   \   000098   0B4A         MOV.W   R10, R11
   \   00009A   B012....     CALL    #_Div64s
   \   00009E   38401027     MOV.W   #0x2710, R8
   \   0000A2   0943         MOV.W   #0x0, R9
   \   0000A4   0A43         MOV.W   #0x0, R10
   \   0000A6   0B43         MOV.W   #0x0, R11
   \   0000A8   B012....     CALL    #_Mul64i
   \   0000AC   0C4E         MOV.W   R14, R12
   \   0000AE   0F5F         RLA.W   R15
   \   0000B0   0F7F         SUBC.W  R15, R15
   \   0000B2   3FE3         XOR.W   #0xffff, R15
    603              #else
    604              z *= 10000;
    605              z /= x;
    606              #endif
    607              /* Avoid stupid results when the maths is going crazy on zero current and
    608                 out of lock conditions */
    609              if (z < 0)
   \   0000B4   0F93         CMP.W   #0x0, R15
   \   0000B6   0134         JGE     ??evaluate_current_thd_1
    610                  z = 0;
   \                     ??evaluate_current_thd_2:
   \   0000B8   0C43         MOV.W   #0x0, R12
    611              return z;
   \                     ??evaluate_current_thd_1:
   \   0000BA   3040....     BR      #?Epilogue8
    612          }
    613          #endif
    614          
    615          #if NUM_PHASES > 1  &&  defined(NEUTRAL_MONITOR_SUPPORT)  &&  defined(IRMS_SUPPORT)
    616          static rms_current_t evaluate_neutral_rms_current(void)
    617          {
    618              rms_current_t x;
    619              #if defined(TWENTYFOUR_BIT)
    620              int64_t tmp;
    621              #else
    622              int32_t tmp;
    623              #endif
    624              int dp;
    625          
    626              /* Calculate the RMS current in 1mA increments. Return -1 for overrange
    627                 (i.e. ADC clip). A side effect of this routine is it updates the dynamic
    628                 phase correction settings, based on the newly calculated current. */
    629              if ((working_data.neutral.status & PHASE_STATUS_I_OVERRANGE))
    630                  return RMS_CURRENT_OVERRANGE;
    631          
    632              dp = working_data.neutral.metrology.dp_set;
    633              tmp = div_ac_current(working_data.neutral.metrology.dot_prod[dp].I_sq, working_data.neutral.metrology.dot_prod[dp].sample_count);
    634              if (tmp < cal_info->neutral.ac_offset)
    635                  return 0;
    636          
    637              /* The ac_offset removes the effect of the AWGN from the ADC front end. AWGN is orthogonal to everything but a true copy
    638                 of itself. This means means we need to subtract the ac_offset in a "Pythagoras" manner", while still squared. */
    639              #if defined(TWENTYFOUR_BIT)
    640              x = isqrt64(tmp - cal_info->neutral.ac_offset) >> 26;
    641              #else
    642              x = isqrt32(tmp - cal_info->neutral.ac_offset) >> 2;
    643              #endif
    644              x = mul48u_32_16(x, cal_info->neutral.I_rms_scale_factor[normal_limp]);
    645          #if defined(TEMPERATURE_CORRECTION_SUPPORT)
    646              x = mul48u_32_16(x, working_data.temperature_correction.amplitude_factor);
    647          #endif
    648              return x;
    649          }
    650          #endif
    651          
    652          #if NUM_PHASES > 1  &&  defined(NEUTRAL_MONITOR_SUPPORT)  &&  defined(RESIDUAL_IRMS_SUPPORT)
    653          static rms_current_t evaluate_residual_3phase_rms_current(void)
    654          {
    655              rms_current_t x;
    656              uint16_t status;
    657              int dp;
    658          
    659              /* Calculate the RMS current in 1mA increments. Return RMS_CURRENT_OVERRANGE for overrange
    660                 (i.e. ADC clipping). */
    661              status = working_data.phases[0].status | working_data.phases[1].status | working_data.phases[2].status | working_data.neutral.status;
    662              if ((status & PHASE_STATUS_I_OVERRANGE))
    663                  return RMS_CURRENT_OVERRANGE;
    664          
    665              dp = working_data.neutral.metrology.dp_set;
    666              #if defined(TWENTYFOUR_BIT)
    667              x = isqrt64(div_ac_current(working_data.neutral.metrology.dot_prod[dp].residual_I_sq, working_data.neutral.metrology.dot_prod[dp].sample_count)) >> 26;
    668              #else
    669              x = isqrt32(div_ac_current(working_data.neutral.metrology.dot_prod[dp].residual_I_sq, working_data.neutral.metrology.dot_prod[dp].sample_count)) >> 2;
    670              #endif
    671              /* Use the scaling factor from phase 0 as a a compromise scaling factor. In most meters the phase to phase scaling variation is a
    672                 fraction of a percent. */
    673              x = mul48u_32_16(x, cal_info->phases[0].current[0].I_rms_scale_factor[normal_limp]);
    674          #if defined(TEMPERATURE_CORRECTION_SUPPORT)
    675              x = mul48u_32_16(x, working_data.temperature_correction.amplitude_factor);
    676          #endif
    677              return x;
    678          }
    679          #endif
    680          
    681          #if NUM_PHASES == 1
    682          static power_t evaluate_active_power(void)
    683          #else
    684          static power_t evaluate_active_power(struct phase_parms_s *phase, struct phase_calibration_data_s const *phase_cal)
    685          #endif
    686          {
    687              #if defined(TWENTYFOUR_BIT)
    688              int64_t x[PER_PHASE_CURRENT_CHANNELS];
    689              #else
    690              int32_t x[PER_PHASE_CURRENT_CHANNELS];
    691              #endif
    692          #if defined(PHASE_REVERSED_DETECTION_SUPPORT)
    693              int reversed;
    694          #endif
    695          #if defined(PHASE_UNBALANCED_DETECTION_SUPPORT)
    696              static const int32_t thresholds[2] = {PHASE_UNBALANCED_CUTOFF_THRESHOLD_POWER, PHASE_UNBALANCED_TIGHT_THRESHOLD_POWER};
    697          #endif
    698          #if defined(PHASE_REVERSED_DETECTION_SUPPORT)
    699              #if NUM_PHASES == 1  &&  defined(NEUTRAL_MONITOR_SUPPORT)
    700              static const uint16_t reversed_masks[PER_PHASE_CURRENT_CHANNELS] = {PHASE_STATUS_I_REVERSED, PHASE_STATUS_I_NEUTRAL_REVERSED};
    701              int ch;
    702              #else
    703              static const uint16_t reversed_masks[1] = {PHASE_STATUS_I_REVERSED};
    704              #endif
    705          #endif
    706              int dp;
    707          
    708              if (phase->status & (PHASE_STATUS_V_OVERRANGE | PHASE_STATUS_I_OVERRANGE | PHASE_STATUS_I_NEUTRAL_OVERRANGE))
    709              {
    710          #if defined(PER_SENSOR_PRECALCULATED_PARAMETER_SUPPORT)
    711                  phase->metrology.current[0].readings.active_power = POWER_OVERRANGE;
    712              #if NUM_PHASES == 1  &&  defined(NEUTRAL_MONITOR_SUPPORT)
    713                  phase->metrology.current[1].readings.active_power = POWER_OVERRANGE;
    714              #endif
    715          #endif
    716                  return POWER_OVERRANGE;
    717              }
    718          
    719              /* We can only do real power assessment in full operating mode. */
    720              /* If we have neutral monitoring for a single phase meter, we need to measure
    721                 both power levels, and decide between them. Issues to be assessed here are
    722                 whether one or both leads show reverse power, and whether the power levels
    723                 are balanced. */
    724          #if defined(PHASE_REVERSED_DETECTION_SUPPORT)
    725              /* If we find a negative power level we may be genuinely feeding power to the grid,
    726                 or we may be seeing a tamper condition. This is application dependent. */
    727              reversed = FALSE;
    728          #endif
    729          
    730              dp = phase->metrology.dp_set;
    731          #if NUM_PHASES == 1  &&  defined(NEUTRAL_MONITOR_SUPPORT)
    732              for (ch = 0;  ch < 2;  ch++)
    733          #endif
    734              {
    735                  x[ch] = div_ac_power(phase->metrology.current[ch].dot_prod[dp].P_active, phase->metrology.current[ch].dot_prod[dp].sample_count);
    736                  x[ch] >>= 9;
    737                  x[ch] = mul48_32_16(x[ch], phase_cal->current[ch].P_scale_factor);
    738          #if defined(PER_SENSOR_PRECALCULATED_PARAMETER_SUPPORT)
    739                  phase->metrology.current[ch].readings.active_power = x[ch];
    740          #endif
    741          #if defined(PHASE_REVERSED_DETECTION_SUPPORT)
    742                  if (x[ch] < 0)
    743                  {
    744              #if defined(PHASE_REVERSED_IS_TAMPERING)
    745                      x[ch] = -x[ch];
    746              #endif
    747                      phase->status |= reversed_masks[ch];
    748                      if (x[ch] > PHASE_REVERSED_THRESHOLD_POWER)
    749                          reversed = TRUE;
    750                  }
    751                  else
    752                  {
    753                      phase->status &= ~reversed_masks[ch];   
    754                  }
    755          #endif
    756              }
    757          
    758          #if defined(PHASE_UNBALANCED_DETECTION_SUPPORT)
    759              x[0] = test_phase_balance(x[0], x[1], thresholds);
    760              if ((phase->status & PHASE_STATUS_UNBALANCED))
    761              {
    762                  /* When the phase is unbalanced we only look for reversed current in the 
    763                     lead with the higher current. If we do not impose this restriction, coupling
    764                     through a parasitic CT power supply transformer can cause the reverse condition
    765                     to be raised incorrectly. If there is no parasitic supply this test is probably
    766                     a waste of time. */
    767                  if ((phase->status & PHASE_STATUS_CURRENT_FROM_NEUTRAL))
    768                      reversed = phase->status & PHASE_STATUS_I_NEUTRAL_REVERSED;
    769                  else
    770                      reversed = phase->status & PHASE_STATUS_I_REVERSED;
    771              }
    772          #endif
    773          
    774          #if defined(PHASE_REVERSED_DETECTION_SUPPORT)
    775              if ((phase->status & PHASE_STATUS_REVERSED))
    776              {
    777                  if (!reversed)
    778                  {
    779                      if (--phase->metrology.current_reversed_persistence_check <= -PHASE_REVERSED_PERSISTENCE_CHECK)
    780                      {
    781                          phase->status &= ~PHASE_STATUS_REVERSED;
    782                          phase->metrology.current_reversed_persistence_check = 0;
    783                      }
    784                  }
    785                  else
    786                  {
    787                      phase->metrology.current_reversed_persistence_check = 0;
    788                  }
    789              }
    790              else
    791              {
    792                  if (reversed)
    793                  {
    794                      if (++phase->metrology.current_reversed_persistence_check >= PHASE_REVERSED_PERSISTENCE_CHECK)
    795                      {
    796                          phase->status |= PHASE_STATUS_REVERSED;
    797                          phase->metrology.current_reversed_persistence_check = 0;
    798                      }
    799                  }
    800                  else
    801                  {
    802                      phase->metrology.current_reversed_persistence_check = 0;
    803                  }
    804              }
    805          #endif
    806          #if defined(TEMPERATURE_CORRECTION_SUPPORT)
    807              x[0] = mul48_32_16(x[0], working_data.temperature_correction.power_factor);
    808          #endif
    809              return x[0];
    810          }
    811          
    812          #if defined(REACTIVE_POWER_SUPPORT)  &&  defined(REACTIVE_POWER_BY_QUADRATURE_SUPPORT)
    813              #if NUM_PHASES == 1

   \                                 In  segment CODE, align 2
    814          static power_t evaluate_reactive_power(void)
   \                     evaluate_reactive_power:
    815              #else
    816          static power_t evaluate_reactive_power(struct phase_parms_s *phase, struct phase_calibration_data_s const *phase_cal)
    817              #endif
    818          {
   \   000000   0A12         PUSH.W  R10
   \   000002   0B12         PUSH.W  R11
   \   000004   0812         PUSH.W  R8
   \   000006   0912         PUSH.W  R9
    819              #if defined(TWENTYFOUR_BIT)
    820              int64_t x;
    821              #else
    822              int32_t x;
    823              #endif
    824              int16_t i;
    825              #if NUM_PHASES == 1  &&  defined(NEUTRAL_MONITOR_SUPPORT)
    826              int ch;
    827              #endif
    828              int dp;
    829          
    830              if (phase->status & (PHASE_STATUS_V_OVERRANGE | PHASE_STATUS_I_OVERRANGE | PHASE_STATUS_I_NEUTRAL_OVERRANGE))
   \   000008   F2B0B000.... BIT.B   #0xb0, &working_data + 360
   \   00000E   0424         JEQ     ??evaluate_reactive_power_0
    831                  return POWER_OVERRANGE;
   \   000010   3C43         MOV.W   #0xffff, R12
   \   000012   3D40FF7F     MOV.W   #0x7fff, R13
   \   000016   403C         JMP     ??evaluate_reactive_power_1
    832          
    833              dp = phase->metrology.dp_set;
   \                     ??evaluate_reactive_power_0:
   \   000018   5F42....     MOV.B   &working_data + 359, R15
   \   00001C   8F11         SXT     R15
    834              #if NUM_PHASES == 1  &&  defined(NEUTRAL_MONITOR_SUPPORT)
    835              /* If we have neutral monitoring for a single phase meter, we need to use whichever
    836                 channel has been selected by the anti-tamper validation scheme. */
    837              ch = (phase->status & PHASE_STATUS_CURRENT_FROM_NEUTRAL)  ?  1  :  0;
    838              #endif
    839          
    840              x = div_ac_power(phase->metrology.current[ch].dot_prod[dp].P_reactive, phase->metrology.current[ch].dot_prod[dp].sample_count);
   \   00001E   0F5F         RLA.W   R15
   \   000020   0B4F         MOV.W   R15, R11
   \   000022   0F5F         RLA.W   R15
   \   000024   0F5F         RLA.W   R15
   \   000026   0B5F         ADD.W   R15, R11
   \   000028   0F5F         RLA.W   R15
   \   00002A   0F5F         RLA.W   R15
   \   00002C   0F5B         ADD.W   R11, R15
   \   00002E   184F....     MOV.W   working_data + 284(R15), R8
   \   000032   0948         MOV.W   R8, R9
   \   000034   39E3         XOR.W   #0xffff, R9
   \   000036   0959         RLA.W   R9
   \   000038   0979         SUBC.W  R9, R9
   \   00003A   0A49         MOV.W   R9, R10
   \   00003C   3AE3         XOR.W   #0xffff, R10
   \   00003E   0A5A         RLA.W   R10
   \   000040   0A7A         SUBC.W  R10, R10
   \   000042   0B4A         MOV.W   R10, R11
   \   000044   3F50....     ADD.W   #working_data + 252, R15
   \   000048   3C4F         MOV.W   @R15+, R12
   \   00004A   3D4F         MOV.W   @R15+, R13
   \   00004C   3E4F         MOV.W   @R15+, R14
   \   00004E   3F4F         MOV.W   @R15+, R15
   \   000050   B012....     CALL    #_Div64s
   \   000054   084C         MOV.W   R12, R8
   \   000056   094D         MOV.W   R13, R9
   \   000058   0A4E         MOV.W   R14, R10
   \   00005A   0B4F         MOV.W   R15, R11
    841              x >>= 9;
    842              i = q1_15_mul(phase_cal->current[ch].P_scale_factor, phase->metrology.current[ch].quadrature_correction.fir_gain);
   \   00005C   1D42....     MOV.W   &working_data + 336, R13
   \   000060   1C42....     MOV.W   &nv_parms + 14, R12
   \   000064   B012....     CALL    #q1_15_mul
    843              x = mul48_32_16(x, i);
    844              x <<= 2;
    845          #if defined(TEMPERATURE_CORRECTION_SUPPORT)
    846              x = mul48_32_16(x, working_data.temperature_correction.power_factor);
    847          #endif
    848              return  x;
   \   000068   0E4C         MOV.W   R12, R14
   \   00006A   8B10         SWPB    R11
   \   00006C   8A10         SWPB    R10
   \   00006E   8910         SWPB    R9
   \   000070   8810         SWPB    R8
   \   000072   48E9         XOR.B   R9, R8
   \   000074   08E9         XOR.W   R9, R8
   \   000076   49EA         XOR.B   R10, R9
   \   000078   09EA         XOR.W   R10, R9
   \   00007A   4AEB         XOR.B   R11, R10
   \   00007C   0AEB         XOR.W   R11, R10
   \   00007E   8B11         SXT     R11
   \   000080   0B11         RRA.W   R11
   \   000082   0A10         RRC.W   R10
   \   000084   0910         RRC.W   R9
   \   000086   0810         RRC.W   R8
   \   000088   0C48         MOV.W   R8, R12
   \   00008A   0D49         MOV.W   R9, R13
   \   00008C   B012....     CALL    #mul48_32_16
   \   000090   0C5C         RLA.W   R12
   \   000092   0D6D         RLC.W   R13
   \   000094   0C5C         RLA.W   R12
   \   000096   0D6D         RLC.W   R13
   \                     ??evaluate_reactive_power_1:
   \   000098   3040....     BR      #?Epilogue4
    849          }
    850          #endif
    851          
    852          #if defined(APPARENT_POWER_SUPPORT)
    853              #if NUM_PHASES == 1
    854          static int32_t evaluate_apparent_power(void)
    855              #else
    856          static int32_t evaluate_apparent_power(struct phase_parms_s *phase, struct phase_calibration_data_s const *phase_cal)
    857              #endif
    858          {
    859              #if defined(REACTIVE_POWER_BY_QUADRATURE_SUPPORT)
    860              int64_t z;
    861          
    862              if (phase->readings.active_power == POWER_OVERRANGE  ||  phase->readings.reactive_power == POWER_OVERRANGE)
    863                  return POWER_OVERRANGE;
    864          
    865              /* Calculate apparent (VA) power in 0.01W increments */
    866          #if defined(__TI_COMPILER_VERSION__)
    867              /* TODO: We seem to need to calculate this way to get the right answer with CCS 5.1 */
    868              {
    869                  int64_t y;
    870          
    871                  z = (int64_t)phase->readings.active_power;
    872                  z *= phase->readings.active_power;
    873                  y = (int64_t)phase->readings.reactive_power;
    874                  y *= phase->readings.reactive_power;
    875                  z += y;
    876              }
    877          #else
    878              z = (int64_t) phase->readings.active_power*phase->readings.active_power
    879                + (int64_t) phase->readings.reactive_power*phase->readings.reactive_power;
    880          #endif
    881              return isqrt64i(z);
    882              #else
    883              rms_voltage_t x;
    884              rms_current_t y;
    885                  #if NUM_PHASES == 1  &&  defined(NEUTRAL_MONITOR_SUPPORT)
    886              int ch;
    887                  #endif
    888              int dp;
    889          
    890              dp = phase->metrology.dp_set;
    891              /* Calculate VA power in 0.01W increments */
    892              x = isqrt32(div_ac_voltage(phase->metrology.dot_prod[dp].V_sq, phase->metrology.dot_prod[dp].sample_count));
    893                  #if defined(LIMP_MODE_SUPPORT)
    894              x = (x >> 12)*phase_cal->V_rms_scale_factor[normal_limp];
    895                  #else
    896              x = (x >> 12)*phase_cal->V_rms_scale_factor;
    897                  #endif
    898              x >>= 14;
    899          
    900                  #if NUM_PHASES == 1  &&  defined(NEUTRAL_MONITOR_SUPPORT)
    901              ch = (phase->status & PHASE_STATUS_CURRENT_FROM_NEUTRAL)  ?  1  :  0;
    902                  #endif
    903              /* The ac_offset removes the effect of the AWGN from the ADC front end. AWGN is orthogonal to everything but a true copy
    904                 of itself. This means means we need to subtract the ac_offset in a "Pythagoras" manner", while still squared. */
    905                  #if defined(TWENTYFOUR_BIT)
    906              y = isqrt64(div_ac_current(phase->metrology.current[ch].dot_prod[dp].I_sq, phase->metrology.current[ch].dot_prod[dp].sample_count)
    907                        - phase_cal->current[ch].ac_offset) >> 36;
    908                  #else
    909              y = isqrt32(div_ac_current(phase->metrology.current[ch].dot_prod[dp].I_sq, phase->metrology.current[ch].dot_prod[dp].sample_count)
    910                        - phase_cal->current[ch].ac_offset) >> 12;
    911                  #endif
    912                  #if defined(LIMP_MODE_SUPPORT)
    913              y *= phase_cal->current[ch].I_rms_scale_factor[normal_limp];
    914                  #else
    915              y *= phase_cal->current[ch].I_rms_scale_factor;
    916                  #endif
    917              y >>= 14;
    918          
    919              x *= y;
    920              x /= 1000;
    921          #if defined(TEMPERATURE_CORRECTION_SUPPORT)
    922              x = mul48_32_16(x, working_data.temperature_correction.power_factor);
    923          #endif
    924              return x;
    925              #endif
    926          }
    927          #endif
    928          
    929          #if defined(FUNDAMENTAL_ACTIVE_POWER_SUPPORT)
    930              #if NUM_PHASES == 1

   \                                 In  segment CODE, align 2
    931          static power_t evaluate_fundamental_active_power(void)
   \                     evaluate_fundamental_active_power:
    932              #else
    933          static power_t evaluate_fundamental_active_power(struct phase_parms_s *phase, struct phase_calibration_data_s const *phase_cal)
    934              #endif
    935          {
   \   000000   0A12         PUSH.W  R10
   \   000002   0B12         PUSH.W  R11
   \   000004   0812         PUSH.W  R8
   \   000006   0912         PUSH.W  R9
   \   000008   0612         PUSH.W  R6
   \   00000A   0712         PUSH.W  R7
   \   00000C   0412         PUSH.W  R4
    936              #if defined(TWENTYFOUR_BIT)
    937              int64_t x;
    938              #else
    939              int32_t x;
    940              #endif
    941              int32_t y;
    942              int32_t z;
    943              #if NUM_PHASES == 1  &&  defined(NEUTRAL_MONITOR_SUPPORT)
    944              int ch;
    945              #endif
    946              int dp;
    947          
    948              if (phase->status & (PHASE_STATUS_V_OVERRANGE | PHASE_STATUS_I_OVERRANGE | PHASE_STATUS_I_NEUTRAL_OVERRANGE))
   \   00000E   F2B0B000.... BIT.B   #0xb0, &working_data + 360
   \   000014   0424         JEQ     ??evaluate_fundamental_active_power_0
    949                  return POWER_OVERRANGE;
   \   000016   3C43         MOV.W   #0xffff, R12
   \   000018   3D40FF7F     MOV.W   #0x7fff, R13
   \   00001C   3B3C         JMP     ??evaluate_fundamental_active_power_1
    950          
    951              dp = phase->metrology.dp_set;
   \                     ??evaluate_fundamental_active_power_0:
   \   00001E   5742....     MOV.B   &working_data + 359, R7
   \   000022   8711         SXT     R7
    952              #if NUM_PHASES == 1  &&  defined(NEUTRAL_MONITOR_SUPPORT)
    953              /* If we have neutral monitoring for a single phase meter, we need to use whichever
    954                 channel has been selected by the anti-tamper validation scheme. */
    955              ch = (phase->status & PHASE_STATUS_CURRENT_FROM_NEUTRAL)  ?  1  :  0;
    956              #endif
    957          
    958              x = div_ac_power(phase->metrology.current[ch].dot_prod[dp].P_fundamental_active, phase->metrology.current[ch].dot_prod[dp].sample_count);
    959              x >>= 6;
    960              y = mul48_32_16(x, phase_cal->current[ch].P_scale_factor);
   \   000024   0647         MOV.W   R7, R6
   \   000026   0656         RLA.W   R6
   \   000028   0F46         MOV.W   R6, R15
   \   00002A   0656         RLA.W   R6
   \   00002C   0656         RLA.W   R6
   \   00002E   0F56         ADD.W   R6, R15
   \   000030   0656         RLA.W   R6
   \   000032   0656         RLA.W   R6
   \   000034   065F         ADD.W   R15, R6
   \   000036   1846....     MOV.W   working_data + 284(R6), R8
   \   00003A   0948         MOV.W   R8, R9
   \   00003C   39E3         XOR.W   #0xffff, R9
   \   00003E   0959         RLA.W   R9
   \   000040   0979         SUBC.W  R9, R9
   \   000042   0A49         MOV.W   R9, R10
   \   000044   3AE3         XOR.W   #0xffff, R10
   \   000046   0A5A         RLA.W   R10
   \   000048   0A7A         SUBC.W  R10, R10
   \   00004A   0B4A         MOV.W   R10, R11
   \   00004C   0F46         MOV.W   R6, R15
   \   00004E   3F50....     ADD.W   #working_data + 260, R15
   \   000052   3C4F         MOV.W   @R15+, R12
   \   000054   3D4F         MOV.W   @R15+, R13
   \   000056   3E4F         MOV.W   @R15+, R14
   \   000058   3F4F         MOV.W   @R15+, R15
   \   00005A   B012....     CALL    #_Div64s
   \   00005E   1442....     MOV.W   &nv_parms + 14, R4
   \   000062   B012....     CALL    #?ShiftRight64s_6
   \   000066   0E44         MOV.W   R4, R14
   \   000068   B012....     CALL    #mul48_32_16
   \   00006C   0A4C         MOV.W   R12, R10
   \   00006E   0B4D         MOV.W   R13, R11
    961              /* Scale by the voltage gain */
    962              z = div_ac_voltage(phase->metrology.dot_prod[dp].V_fundamental, phase->metrology.current[ch].dot_prod[dp].sample_count);
   \   000070   1D46....     MOV.W   working_data + 284(R6), R13
   \   000074   0757         RLA.W   R7
   \   000076   0F47         MOV.W   R7, R15
   \   000078   0757         RLA.W   R7
   \   00007A   0F57         ADD.W   R7, R15
   \   00007C   0757         RLA.W   R7
   \   00007E   075F         ADD.W   R15, R7
   \   000080   3750....     ADD.W   #working_data + 208, R7
   \   000084   0C47         MOV.W   R7, R12
   \   000086   B012....     CALL    #div48
    963              /* Scale down by the size of the reference signal to 15 bits */
    964              z >>= 16;
    965              y = mul48_32_16(y, (int16_t) z);
    966          #if defined(TEMPERATURE_CORRECTION_SUPPORT)
    967              y = mul48_32_16(y, working_data.temperature_correction.power_factor);
    968          #endif
    969              return y;
   \   00008A   0E4D         MOV.W   R13, R14
   \   00008C   0C4A         MOV.W   R10, R12
   \   00008E   0D4B         MOV.W   R11, R13
   \   000090   B012....     CALL    #mul48_32_16
   \                     ??evaluate_fundamental_active_power_1:
   \   000094   3040....     BR      #?Epilogue7
    970          }
    971          #endif
    972          
    973          #if defined(FUNDAMENTAL_REACTIVE_POWER_SUPPORT)
    974              #if NUM_PHASES == 1

   \                                 In  segment CODE, align 2
    975          static power_t evaluate_fundamental_reactive_power(void)
   \                     evaluate_fundamental_reactive_power:
    976              #else
    977          static power_t evaluate_fundamental_reactive_power(struct phase_parms_s *phase, struct phase_calibration_data_s const *phase_cal)
    978              #endif
    979          {
   \   000000   0A12         PUSH.W  R10
   \   000002   0B12         PUSH.W  R11
   \   000004   0812         PUSH.W  R8
   \   000006   0912         PUSH.W  R9
   \   000008   0612         PUSH.W  R6
   \   00000A   0712         PUSH.W  R7
   \   00000C   0412         PUSH.W  R4
    980              #if defined(TWENTYFOUR_BIT)
    981              int64_t x;
    982              #else
    983              int32_t x;
    984              #endif
    985              power_t y;
    986              rms_voltage_t z;
    987              #if NUM_PHASES == 1  &&  defined(NEUTRAL_MONITOR_SUPPORT)
    988              int ch;
    989              #endif
    990              int dp;
    991          
    992              if (phase->status & (PHASE_STATUS_V_OVERRANGE | PHASE_STATUS_I_OVERRANGE | PHASE_STATUS_I_NEUTRAL_OVERRANGE))
   \   00000E   F2B0B000.... BIT.B   #0xb0, &working_data + 360
   \   000014   0424         JEQ     ??evaluate_fundamental_reactive_power_0
    993                  return POWER_OVERRANGE;
   \   000016   3C43         MOV.W   #0xffff, R12
   \   000018   3D40FF7F     MOV.W   #0x7fff, R13
   \   00001C   3B3C         JMP     ??evaluate_fundamental_reactive_power_1
    994          
    995              dp = phase->metrology.dp_set;
   \                     ??evaluate_fundamental_reactive_power_0:
   \   00001E   5742....     MOV.B   &working_data + 359, R7
   \   000022   8711         SXT     R7
    996              #if NUM_PHASES == 1  &&  defined(NEUTRAL_MONITOR_SUPPORT)
    997              /* If we have neutral monitoring for a single phase meter, we need to use whichever
    998                 channel has been selected by the anti-tamper validation scheme. */
    999              ch = (phase->status & PHASE_STATUS_CURRENT_FROM_NEUTRAL)  ?  1  :  0;
   1000              #endif
   1001          
   1002              x = div_ac_power(phase->metrology.current[ch].dot_prod[dp].P_fundamental_reactive, phase->metrology.current[ch].dot_prod[dp].sample_count);
   1003              x >>= 6;
   1004              y = mul48_32_16(x, phase_cal->current[ch].P_scale_factor);
   \   000024   0647         MOV.W   R7, R6
   \   000026   0656         RLA.W   R6
   \   000028   0F46         MOV.W   R6, R15
   \   00002A   0656         RLA.W   R6
   \   00002C   0656         RLA.W   R6
   \   00002E   0F56         ADD.W   R6, R15
   \   000030   0656         RLA.W   R6
   \   000032   0656         RLA.W   R6
   \   000034   065F         ADD.W   R15, R6
   \   000036   1846....     MOV.W   working_data + 284(R6), R8
   \   00003A   0948         MOV.W   R8, R9
   \   00003C   39E3         XOR.W   #0xffff, R9
   \   00003E   0959         RLA.W   R9
   \   000040   0979         SUBC.W  R9, R9
   \   000042   0A49         MOV.W   R9, R10
   \   000044   3AE3         XOR.W   #0xffff, R10
   \   000046   0A5A         RLA.W   R10
   \   000048   0A7A         SUBC.W  R10, R10
   \   00004A   0B4A         MOV.W   R10, R11
   \   00004C   0F46         MOV.W   R6, R15
   \   00004E   3F50....     ADD.W   #working_data + 268, R15
   \   000052   3C4F         MOV.W   @R15+, R12
   \   000054   3D4F         MOV.W   @R15+, R13
   \   000056   3E4F         MOV.W   @R15+, R14
   \   000058   3F4F         MOV.W   @R15+, R15
   \   00005A   B012....     CALL    #_Div64s
   \   00005E   1442....     MOV.W   &nv_parms + 14, R4
   \   000062   B012....     CALL    #?ShiftRight64s_6
   \   000066   0E44         MOV.W   R4, R14
   \   000068   B012....     CALL    #mul48_32_16
   \   00006C   0A4C         MOV.W   R12, R10
   \   00006E   0B4D         MOV.W   R13, R11
   1005              /* Scale by the voltage gain */
   1006              z = div_ac_voltage(phase->metrology.dot_prod[dp].V_fundamental, phase->metrology.current[ch].dot_prod[dp].sample_count);
   \   000070   1D46....     MOV.W   working_data + 284(R6), R13
   \   000074   0757         RLA.W   R7
   \   000076   0F47         MOV.W   R7, R15
   \   000078   0757         RLA.W   R7
   \   00007A   0F57         ADD.W   R7, R15
   \   00007C   0757         RLA.W   R7
   \   00007E   075F         ADD.W   R15, R7
   \   000080   3750....     ADD.W   #working_data + 208, R7
   \   000084   0C47         MOV.W   R7, R12
   \   000086   B012....     CALL    #div48
   1007              /* Scale down by the size of the reference signal to 15 bits */
   1008              z >>= 16;
   1009              y = mul48_32_16(y, (int16_t) z);
   1010          #if defined(TEMPERATURE_CORRECTION_SUPPORT)
   1011              y = mul48_32_16(y, working_data.temperature_correction.power_factor);
   1012          #endif
   1013              return y;
   \   00008A   0E4D         MOV.W   R13, R14
   \   00008C   0C4A         MOV.W   R10, R12
   \   00008E   0D4B         MOV.W   R11, R13
   \   000090   B012....     CALL    #mul48_32_16
   \                     ??evaluate_fundamental_reactive_power_1:
   \   000094   3040....     BR      #?Epilogue7
   1014          }
   1015          #endif
   1016          
   1017          #if defined(POWER_FACTOR_SUPPORT)
   1018              #if NUM_PHASES == 1

   \                                 In  segment CODE, align 2
   1019          static int16_t evaluate_power_factor(void)
   \                     evaluate_power_factor:
   1020              #else
   1021          static int16_t evaluate_power_factor(struct phase_parms_s *phase, struct phase_calibration_data_s const *phase_cal)
   1022              #endif
   1023          {
   \   000000   0A12         PUSH.W  R10
   1024              power_t p;
   1025              power_t x;
   1026              #if NUM_PHASES == 1  &&  defined(NEUTRAL_MONITOR_SUPPORT)
   1027              int ch;
   1028              #endif
   1029          
   1030              p = abs32(phase->readings.active_power);
   \   000002   1C42....     MOV.W   &working_data + 20, R12
   \   000006   1D42....     MOV.W   &working_data + 22, R13
   \   00000A   0D93         CMP.W   #0x0, R13
   \   00000C   0434         JGE     ??evaluate_power_factor_1
   \   00000E   3CE3         XOR.W   #0xffff, R12
   \   000010   3DE3         XOR.W   #0xffff, R13
   \   000012   1C53         ADD.W   #0x1, R12
   \   000014   0D63         ADDC.W  #0x0, R13
   1031              #if defined(POWER_FACTOR_MEASUREMENT_CUTOFF)
   1032              if (p < POWER_FACTOR_MEASUREMENT_CUTOFF/10)
   1033                  return 10000;
   1034              #endif
   1035              #if defined(APPARENT_POWER_SUPPORT)
   1036              x = abs32(phase->readings.apparent_power);
   \                     ??evaluate_power_factor_1:
   \   000016   1E42....     MOV.W   &working_data + 36, R14
   \   00001A   1F42....     MOV.W   &working_data + 38, R15
   \   00001E   0F93         CMP.W   #0x0, R15
   \   000020   0434         JGE     ??evaluate_power_factor_2
   \   000022   3EE3         XOR.W   #0xffff, R14
   \   000024   3FE3         XOR.W   #0xffff, R15
   \   000026   1E53         ADD.W   #0x1, R14
   \   000028   0F63         ADDC.W  #0x0, R15
   1037              #endif
   1038              if (p  &&  x)
   \                     ??evaluate_power_factor_2:
   \   00002A   0A4C         MOV.W   R12, R10
   \   00002C   0ADD         BIS.W   R13, R10
   \   00002E   0A93         CMP.W   #0x0, R10
   \   000030   4624         JEQ     ??evaluate_power_factor_3
   \   000032   0A4E         MOV.W   R14, R10
   \   000034   0ADF         BIS.W   R15, R10
   \   000036   0A93         CMP.W   #0x0, R10
   \   000038   4224         JEQ     ??evaluate_power_factor_3
   1039              {
   1040                  /* Justify for optimal accuracy */
   1041                  while ((p & 0x40000000) == 0  &&  (x & 0x40000000) == 0)
   \   00003A   3DB00040     BIT.W   #0x4000, R13
   \   00003E   172C         JC      ??evaluate_power_factor_4
   \   000040   3FB00040     BIT.W   #0x4000, R15
   \   000044   142C         JC      ??evaluate_power_factor_4
   1042                  {
   1043                      p <<= 1;
   \                     ??evaluate_power_factor_0:
   \   000046   0C5C         RLA.W   R12
   \   000048   0D6D         RLC.W   R13
   1044                      x <<= 1;
   \   00004A   0E5E         RLA.W   R14
   \   00004C   0F6F         RLC.W   R15
   \   00004E   3DB00040     BIT.W   #0x4000, R13
   \   000052   0D2C         JC      ??evaluate_power_factor_4
   \   000054   3FB00040     BIT.W   #0x4000, R15
   \   000058   0A2C         JC      ??evaluate_power_factor_4
   \   00005A   0C5C         RLA.W   R12
   \   00005C   0D6D         RLC.W   R13
   \   00005E   0E5E         RLA.W   R14
   \   000060   0F6F         RLC.W   R15
   \   000062   3DB00040     BIT.W   #0x4000, R13
   \   000066   032C         JC      ??evaluate_power_factor_4
   \   000068   3FB00040     BIT.W   #0x4000, R15
   \   00006C   EC2B         JNC     ??evaluate_power_factor_0
   1045                  }
   1046                  x >>= 16;
   1047                  p /= x;
   1048                  p *= 10000;
   1049                  p >>= 16;
   \                     ??evaluate_power_factor_4:
   \   00006E   0E4F         MOV.W   R15, R14
   \   000070   3FE3         XOR.W   #0xffff, R15
   \   000072   0F5F         RLA.W   R15
   \   000074   0F7F         SUBC.W  R15, R15
   \   000076   B012....     CALL    #?DivMod32s
   \   00007A   0212         PUSH.W  SR
   \   00007C   32C2         DINT
   \   00007E   0343         NOP
   \   000080   824C3001     MOV.W   R12, &0x130
   \   000084   B24010273801 MOV.W   #0x2710, &0x138
   \   00008A   1C423A01     MOV.W   &0x13a, R12
   \   00008E   92423C013A01 MOV.W   &0x13c, &0x13a
   \   000094   824D3401     MOV.W   R13, &0x134
   \   000098   B24010273801 MOV.W   #0x2710, &0x138
   \   00009E   1D423A01     MOV.W   &0x13a, R13
   \   0000A2   3241         POP.W   SR
   \   0000A4   0C4D         MOV.W   R13, R12
   \   0000A6   3DE3         XOR.W   #0xffff, R13
   \   0000A8   0D5D         RLA.W   R13
   \   0000AA   0D7D         SUBC.W  R13, R13
   1050                  /* Don't let a little imprecision cause strange answers */
   1051                  if (p > 10000)
   \   0000AC   0D93         CMP.W   #0x0, R13
   \   0000AE   0838         JL      ??evaluate_power_factor_5
   \   0000B0   0320         JNE     ??evaluate_power_factor_6
   \   0000B2   3C901127     CMP.W   #0x2711, R12
   \   0000B6   0428         JNC     ??evaluate_power_factor_5
   1052                      p = 10000;
   \                     ??evaluate_power_factor_6:
   \   0000B8   3C401027     MOV.W   #0x2710, R12
   \   0000BC   013C         JMP     ??evaluate_power_factor_5
   1053              }
   1054              else
   1055              {
   1056                  p = 0;
   \                     ??evaluate_power_factor_3:
   \   0000BE   0C43         MOV.W   #0x0, R12
   1057              }
   1058              /* Use a negative PF to indicate an inductive load */
   1059              #if defined(REACTIVE_POWER_BY_QUADRATURE_SUPPORT)
   1060              if (phase->readings.reactive_power < 0)
   \                     ??evaluate_power_factor_5:
   \   0000C0   8293....     CMP.W   #0x0, &working_data + 30
   \   0000C4   0234         JGE     ??evaluate_power_factor_7
   1061                  p = -p;
   \   0000C6   3CE3         XOR.W   #0xffff, R12
   \   0000C8   1C53         ADD.W   #0x1, R12
   1062              #else
   1063                  #if NUM_PHASES == 1  &&  defined(NEUTRAL_MONITOR_SUPPORT)
   1064              /* If we have neutral monitoring for a single phase meter, we need to use whichever
   1065                 channel has been selected by the anti-tamper validation scheme. */
   1066              ch = (phase->status & PHASE_STATUS_CURRENT_FROM_NEUTRAL)  ?  1  :  0;
   1067                  #endif
   1068              if (phase->metrology.current[ch].leading < 0)
   1069                  p = -p;
   1070              #endif
   1071              return p;
   \                     ??evaluate_power_factor_7:
   \   0000CA   3A41         POP.W   R10
   \   0000CC   3041         RET
   1072          }
   1073          #endif
   1074          
   1075          #if defined(ENERGY_SUPPORT)

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine0:
   \   000000   2153         ADD.W   #0x2, SP
   \   000002   3040....     BR      #?Epilogue8

   \                                 In  segment CODE, align 2
   1076          void integrate_power_to_energy(struct energy_integrator_t *en, power_t pow, int samples)
   \                     integrate_power_to_energy:
   1077          {
   \   000000   0A12         PUSH.W  R10
   \   000002   0B12         PUSH.W  R11
   \   000004   0812         PUSH.W  R8
   \   000006   0912         PUSH.W  R9
   \   000008   0612         PUSH.W  R6
   \   00000A   0712         PUSH.W  R7
   \   00000C   0412         PUSH.W  R4
   \   00000E   0512         PUSH.W  R5
   \   000010   0C12         PUSH.W  R12
   \   000012   0B4D         MOV.W   R13, R11
   1078              energy_t energy;
   1079          
   1080              energy = (energy_t) pow*samples + en->energy_residual;
   \   000014   0C4E         MOV.W   R14, R12
   \   000016   0D4F         MOV.W   R15, R13
   \   000018   0E4B         MOV.W   R11, R14
   \   00001A   0F4B         MOV.W   R11, R15
   \   00001C   3FE3         XOR.W   #0xffff, R15
   \   00001E   0F5F         RLA.W   R15
   \   000020   0F7F         SUBC.W  R15, R15
   \   000022   B012....     CALL    #_Mul32s32sto64i
   \   000026   2B41         MOV.W   @SP, R11
   \   000028   184B0800     MOV.W   0x8(R11), R8
   \   00002C   194B0A00     MOV.W   0xa(R11), R9
   \   000030   0A49         MOV.W   R9, R10
   \   000032   3AE3         XOR.W   #0xffff, R10
   \   000034   0A5A         RLA.W   R10
   \   000036   0A7A         SUBC.W  R10, R10
   \   000038   0C58         ADD.W   R8, R12
   \   00003A   0D69         ADDC.W  R9, R13
   \   00003C   0E6A         ADDC.W  R10, R14
   \   00003E   0F6A         ADDC.W  R10, R15
   \   000040   044C         MOV.W   R12, R4
   \   000042   054D         MOV.W   R13, R5
   \   000044   0F93         CMP.W   #0x0, R15
   \   000046   2538         JL      ??integrate_power_to_energy_0
   \   000048   0920         JNE     ??integrate_power_to_energy_1
   \   00004A   0E93         CMP.W   #0x0, R14
   \   00004C   0720         JNE     ??integrate_power_to_energy_1
   \   00004E   3D90A9AB     CMP.W   #0xaba9, R13
   \   000052   1F28         JNC     ??integrate_power_to_energy_0
   \   000054   0320         JNE     ??integrate_power_to_energy_1
   \   000056   3C900050     CMP.W   #0x5000, R12
   \   00005A   1B28         JNC     ??integrate_power_to_energy_0
   \                     ??integrate_power_to_energy_1:
   \   00005C   38400050     MOV.W   #0x5000, R8
   \   000060   3940A9AB     MOV.W   #0xaba9, R9
   \   000064   0A43         MOV.W   #0x0, R10
   \   000066   0B43         MOV.W   #0x0, R11
   \   000068   B012....     CALL    #_Div64s
   \   00006C   2B41         MOV.W   @SP, R11
   \   00006E   8B5C0000     ADD.W   R12, 0(R11)
   \   000072   8B6D0200     ADDC.W  R13, 0x2(R11)
   \   000076   8B6E0400     ADDC.W  R14, 0x4(R11)
   \   00007A   8B6F0600     ADDC.W  R15, 0x6(R11)
   \   00007E   384000B0     MOV.W   #0xb000, R8
   \   000082   39405654     MOV.W   #0x5456, R9
   \   000086   3A43         MOV.W   #0xffff, R10
   \   000088   3B43         MOV.W   #0xffff, R11
   \   00008A   B012....     CALL    #_Mul64i
   \   00008E   045C         ADD.W   R12, R4
   \   000090   056D         ADDC.W  R13, R5
   1081              while (energy >= ENERGY_100MWATT_HOUR_THRESHOLD)
   1082              {
   1083                  energy -= ENERGY_100MWATT_HOUR_THRESHOLD;
   1084                  en->energy++;
   1085              }
   1086              en->energy_residual = energy;
   \                     ??integrate_power_to_energy_0:
   \   000092   2F41         MOV.W   @SP, R15
   \   000094   8F440800     MOV.W   R4, 0x8(R15)
   \   000098   8F450A00     MOV.W   R5, 0xa(R15)
   1087          }
   \   00009C   ....         JMP     ?Subroutine0
   1088          
   1089              #if NUM_PHASES == 1

   \                                 In  segment CODE, align 2, keep-with-next
   1090          static void accumulate_phase_energies(void)
   \                     accumulate_phase_energies:
   1091              #else
   1092          static void accumulate_phase_energies(struct phase_parms_s *phase, struct phase_calibration_data_s const *phase_cal)
   1093              #endif
   1094          {
   \   000000   0A12         PUSH.W  R10
   \   000002   0B12         PUSH.W  R11
   \   000004   0812         PUSH.W  R8
   \   000006   0912         PUSH.W  R9
   \   000008   0612         PUSH.W  R6
   \   00000A   0712         PUSH.W  R7
   \   00000C   0412         PUSH.W  R4
   \   00000E   0512         PUSH.W  R5
   \   000010   2183         SUB.W   #0x2, SP
   1095              power_t pow;
   1096              int which;
   1097              int dp;
   1098          
   1099              if (phase->readings.active_power == POWER_OVERRANGE)
   \   000012   1C42....     MOV.W   &working_data + 20, R12
   \   000016   1D42....     MOV.W   &working_data + 22, R13
   \   00001A   3C93         CMP.W   #0xffff, R12
   \   00001C   0320         JNE     ??accumulate_phase_energies_1
   \   00001E   3D90FF7F     CMP.W   #0x7fff, R13
   \   000022   7224         JEQ     ??accumulate_phase_energies_2
   1100                  return;
   1101              if (abs32(phase->readings.active_power) < RESIDUAL_POWER_CUTOFF/10)
   \                     ??accumulate_phase_energies_1:
   \   000024   0E4C         MOV.W   R12, R14
   \   000026   0F4D         MOV.W   R13, R15
   \   000028   0D93         CMP.W   #0x0, R13
   \   00002A   0434         JGE     ??accumulate_phase_energies_0
   \   00002C   3EE3         XOR.W   #0xffff, R14
   \   00002E   3FE3         XOR.W   #0xffff, R15
   \   000030   1E53         ADD.W   #0x1, R14
   \   000032   0F63         ADDC.W  #0x0, R15
   \                     ??accumulate_phase_energies_0:
   \   000034   0F93         CMP.W   #0x0, R15
   \   000036   6838         JL      ??accumulate_phase_energies_2
   \   000038   0320         JNE     ??accumulate_phase_energies_4
   \   00003A   3E90FA00     CMP.W   #0xfa, R14
   \   00003E   6428         JNC     ??accumulate_phase_energies_2
   1102                  return;
   1103              dp = phase->metrology.dp_set;
   \                     ??accumulate_phase_energies_4:
   \   000040   5E42....     MOV.B   &working_data + 359, R14
   \   000044   8E11         SXT     R14
   1104              #if defined(ACTIVE_ENERGY_SUPPORT)
   1105              pow = phase->readings.active_power;
   1106              if (phase->readings.active_power >= 0)
   \   000046   0D93         CMP.W   #0x0, R13
   \   000048   0238         JL      ??accumulate_phase_energies_5
   1107              {
   1108                  which = ENERGY_DIRECTION_IMPORT;
   \   00004A   0F43         MOV.W   #0x0, R15
   \   00004C   053C         JMP     ??accumulate_phase_energies_6
   1109              }
   1110              else
   1111              {
   1112                  which = ENERGY_DIRECTION_EXPORT;
   \                     ??accumulate_phase_energies_5:
   \   00004E   1F43         MOV.W   #0x1, R15
   1113                  pow = -pow;
   \   000050   3CE3         XOR.W   #0xffff, R12
   \   000052   3DE3         XOR.W   #0xffff, R13
   \   000054   1C53         ADD.W   #0x1, R12
   \   000056   0D63         ADDC.W  #0x0, R13
   1114              }
   1115              integrate_power_to_energy(&phase->energy.active[which], pow, phase->metrology.current[0].dot_prod[dp].sample_count);
   \                     ??accumulate_phase_energies_6:
   \   000058   0E5E         RLA.W   R14
   \   00005A   0B4E         MOV.W   R14, R11
   \   00005C   0E5E         RLA.W   R14
   \   00005E   0E5E         RLA.W   R14
   \   000060   0B5E         ADD.W   R14, R11
   \   000062   0E5E         RLA.W   R14
   \   000064   0E5E         RLA.W   R14
   \   000066   0E5B         ADD.W   R11, R14
   \   000068   1E4E....     MOV.W   working_data + 284(R14), R14
   \   00006C   0F5F         RLA.W   R15
   \   00006E   0F5F         RLA.W   R15
   \   000070   0B4F         MOV.W   R15, R11
   \   000072   0F5F         RLA.W   R15
   \   000074   0F5B         ADD.W   R11, R15
   \   000076   3F50....     ADD.W   #working_data + 54, R15
   \   00007A   814F0000     MOV.W   R15, 0(SP)
   \   00007E   0F4E         MOV.W   R14, R15
   \   000080   3FE3         XOR.W   #0xffff, R15
   \   000082   0F5F         RLA.W   R15
   \   000084   0F7F         SUBC.W  R15, R15
   \   000086   B012....     CALL    #_Mul32s32sto64i
   \   00008A   044C         MOV.W   R12, R4
   \   00008C   054D         MOV.W   R13, R5
   \   00008E   074F         MOV.W   R15, R7
   \   000090   2F41         MOV.W   @SP, R15
   \   000092   184F0800     MOV.W   0x8(R15), R8
   \   000096   194F0A00     MOV.W   0xa(R15), R9
   \   00009A   0A49         MOV.W   R9, R10
   \   00009C   3AE3         XOR.W   #0xffff, R10
   \   00009E   0A5A         RLA.W   R10
   \   0000A0   0A7A         SUBC.W  R10, R10
   \   0000A2   0458         ADD.W   R8, R4
   \   0000A4   0569         ADDC.W  R9, R5
   \   0000A6   0E6A         ADDC.W  R10, R14
   \   0000A8   076A         ADDC.W  R10, R7
   \   0000AA   0793         CMP.W   #0x0, R7
   \   0000AC   2838         JL      ??accumulate_phase_energies_7
   \   0000AE   0920         JNE     ??accumulate_phase_energies_8
   \   0000B0   0E93         CMP.W   #0x0, R14
   \   0000B2   0720         JNE     ??accumulate_phase_energies_8
   \   0000B4   3590A9AB     CMP.W   #0xaba9, R5
   \   0000B8   2228         JNC     ??accumulate_phase_energies_7
   \   0000BA   0320         JNE     ??accumulate_phase_energies_8
   \   0000BC   34900050     CMP.W   #0x5000, R4
   \   0000C0   1E28         JNC     ??accumulate_phase_energies_7
   \                     ??accumulate_phase_energies_8:
   \   0000C2   38400050     MOV.W   #0x5000, R8
   \   0000C6   3940A9AB     MOV.W   #0xaba9, R9
   \   0000CA   0A43         MOV.W   #0x0, R10
   \   0000CC   0B43         MOV.W   #0x0, R11
   \   0000CE   0C44         MOV.W   R4, R12
   \   0000D0   0D45         MOV.W   R5, R13
   \   0000D2   0F47         MOV.W   R7, R15
   \   0000D4   B012....     CALL    #_Div64s
   \   0000D8   2B41         MOV.W   @SP, R11
   \   0000DA   8B5C0000     ADD.W   R12, 0(R11)
   \   0000DE   8B6D0200     ADDC.W  R13, 0x2(R11)
   \   0000E2   8B6E0400     ADDC.W  R14, 0x4(R11)
   \   0000E6   8B6F0600     ADDC.W  R15, 0x6(R11)
   \   0000EA   384000B0     MOV.W   #0xb000, R8
   \   0000EE   39405654     MOV.W   #0x5456, R9
   \   0000F2   3A43         MOV.W   #0xffff, R10
   \   0000F4   3B43         MOV.W   #0xffff, R11
   \   0000F6   B012....     CALL    #_Mul64i
   \   0000FA   045C         ADD.W   R12, R4
   \   0000FC   056D         ADDC.W  R13, R5
   \                     ??accumulate_phase_energies_7:
   \   0000FE   2F41         MOV.W   @SP, R15
   \   000100   8F440800     MOV.W   R4, 0x8(R15)
   \   000104   8F450A00     MOV.W   R5, 0xa(R15)
   1116              #endif
   1117              #if defined(FUNDAMENTAL_ACTIVE_ENERGY_SUPPORT)
   1118              pow = phase->readings.fundamental_active_power;
   1119              if (phase->readings.fundamental_active_power >= 0)
   1120              {
   1121                  which = ENERGY_DIRECTION_IMPORT;
   1122              }
   1123              else
   1124              {
   1125                  which = ENERGY_DIRECTION_EXPORT;
   1126                  pow = -pow;
   1127              }
   1128              integrate_power_to_energy(&phase->energy.fundamental_active[which], pow, phase->metrology.current[0].dot_prod[dp].sample_count);
   1129              #endif
   1130              #if defined(REACTIVE_ENERGY_SUPPORT)
   1131              pow = phase->readings.reactive_power;
   1132              if (phase->readings.reactive_power >= 0)
   1133              {
   1134                  which = (phase->readings.active_power >= 0)  ?  ENERGY_QUADRANT_I  :  ENERGY_QUADRANT_II;
   1135              }
   1136              else
   1137              {
   1138                  which = (phase->readings.active_power >= 0)  ?  ENERGY_QUADRANT_IV  :  ENERGY_QUADRANT_III;
   1139                  pow = -pow;
   1140              }
   1141              integrate_power_to_energy(&phase->energy.reactive[which], pow, phase->metrology.current[0].dot_prod[dp].sample_count);
   1142              #endif
   1143              #if defined(FUNDAMENTAL_REACTIVE_ENERGY_SUPPORT)
   1144              pow = phase->readings.fundamental_reactive_power;
   1145              if (phase->readings.fundamental_reactive_power >= 0)
   1146              {
   1147                  which = (phase->readings.active_power >= 0)  ?  ENERGY_QUADRANT_I  :  ENERGY_QUADRANT_II;
   1148              }
   1149              else
   1150              {
   1151                  which = (phase->readings.active_power >= 0)  ?  ENERGY_QUADRANT_IV  :  ENERGY_QUADRANT_III;
   1152                  pow = -pow;
   1153              }
   1154              integrate_power_to_energy(&phase->energy.fundamental_reactive[which], pow, phase->metrology.current[0].dot_prod[dp].sample_count);
   1155              #endif
   1156              #if defined(APPARENT_ENERGY_SUPPORT)
   1157              pow = phase->readings.apparent_power;
   1158              if (phase->readings.active_power >= 0)
   1159              {
   1160                  which = ENERGY_DIRECTION_IMPORT;
   1161              }
   1162              else
   1163              {
   1164                  which = ENERGY_DIRECTION_EXPORT;
   1165                  pow = -pow;
   1166              }
   1167              integrate_power_to_energy(&phase->energy.apparent[which], pow, phase->metrology.current[0].dot_prod[dp].sample_count);
   1168              #endif
   1169          }
   \                     ??accumulate_phase_energies_2:
   \   000108                REQUIRE ?Subroutine0
   \   000108                // Fall through to label ?Subroutine0
   1170          #endif
   1171          
   1172          #if defined(TOTAL_ENERGY_SUPPORT)
   1173              #if NUM_PHASES == 1
   1174          static void accumulate_total_energies(void)
   1175              #else
   1176          static void accumulate_total_energies(struct phase_parms_s *phase, struct phase_calibration_data_s const *phase_cal)
   1177              #endif
   1178          {
   1179              power_t pow;
   1180              int which;
   1181              int dp;
   1182          
   1183              if (working_data.totals.readings.active_power == POWER_OVERRANGE)
   1184                  return;
   1185              if (abs32(working_data.totals.readings.active_power) < TOTAL_RESIDUAL_POWER_CUTOFF)
   1186                  return;
   1187              dp = phase->metrology.dp_set;
   1188              #if defined(TOTAL_ACTIVE_ENERGY_SUPPORT)
   1189              pow = phase->readings.active_power;
   1190              if (working_data.totals.readings.active_power >= 0)
   1191              {
   1192                  which = ENERGY_DIRECTION_IMPORT;
   1193              }
   1194              else
   1195              {
   1196                  which = ENERGY_DIRECTION_EXPORT;
   1197                  pow = -pow;
   1198              }
   1199              integrate_power_to_energy(&working_data.totals.energy.active[which], pow, phase->metrology.current[0].dot_prod[dp].sample_count);
   1200              #endif
   1201              #if defined(TOTAL_FUNDAMENTAL_ACTIVE_ENERGY_SUPPORT)
   1202              pow = phase->readings.fundamental_active_power;
   1203              if (working_data.totals.readings.fundamental_active_power >= 0)
   1204              {
   1205                  which = ENERGY_DIRECTION_IMPORT;
   1206              }
   1207              else
   1208              {
   1209                  which = ENERGY_DIRECTION_EXPORT;
   1210                  pow = -pow;
   1211              }
   1212              integrate_power_to_energy(&working_data.totals.energy.fundamental_active[which], pow, phase->metrology.current[0].dot_prod[dp].sample_count);
   1213              #endif
   1214              #if defined(TOTAL_REACTIVE_ENERGY_SUPPORT)
   1215              pow = phase->readings.reactive_power;
   1216              if (working_data.totals.readings.reactive_power >= 0)
   1217              {
   1218                  which = (working_data.totals.readings.active_power >= 0)  ?  ENERGY_QUADRANT_I  :  ENERGY_QUADRANT_II;
   1219              }
   1220              else
   1221              {
   1222                  which = (working_data.totals.readings.active_power >= 0)  ?  ENERGY_QUADRANT_IV  :  ENERGY_QUADRANT_III;
   1223                  pow = -pow;
   1224              }
   1225              integrate_power_to_energy(&working_data.totals.energy.reactive[which], pow, phase->metrology.current[0].dot_prod[dp].sample_count);
   1226              #endif
   1227              #if defined(TOTAL_FUNDAMENTAL_REACTIVE_ENERGY_SUPPORT)
   1228              pow = phase->readings.fundamental_reactive_power;
   1229              if (working_data.totals.readings.fundamental_reactive_power >= 0)
   1230              {
   1231                  which = (working_data.totals.readings.active_power >= 0)  ?  ENERGY_QUADRANT_I  :  ENERGY_QUADRANT_II;
   1232              }
   1233              else
   1234              {
   1235                  which = (working_data.totals.readings.active_power >= 0)  ?  ENERGY_QUADRANT_IV  :  ENERGY_QUADRANT_III;
   1236                  pow = -pow;
   1237              }
   1238              integrate_power_to_energy(&working_data.totals.energy.fundamental_reactive[which], pow, phase->metrology.current[0].dot_prod[dp].sample_count);
   1239              #endif
   1240              #if defined(TOTAL_APPARENT_ENERGY_SUPPORT)
   1241              pow = phase->readings.apparent_power;
   1242              if (working_data.totals.readings.active_power >= 0)
   1243              {
   1244                  which = ENERGY_DIRECTION_IMPORT;
   1245              }
   1246              else
   1247              {
   1248                  which = ENERGY_DIRECTION_EXPORT;
   1249                  pow = -pow;
   1250              }
   1251              integrate_power_to_energy(&working_data.totals.energy.apparent[which], pow, phase->metrology.current[0].dot_prod[dp].sample_count);
   1252              #endif
   1253          }
   1254          #endif
   1255          
   1256          #if defined(SAG_SWELL_SUPPORT)
   1257              #if NUM_PHASES == 1
   1258          static void sag_swell_control(void)
   1259              #else
   1260          static void sag_swell_control(struct phase_parms_s *phase, struct phase_calibration_data_s const *phase_cal)
   1261              #endif
   1262          {
   1263              int64_t xxx;
   1264              int32_t yyy;
   1265              int64_t zzz;
   1266          
   1267              /* Find the current sag and swell thresholds, based on the current mains period */
   1268              xxx = MAINS_NOMINAL_VOLTAGE*1000L*1024L;
   1269              xxx /= phase_cal->V_rms_scale_factor[normal_limp];
   1270              xxx = xxx*xxx;
   1271              yyy = (phase->metrology.mains_period >> 24)*5;
   1272              xxx *= yyy;
   1273              zzz = xxx*207LL;
   1274              zzz >>= 8;
   1275              phase->metrology.sag_threshold[1] = zzz >> 16;
   1276              phase->metrology.sag_threshold[2] = zzz >> 32;
   1277              zzz = xxx*310LL;
   1278              zzz >>= 8;
   1279              phase->metrology.swell_threshold[1] = zzz >> 16;
   1280              phase->metrology.swell_threshold[2] = zzz >> 32;
   1281          }
   1282          #endif
   1283          
   1284          #if defined(TEMPERATURE_SUPPORT)
   1285          static void evaluate_temperature(void)
   1286          {
   1287              int32_t temp;
   1288          
   1289              /* Find the temperature, in Celsius, based on the values for the slope and intercept of the
   1290                 sensor characteristic found at calibration time. */
   1291              /* The temperature in Celsius is approx. (Vsensor - 986mV)/3.55mV . The exact voltages
   1292                 are the subject of calibration. */
   1293              temp = 100L * ((raw_temperature_from_adc) - cal_info->temperature_sensor_intercept);
   1294              /* We now have the temperature in degrees C. */
   1295              temperature_in_celsius = (int16_t)(temp / cal_info->temperature_sensor_slope) + cal_info->temperature_at_calibration;
   1296          }
   1297          #endif
   1298          
   1299          #if defined(LIMP_MODE_SUPPORT)
   1300          void metrology_limp_normal_detection(void)
   1301          {
   1302              static const rms_voltage_t thresholds[] = {(rms_voltage_t) LIMP_MODE_VOLTAGE_THRESHOLD*1000, (rms_voltage_t) NORMAL_MODE_VOLTAGE_THRESHOLD*1000};
   1303          
   1304              /* The voltage channel DC offset will not move very much when the meter is
   1305                 operating normally, even over wide temperature changes. If our estimate
   1306                 moves, there must be some tampering introducing DC into the voltage
   1307                 signal, such as a diode between the grid and the meter. */
   1308              if (phase->readings.V_rms >= thresholds[normal_limp]
   1309                  &&
   1310                  (phase->metrology.V_dc_estimate[normal_limp][0] >> 16) <= phase_cal->upper_v_dc_estimate[normal_limp]
   1311                  &&
   1312                  (phase->metrology.V_dc_estimate[normal_limp][0] >> 16) >= phase_cal->lower_v_dc_estimate[normal_limp])
   1313              {
   1314                  if (operating_mode == OPERATING_MODE_LIMP)
   1315                      switch_to_normal_mode();
   1316              }
   1317              else
   1318              {
   1319                  if (operating_mode == OPERATING_MODE_NORMAL)
   1320                      switch_to_limp_mode();
   1321              }
   1322          }
   1323          #endif
   1324          
   1325          #if defined(LIMP_MODE_SUPPORT)
   1326              #if NUM_PHASES == 1
   1327          static power_t calculate_limp_phase_readings(void)
   1328              #else
   1329          static power_t calculate_limp_phase_readings(int ph)
   1330              #endif
   1331          {
   1332              #if NUM_PHASES > 1
   1333              struct phase_parms_s *phase;
   1334              struct phase_calibration_data_s const *phase_cal;
   1335          
   1336              phase = &chan[ph];
   1337              phase_cal = &cal_info->phases[ph];
   1338              #endif
   1339              /* In limp mode we must assess estimated power from only the measured current. */
   1340              /* We cannot properly determine current reversal in this mode. Also, current
   1341                 imbalance is really just a measure of which lead is still connected.
   1342                 Just treat both the imbalance and reversal conditions as OK */
   1343              #if NUM_PHASES == 1
   1344                  #if defined(VRMS_SUPPORT)
   1345              phase->readings.V_rms = evaluate_rms_voltage();
   1346                  #endif
   1347                  #if defined(IRMS_SUPPORT)
   1348              phase->readings.I_rms = evaluate_rms_current();
   1349                  #endif
   1350              #else
   1351                  #if defined(VRMS_SUPPORT)
   1352              phase->V_rms = evaluate_rms_voltage(phase, phase_cal);
   1353                  #endif
   1354                  #if defined(IRMS_SUPPORT)
   1355              phase->readings.I_rms = evaluate_rms_current(phase, phase_cal, ch);
   1356                  #endif
   1357              #endif
   1358              phase->readings.active_power = phase->readings.I_rms*MAINS_NOMINAL_VOLTAGE/1000;
   1359              return phase->readings.active_power;
   1360          }
   1361          #endif
   1362          
   1363          
   1364          
   1365          #if defined(CAPACITOR_COMPENSATE_ON)
   1366          static rms_current_t capacitor_compensate (int phx)
   1367          {
   1368              int64_t Temp;
   1369              int64_t Temp1;
   1370              uint16_t Cap = cal_info->phases[phx].initial_compensate_capacitance[0];
   1371              
   1372              if (Cap > 0x8000)
   1373                Cap = 0;
   1374              
   1375              // Resolution : important to set a proper scaling factor
   1376              // Power resolution 1mW
   1377              // Frequency resolution 0.01Hz
   1378              // Irms resolution 1uA
   1379              // Vrms resolution 1mA
   1380              // CAP 1/64uF
   1381              // Temp is 2*pi*f*c*Vrms the number calculated here is 2*pi*100f*64000000C*1000Vrms which is 6.4*10^12 time
   1382              // it should be. Thus the constant is 2*pi/6.4*10^12 = 9.81747704 * 10^-13
   1383              // in order to get 1uA resolution (as to compatable with the current resolution) we need Temp be 10^6 times of the value it should be
   1384              // thus the final scaling factor is 9.81747704 * 10^-7 which is about 527 / 2^29 (0.01% error) - new value
   1385              Temp = (((int64_t)527 * phase->readings.frequency * (phase->readings.V_rms) * Cap) >> (29));
   1386              
   1387              // similiar to above Temp1 is 4*pi*100f*640000000C*1000Preactive same 6.4*10^12 time it should be
   1388              // in order to get 1uA reolution we need Temp1 to be 10^12 times of the value
   1389              // thus the final scaling factor is 7.853981634 which is about 4021 / 2048 (0.0059% error)
   1390          	// leaving 2048 to be divided later
   1391              Temp1 = ((((int64_t)4021 * phase->readings.frequency * Cap)));
   1392              
   1393              Temp = -(((int64_t)Temp1 * phase->readings.reactive_power) / 2048) + ((int64_t)Temp * Temp) + ((int64_t)phase->readings.I_rms * phase->readings.I_rms);
   1394              return (isqrt64i (Temp));
   1395          }
   1396          #endif
   1397          
   1398          
   1399          
   1400          #ifndef AVERAGE
   1401          #define AVERAGE 0
   1402          #endif
   1403          
   1404          #if NUM_PHASES == 1

   \                                 In  segment CODE, align 2
   1405          power_t calculate_phase_readings(void)
   \                     calculate_phase_readings:
   1406          #else
   1407          power_t calculate_phase_readings(int ph)
   1408          #endif
   1409          {
   \   000000   0A12         PUSH.W  R10
   \   000002   0B12         PUSH.W  R11
   \   000004   0812         PUSH.W  R8
   \   000006   0912         PUSH.W  R9
   \   000008   0612         PUSH.W  R6
   \   00000A   0712         PUSH.W  R7
   1410              int dp;
   1411          
   1412              FOREGROUND_PROCESS_ON ();
   \   00000C   B012....     CALL    #FOREGROUND_PROCESS_ON
   1413          #if NUM_PHASES == 1
   1414              #if defined(LIMP_MODE_SUPPORT)
   1415              if (operating_mode == OPERATING_MODE_LIMP)
   1416                  return calculate_limp_phase_readings();
   1417              #endif
   1418          
   1419          //    phase->readings.active_power = evaluate_active_power();
   1420              phase->readings.active_power = phase->readings.active_power + ((evaluate_active_power() - phase->readings.active_power) >> AVERAGE);
   \   000010   F2B0B000.... BIT.B   #0xb0, &working_data + 360
   \   000016   0424         JEQ     ??calculate_phase_readings_0
   \   000018   3C43         MOV.W   #0xffff, R12
   \   00001A   3D40FF7F     MOV.W   #0x7fff, R13
   \   00001E   333C         JMP     ??calculate_phase_readings_1
   \                     ??calculate_phase_readings_0:
   \   000020   5742....     MOV.B   &working_data + 359, R7
   \   000024   8711         SXT     R7
   \   000026   0757         RLA.W   R7
   \   000028   0B47         MOV.W   R7, R11
   \   00002A   0757         RLA.W   R7
   \   00002C   0757         RLA.W   R7
   \   00002E   0B57         ADD.W   R7, R11
   \   000030   0757         RLA.W   R7
   \   000032   0757         RLA.W   R7
   \   000034   075B         ADD.W   R11, R7
   \   000036   1847....     MOV.W   working_data + 284(R7), R8
   \   00003A   0948         MOV.W   R8, R9
   \   00003C   39E3         XOR.W   #0xffff, R9
   \   00003E   0959         RLA.W   R9
   \   000040   0979         SUBC.W  R9, R9
   \   000042   0A49         MOV.W   R9, R10
   \   000044   3AE3         XOR.W   #0xffff, R10
   \   000046   0A5A         RLA.W   R10
   \   000048   0A7A         SUBC.W  R10, R10
   \   00004A   0B4A         MOV.W   R10, R11
   \   00004C   3750....     ADD.W   #working_data + 244, R7
   \   000050   3C47         MOV.W   @R7+, R12
   \   000052   3D47         MOV.W   @R7+, R13
   \   000054   3E47         MOV.W   @R7+, R14
   \   000056   3F47         MOV.W   @R7+, R15
   \   000058   B012....     CALL    #_Div64s
   \   00005C   0A4E         MOV.W   R14, R10
   \   00005E   0B4F         MOV.W   R15, R11
   \   000060   1E42....     MOV.W   &nv_parms + 14, R14
   \   000064   8B10         SWPB    R11
   \   000066   8A10         SWPB    R10
   \   000068   8D10         SWPB    R13
   \   00006A   8C10         SWPB    R12
   \   00006C   4CED         XOR.B   R13, R12
   \   00006E   0CED         XOR.W   R13, R12
   \   000070   4DEA         XOR.B   R10, R13
   \   000072   0DEA         XOR.W   R10, R13
   \   000074   4AEB         XOR.B   R11, R10
   \   000076   0AEB         XOR.W   R11, R10
   \   000078   8B11         SXT     R11
   \   00007A   0B11         RRA.W   R11
   \   00007C   0A10         RRC.W   R10
   \   00007E   0D10         RRC.W   R13
   \   000080   0C10         RRC.W   R12
   \   000082   B012....     CALL    #mul48_32_16
   \                     ??calculate_phase_readings_1:
   \   000086   1C82....     SUB.W   &working_data + 20, R12
   \   00008A   1D72....     SUBC.W  &working_data + 22, R13
   \   00008E   0D11         RRA.W   R13
   \   000090   0C10         RRC.W   R12
   \   000092   0D11         RRA.W   R13
   \   000094   0C10         RRC.W   R12
   \   000096   0D11         RRA.W   R13
   \   000098   0C10         RRC.W   R12
   \   00009A   825C....     ADD.W   R12, &working_data + 20
   \   00009E   826D....     ADDC.W  R13, &working_data + 22
   1421          
   1422              if (!(phase->status & PHASE_STATUS_DC_MODE))
   \   0000A2   8293....     CMP.W   #0x0, &working_data + 360
   \   0000A6   3138         JL      ??calculate_phase_readings_2
   1423              {
   1424                #if defined(FUNDAMENTAL_ACTIVE_POWER_SUPPORT)
   1425          //      phase->readings.fundamental_active_power = evaluate_fundamental_active_power();
   1426                phase->readings.fundamental_active_power = phase->readings.fundamental_active_power + ((evaluate_fundamental_active_power()- phase->readings.fundamental_active_power) >> AVERAGE);
   \   0000A8   B012....     CALL    #evaluate_fundamental_active_power
   \   0000AC   1C82....     SUB.W   &working_data + 24, R12
   \   0000B0   1D72....     SUBC.W  &working_data + 26, R13
   \   0000B4   0D11         RRA.W   R13
   \   0000B6   0C10         RRC.W   R12
   \   0000B8   0D11         RRA.W   R13
   \   0000BA   0C10         RRC.W   R12
   \   0000BC   0D11         RRA.W   R13
   \   0000BE   0C10         RRC.W   R12
   \   0000C0   825C....     ADD.W   R12, &working_data + 24
   \   0000C4   826D....     ADDC.W  R13, &working_data + 26
   1427                #endif
   1428                #if defined(REACTIVE_POWER_SUPPORT)
   1429          //      phase->readings.reactive_power = evaluate_reactive_power();
   1430                phase->readings.reactive_power = phase->readings.reactive_power + ((evaluate_reactive_power() - phase->readings.reactive_power) >> AVERAGE);
   \   0000C8   B012....     CALL    #evaluate_reactive_power
   \   0000CC   1C82....     SUB.W   &working_data + 28, R12
   \   0000D0   1D72....     SUBC.W  &working_data + 30, R13
   \   0000D4   0D11         RRA.W   R13
   \   0000D6   0C10         RRC.W   R12
   \   0000D8   0D11         RRA.W   R13
   \   0000DA   0C10         RRC.W   R12
   \   0000DC   0D11         RRA.W   R13
   \   0000DE   0C10         RRC.W   R12
   \   0000E0   825C....     ADD.W   R12, &working_data + 28
   \   0000E4   826D....     ADDC.W  R13, &working_data + 30
   1431                #endif
   1432                #if defined(FUNDAMENTAL_REACTIVE_POWER_SUPPORT)
   1433          //      phase->readings.fundamental_reactive_power = evaluate_fundamental_reactive_power();
   1434                phase->readings.fundamental_reactive_power = phase->readings.fundamental_reactive_power + ((evaluate_fundamental_reactive_power() - phase->readings.fundamental_reactive_power) >> AVERAGE) ;
   \   0000E8   B012....     CALL    #evaluate_fundamental_reactive_power
   \   0000EC   1C82....     SUB.W   &working_data + 32, R12
   \   0000F0   1D72....     SUBC.W  &working_data + 34, R13
   \   0000F4   0D11         RRA.W   R13
   \   0000F6   0C10         RRC.W   R12
   \   0000F8   0D11         RRA.W   R13
   \   0000FA   0C10         RRC.W   R12
   \   0000FC   0D11         RRA.W   R13
   \   0000FE   0C10         RRC.W   R12
   \   000100   825C....     ADD.W   R12, &working_data + 32
   \   000104   826D....     ADDC.W  R13, &working_data + 34
   \   000108   103C         JMP     ??calculate_phase_readings_3
   1435                #endif
   1436            
   1437              }
   1438              else
   1439              {
   1440                #if defined(FUNDAMENTAL_ACTIVE_POWER_SUPPORT)
   1441                phase->readings.fundamental_active_power = 0;
   \                     ??calculate_phase_readings_2:
   \   00010A   8243....     MOV.W   #0x0, &working_data + 24
   \   00010E   8243....     MOV.W   #0x0, &working_data + 26
   1442                #endif
   1443                #if defined(REACTIVE_POWER_SUPPORT)
   1444                phase->readings.reactive_power = 0;
   \   000112   8243....     MOV.W   #0x0, &working_data + 28
   \   000116   8243....     MOV.W   #0x0, &working_data + 30
   1445                #endif
   1446                #if defined(FUNDAMENTAL_REACTIVE_POWER_SUPPORT)
   1447                phase->readings.fundamental_reactive_power = 0;
   \   00011A   8243....     MOV.W   #0x0, &working_data + 32
   \   00011E   8243....     MOV.W   #0x0, &working_data + 34
   1448                #endif
   1449            
   1450                #if defined(APPARENT_POWER_SUPPORT)
   1451                phase->readings.apparent_power = 0;
   \   000122   8243....     MOV.W   #0x0, &working_data + 36
   \   000126   8243....     MOV.W   #0x0, &working_data + 38
   1452                #endif
   1453              }
   1454              
   1455              #if defined(VRMS_SUPPORT)
   1456          //    phase->readings.V_rms = evaluate_rms_voltage();
   1457              phase->readings.V_rms = phase->readings.V_rms + ((evaluate_rms_voltage() - phase->readings.V_rms) >> AVERAGE);
   \                     ??calculate_phase_readings_3:
   \   00012A   B012....     CALL    #evaluate_rms_voltage
   \   00012E   1C82....     SUB.W   &working_data, R12
   \   000132   1D72....     SUBC.W  &working_data + 2, R13
   \   000136   0D11         RRA.W   R13
   \   000138   0C10         RRC.W   R12
   \   00013A   0D11         RRA.W   R13
   \   00013C   0C10         RRC.W   R12
   \   00013E   0D11         RRA.W   R13
   \   000140   0C10         RRC.W   R12
   \   000142   825C....     ADD.W   R12, &working_data
   \   000146   826D....     ADDC.W  R13, &working_data + 2
   1458              #endif
   1459          
   1460              if (!(phase->status & PHASE_STATUS_DC_MODE))
   \   00014A   8293....     CMP.W   #0x0, &working_data + 360
   \   00014E   1A38         JL      ??calculate_phase_readings_4
   1461              {
   1462                #if defined(FUNDAMENTAL_VRMS_SUPPORT)
   1463          //      phase->readings.fundamental_V_rms = evaluate_fundamental_rms_voltage();
   1464                phase->readings.fundamental_V_rms = phase->readings.fundamental_V_rms + ((evaluate_fundamental_rms_voltage() - phase->readings.fundamental_V_rms) >> AVERAGE);
   \   000150   B012....     CALL    #evaluate_fundamental_rms_voltage
   \   000154   1C82....     SUB.W   &working_data + 4, R12
   \   000158   1D72....     SUBC.W  &working_data + 6, R13
   \   00015C   0D11         RRA.W   R13
   \   00015E   0C10         RRC.W   R12
   \   000160   0D11         RRA.W   R13
   \   000162   0C10         RRC.W   R12
   \   000164   0D11         RRA.W   R13
   \   000166   0C10         RRC.W   R12
   \   000168   825C....     ADD.W   R12, &working_data + 4
   \   00016C   826D....     ADDC.W  R13, &working_data + 6
   1465                #endif
   1466                #if defined(VOLTAGE_THD_SUPPORT)
   1467          //      phase->readings.voltage_thd = evaluate_voltage_thd();
   1468                phase->readings.voltage_thd = phase->readings.voltage_thd + ((evaluate_voltage_thd() - phase->readings.voltage_thd) >> AVERAGE);
   \   000170   B012....     CALL    #evaluate_voltage_thd
   \   000174   1C82....     SUB.W   &working_data + 8, R12
   \   000178   0C11         RRA.W   R12
   \   00017A   0C11         RRA.W   R12
   \   00017C   0C11         RRA.W   R12
   \   00017E   825C....     ADD.W   R12, &working_data + 8
   \   000182   063C         JMP     ??calculate_phase_readings_5
   1469                #endif
   1470              }
   1471              else
   1472              {
   1473                #if defined(FUNDAMENTAL_VRMS_SUPPORT)
   1474                phase->readings.fundamental_V_rms = 0;
   \                     ??calculate_phase_readings_4:
   \   000184   8243....     MOV.W   #0x0, &working_data + 4
   \   000188   8243....     MOV.W   #0x0, &working_data + 6
   1475                #endif
   1476                #if defined(VOLTAGE_THD_SUPPORT)
   1477                phase->readings.voltage_thd = 0;
   \   00018C   8243....     MOV.W   #0x0, &working_data + 8
   1478                #endif
   1479              }
   1480          
   1481          
   1482              #if defined(IRMS_SUPPORT)
   1483          //    phase->readings.I_rms = evaluate_rms_current();
   1484              phase->readings.I_rms = phase->readings.I_rms + ((evaluate_rms_current() - phase->readings.I_rms) >> AVERAGE);
   \                     ??calculate_phase_readings_5:
   \   000190   B012....     CALL    #evaluate_rms_current
   \   000194   1C82....     SUB.W   &working_data + 10, R12
   \   000198   1D72....     SUBC.W  &working_data + 12, R13
   \   00019C   0D11         RRA.W   R13
   \   00019E   0C10         RRC.W   R12
   \   0001A0   0D11         RRA.W   R13
   \   0001A2   0C10         RRC.W   R12
   \   0001A4   0D11         RRA.W   R13
   \   0001A6   0C10         RRC.W   R12
   \   0001A8   825C....     ADD.W   R12, &working_data + 10
   \   0001AC   826D....     ADDC.W  R13, &working_data + 12
   1485              #endif
   1486              
   1487              if (!(phase->status & PHASE_STATUS_DC_MODE))
   \   0001B0   8293....     CMP.W   #0x0, &working_data + 360
   \   0001B4   6B38         JL      ??calculate_phase_readings_6
   1488              {
   1489                #if defined(CAPACITOR_COMPENSATE_ON)
   1490          //      phase->readings.I_rms = capacitor_compensate (ph);
   1491                    #if defined(APPARENT_POWER_SUPPORT)
   1492                phase->readings.apparent_power = ((int64_t)(phase->readings.V_rms) * phase->readings.I_rms) / 1000000LL;
   \   0001B6   38404042     MOV.W   #0x4240, R8
   \   0001BA   39400F00     MOV.W   #0xf, R9
   \   0001BE   0A43         MOV.W   #0x0, R10
   \   0001C0   0B43         MOV.W   #0x0, R11
   \   0001C2   1C42....     MOV.W   &working_data, R12
   \   0001C6   1D42....     MOV.W   &working_data + 2, R13
   \   0001CA   1E42....     MOV.W   &working_data + 10, R14
   \   0001CE   1F42....     MOV.W   &working_data + 12, R15
   \   0001D2   B012....     CALL    #_Mul32s32sto64i
   \   0001D6   B012....     CALL    #_Div64s
   \   0001DA   824C....     MOV.W   R12, &working_data + 36
   \   0001DE   824D....     MOV.W   R13, &working_data + 38
   1493                    #endif
   1494                #else
   1495                    #if defined(APPARENT_POWER_SUPPORT)
   1496                //      ph-ase->readings.apparent_power = evaluate_apparent_power();
   1497                      phase->readings.apparent_power = phase->readings.apparent_power + ((evaluate_apparent_power() - phase->readings.apparent_power) >> AVERAGE);
   1498                    #endif
   1499                #endif
   1500          
   1501                #if defined(FUNDAMENTAL_IRMS_SUPPORT)
   1502          //      phase->readings.fundamental_I_rms = evaluate_fundamental_rms_current();
   1503                phase->readings.fundamental_I_rms = phase->readings.fundamental_I_rms + ((evaluate_fundamental_rms_current() - phase->readings.fundamental_I_rms) >> AVERAGE);
   \   0001E2   B012....     CALL    #evaluate_fundamental_rms_current
   \   0001E6   1C82....     SUB.W   &working_data + 14, R12
   \   0001EA   1D72....     SUBC.W  &working_data + 16, R13
   \   0001EE   0D11         RRA.W   R13
   \   0001F0   0C10         RRC.W   R12
   \   0001F2   0D11         RRA.W   R13
   \   0001F4   0C10         RRC.W   R12
   \   0001F6   0D11         RRA.W   R13
   \   0001F8   0C10         RRC.W   R12
   \   0001FA   825C....     ADD.W   R12, &working_data + 14
   \   0001FE   826D....     ADDC.W  R13, &working_data + 16
   1504                #endif
   1505                #if defined(CURRENT_THD_SUPPORT)
   1506          //      phase->readings.current_thd = evaluate_current_thd();
   1507                phase->readings.current_thd = phase->readings.current_thd + ((evaluate_current_thd() - phase->readings.current_thd) >> AVERAGE);
   \   000202   B012....     CALL    #evaluate_current_thd
   \   000206   1C82....     SUB.W   &working_data + 18, R12
   \   00020A   0C11         RRA.W   R12
   \   00020C   0C11         RRA.W   R12
   \   00020E   0C11         RRA.W   R12
   \   000210   825C....     ADD.W   R12, &working_data + 18
   1508                #endif
   1509          
   1510                #if defined(POWER_FACTOR_SUPPORT)
   1511                /* The power factor should be calculated last */
   1512                phase->readings.power_factor = evaluate_power_factor();
   \   000214   B012....     CALL    #evaluate_power_factor
   \   000218   824C....     MOV.W   R12, &working_data + 42
   1513                #endif
   1514          
   1515                #if defined(MAINS_FREQUENCY_SUPPORT)
   1516                phase->readings.frequency = evaluate_mains_frequency();
   \   00021C   1842....     MOV.W   &working_data + 350, R8
   \   000220   1742....     MOV.W   &working_data + 352, R7
   \   000224   0E47         MOV.W   R7, R14
   \   000226   12C3         CLRC
   \   000228   0E10         RRC.W   R14
   \   00022A   0E11         RRA.W   R14
   \   00022C   3E508000     ADD.W   #0x80, R14
   \   000230   0F4E         MOV.W   R14, R15
   \   000232   8F10         SWPB    R15
   \   000234   8F11         SXT     R15
   \   000236   2F53         ADD.W   #0x2, R15
   \   000238   824F....     MOV.W   R15, &working_data + 332
   \   00023C   3B407F00     MOV.W   #0x7f, R11
   \   000240   4E11         RRA.B   R14
   \   000242   4F4E         MOV.B   R14, R15
   \   000244   8F11         SXT     R15
   \   000246   0FFB         AND.W   R11, R15
   \   000248   0E4B         MOV.W   R11, R14
   \   00024A   0E8F         SUB.W   R15, R14
   \   00024C   0E5E         RLA.W   R14
   \   00024E   0E5E         RLA.W   R14
   \   000250   924E........ MOV.W   fir_coeffs(R14), &working_data + 334
   \   000256   924E........ MOV.W   fir_coeffs + 2(R14), &working_data + 336
   \   00025C   0947         MOV.W   R7, R9
   \   00025E   0A43         MOV.W   #0x0, R10
   \   000260   0B43         MOV.W   #0x0, R11
   \   000262   0C43         MOV.W   #0x0, R12
   \   000264   0D43         MOV.W   #0x0, R13
   \   000266   0E43         MOV.W   #0x0, R14
   \   000268   3F400001     MOV.W   #0x100, R15
   \   00026C   B012....     CALL    #_Div64s
   \   000270   824C....     MOV.W   R12, &working_data + 192
   \   000274   824D....     MOV.W   R13, &working_data + 194
   1517                #endif
   1518              }
   \   000278   0C43         MOV.W   #0x0, R12
   \   00027A   3D40350C     MOV.W   #0xc35, R13
   \   00027E   0E47         MOV.W   R7, R14
   \   000280   0F43         MOV.W   #0x0, R15
   \   000282   B012....     CALL    #?DivMod32u
   \   000286   824C....     MOV.W   R12, &working_data + 40
   \   00028A   0A3C         JMP     ??calculate_phase_readings_7
   1519              else
   1520              {
   1521                #if defined(FUNDAMENTAL_IRMS_SUPPORT)
   1522                phase->readings.fundamental_I_rms = 0;
   \                     ??calculate_phase_readings_6:
   \   00028C   8243....     MOV.W   #0x0, &working_data + 14
   \   000290   8243....     MOV.W   #0x0, &working_data + 16
   1523                #endif
   1524                #if defined(CURRENT_THD_SUPPORT)
   1525                phase->readings.current_thd = 0;
   \   000294   8243....     MOV.W   #0x0, &working_data + 18
   1526                #endif
   1527          
   1528                #if defined(POWER_FACTOR_SUPPORT)
   1529                /* The power factor should be calculated last */
   1530                phase->readings.power_factor = 0;
   \   000298   8243....     MOV.W   #0x0, &working_data + 42
   1531                #endif
   1532          
   1533                #if defined(MAINS_FREQUENCY_SUPPORT)
   1534                phase->readings.frequency = 0;
   \   00029C   8243....     MOV.W   #0x0, &working_data + 40
   1535                #endif
   1536              }
   1537          
   1538              #if defined(ENERGY_SUPPORT)  ||  defined(TOTAL_ENERGY_SUPPORT)
   1539              accumulate_phase_energies();
   \                     ??calculate_phase_readings_7:
   \   0002A0   B012....     CALL    #accumulate_phase_energies
   1540              #endif
   1541          
   1542              #if defined(SAG_SWELL_SUPPORT)
   1543              sag_swell_control();
   1544              #endif
   1545              
   1546          #else
   1547              struct phase_parms_s *phase;
   1548              struct phase_calibration_data_s const *phase_cal;
   1549          
   1550              #if defined(LIMP_MODE_SUPPORT)
   1551              if (operating_mode == OPERATING_MODE_LIMP)
   1552                  return calculate_limp_phase_readings(ph);
   1553              #endif
   1554              phase = &working_data.phases[ph];
   1555              phase_cal = &cal_info->phases[ph];
   1556          
   1557              phase->readings.active_power = evaluate_active_power(phase, phase_cal);
   1558              #if defined(TOTAL_ACTIVE_POWER_SUPPORT)
   1559              working_data.totals.readings.active_power = working_data.phases[0].readings.active_power;
   1560                  #if NUM_PHASES >= 2
   1561              working_data.totals.readings.active_power += working_data.phases[1].readings.active_power;
   1562                  #endif
   1563                  #if NUM_PHASES >= 3
   1564              working_data.totals.readings.active_power += working_data.phases[2].readings.active_power;
   1565                  #endif
   1566              #endif
   1567              
   1568              #if defined(FUNDAMENTAL_ACTIVE_POWER_SUPPORT)
   1569              phase->readings.fundamental_active_power = evaluate_fundamental_active_power(phase, phase_cal);
   1570              #endif
   1571          
   1572              #if defined(REACTIVE_POWER_SUPPORT)
   1573              phase->readings.reactive_power = evaluate_reactive_power(phase, phase_cal);
   1574                  #if defined(TOTAL_REACTIVE_POWER_SUPPORT)
   1575              working_data.totals.readings.reactive_power = working_data.phases[0].readings.reactive_power;
   1576                      #if NUM_PHASES >= 2
   1577              working_data.totals.readings.reactive_power += working_data.phases[1].readings.reactive_power;
   1578                      #endif
   1579                      #if NUM_PHASES >= 3
   1580              working_data.totals.readings.reactive_power += working_data.phases[2].readings.reactive_power;
   1581                      #endif
   1582                  #endif
   1583              #endif
   1584              #if defined(FUNDAMENTAL_REACTIVE_POWER_SUPPORT)
   1585              phase->readings.fundamental_reactive_power = evaluate_fundamental_reactive_power(phase, phase_cal);
   1586              #endif
   1587          
   1588              #if defined(APPARENT_POWER_SUPPORT)
   1589              phase->readings.apparent_power = evaluate_apparent_power(phase, phase_cal);
   1590                  #if defined(TOTAL_APPARENT_POWER_SUPPORT)
   1591              working_data.totals.readings.apparent_power = working_data.phases[0].readings.apparent_power;
   1592                      #if NUM_PHASES >= 2
   1593              working_data.totals.readings.apparent_power += working_data.phases[1].readings.apparent_power;
   1594                      #endif
   1595                      #if NUM_PHASES >= 3
   1596              working_data.totals.readings.apparent_power += working_data.phases[2].readings.apparent_power;
   1597                      #endif
   1598                  #endif
   1599              #endif
   1600          
   1601              #if defined(VRMS_SUPPORT)
   1602              phase->readings.V_rms = evaluate_rms_voltage(phase, phase_cal);
   1603              #endif
   1604              #if defined(FUNDAMENTAL_VRMS_SUPPORT)
   1605              phase->readings.fundamental_V_rms = evaluate_fundamental_rms_voltage(phase, phase_cal);
   1606              #endif
   1607              #if defined(VOLTAGE_THD_SUPPORT)
   1608              phase->readings.voltage_thd = evaluate_voltage_thd(phase, phase_cal);
   1609              #endif
   1610          
   1611              #if defined(IRMS_SUPPORT)
   1612              phase->readings.I_rms = evaluate_rms_current(phase, phase_cal, ph);
   1613              #endif
   1614              #if defined(FUNDAMENTAL_IRMS_SUPPORT)
   1615              phase->readings.fundamental_I_rms = evaluate_fundamental_rms_current(phase, phase_cal);
   1616              #endif
   1617              #if defined(CURRENT_THD_SUPPORT)
   1618              phase->readings.current_thd = evaluate_current_thd(phase, phase_cal);
   1619              #endif
   1620          
   1621              #if defined(POWER_FACTOR_SUPPORT)
   1622              /* The power factor should be calculated last */
   1623              phase->readings.power_factor = evaluate_power_factor(phase, phase_cal);
   1624              #endif
   1625          
   1626              #if defined(MAINS_FREQUENCY_SUPPORT)
   1627              phase->readings.frequency = evaluate_mains_frequency(phase, phase_cal);
   1628              #endif
   1629          
   1630              #if defined(ENERGY_SUPPORT)
   1631              accumulate_phase_energies(phase, phase_cal);
   1632              #endif
   1633          
   1634              #if defined(TOTAL_ENERGY_SUPPORT)
   1635              accumulate_total_energies(phase, phase_cal);
   1636              #endif
   1637          
   1638              #if defined(SAG_SWELL_SUPPORT)
   1639              sag_swell_control(phase, phase_cal);
   1640              #endif
   1641          #endif
   1642          
   1643          #if defined(TEMPERATURE_SUPPORT)
   1644              #if NUM_PHASES > 1
   1645              if (ph == 0)
   1646              #endif
   1647                  evaluate_temperature();
   \   0002A4   1E42....     MOV.W   &raw_temperature_from_adc, R14
   \   0002A8   1E82....     SUB.W   &nv_parms + 30, R14
   \   0002AC   0F4E         MOV.W   R14, R15
   \   0002AE   3FE3         XOR.W   #0xffff, R15
   \   0002B0   0F5F         RLA.W   R15
   \   0002B2   0F7F         SUBC.W  R15, R15
   \   0002B4   0212         PUSH.W  SR
   \   0002B6   32C2         DINT
   \   0002B8   0343         NOP
   \   0002BA   824E3001     MOV.W   R14, &0x130
   \   0002BE   B24064003801 MOV.W   #0x64, &0x138
   \   0002C4   1C423A01     MOV.W   &0x13a, R12
   \   0002C8   92423C013A01 MOV.W   &0x13c, &0x13a
   \   0002CE   824F3401     MOV.W   R15, &0x134
   \   0002D2   B24064003801 MOV.W   #0x64, &0x138
   \   0002D8   1D423A01     MOV.W   &0x13a, R13
   \   0002DC   3241         POP.W   SR
   \   0002DE   1E42....     MOV.W   &nv_parms + 32, R14
   \   0002E2   0F43         MOV.W   #0x0, R15
   \   0002E4   B012....     CALL    #?DivMod32s
   \   0002E8   1C52....     ADD.W   &nv_parms + 28, R12
   \   0002EC   824C....     MOV.W   R12, &temperature_in_celsius
   1648          #endif
   1649              dp = phase->metrology.dp_set;
   \   0002F0   5B42....     MOV.B   &working_data + 359, R11
   \   0002F4   8B11         SXT     R11
   1650              memset(&phase->metrology.dot_prod[dp], 0, sizeof(phase->metrology.dot_prod[0]));
   \   0002F6   3E400E00     MOV.W   #0xe, R14
   \   0002FA   0D43         MOV.W   #0x0, R13
   \   0002FC   0C4B         MOV.W   R11, R12
   \   0002FE   0C5C         RLA.W   R12
   \   000300   0F4C         MOV.W   R12, R15
   \   000302   0C5C         RLA.W   R12
   \   000304   0F5C         ADD.W   R12, R15
   \   000306   0C5C         RLA.W   R12
   \   000308   0C5F         ADD.W   R15, R12
   \   00030A   3C50....     ADD.W   #working_data + 202, R12
   \   00030E   B012....     CALL    #memset
   1651              memset(&phase->metrology.current[0].dot_prod[dp], 0, sizeof(phase->metrology.current[0].dot_prod[0]));
   \   000312   3E402A00     MOV.W   #0x2a, R14
   \   000316   0D43         MOV.W   #0x0, R13
   \   000318   0B5B         RLA.W   R11
   \   00031A   0F4B         MOV.W   R11, R15
   \   00031C   0B5B         RLA.W   R11
   \   00031E   0B5B         RLA.W   R11
   \   000320   0F5B         ADD.W   R11, R15
   \   000322   0B5B         RLA.W   R11
   \   000324   0B5B         RLA.W   R11
   \   000326   0B5F         ADD.W   R15, R11
   \   000328   3B50....     ADD.W   #working_data + 244, R11
   \   00032C   0C4B         MOV.W   R11, R12
   \   00032E   B012....     CALL    #memset
   1652          #if NUM_PHASES == 1  &&  defined(NEUTRAL_MONITOR_SUPPORT)
   1653              memset(&phase->metrology.current[1].dot_prod[dp], 0, sizeof(phase->metrology.current[1].dot_prod[0]));
   1654          #endif
   1655          
   1656              FOREGROUND_PROCESS_OFF ();
   \   000332   B012....     CALL    #FOREGROUND_PROCESS_OFF
   1657              
   1658              return phase->readings.active_power;
   \   000336   1C42....     MOV.W   &working_data + 20, R12
   \   00033A   1D42....     MOV.W   &working_data + 22, R13
   \   00033E   3040....     BR      #?Epilogue6
   1659          }
   1660          
   1661          #if NUM_PHASES > 1  &&  defined(NEUTRAL_MONITOR_SUPPORT)
   1662          /* Calculate the neutral readings for a 3-phase meter with neutral monitoring. */
   1663          void calculate_neutral_readings(void)
   1664          {
   1665              int dp;
   1666          
   1667              #if defined(IRMS_SUPPORT)
   1668              working_data.neutral.readings.I_rms = evaluate_neutral_rms_current();
   1669              #endif
   1670              #if defined(RESIDUAL_IRMS_SUPPORT)
   1671              working_data.neutral.readings.residual_I_rms = evaluate_residual_3phase_rms_current();
   1672              #endif
   1673              dp = working_data.neutral.metrology.dp_set;
   1674              memset(&working_data.neutral.metrology.dot_prod[dp], 0, sizeof(working_data.neutral.metrology.dot_prod[0]));
   1675          }
   1676          #endif
   1677          

   \                                 In  segment CODE, align 2
   1678          void align_metrology_with_calibration_data(void)
   \                     align_metrology_with_calibration_data:
   1679          {
   1680          #if NUM_PHASES > 1
   1681              int ph;
   1682              static struct phase_parms_s *phase;
   1683              static struct phase_calibration_data_s const *phase_cal;
   1684          #endif
   1685          
   1686              metrology_disable_analog_front_end();
   \   000000   B012....     CALL    #metrology_disable_analog_front_end
   1687              metrology_init_analog_front_end_normal_mode();
   \   000004   B012....     CALL    #metrology_init_analog_front_end_normal_mode
   1688          
   1689          #if NUM_PHASES > 1
   1690              phase = working_data.phases;
   1691              phase_cal = cal_info->phases;
   1692              for (ph = 0;  ph < NUM_PHASES;  ph++, phase++, phase_cal++)
   1693          #endif
   1694                  set_sd_phase_correction(&phase->metrology.current[0].in_phase_correction, ph, phase_cal->current[0].phase_correction);
   \   000008   1E42....     MOV.W   &nv_parms + 10, R14
   \   00000C   C293....     CMP.B   #0x0, &operating_mode
   \   000010   0620         JNE     ??align_metrology_with_calibration_data_0
   \   000012   5F42....     MOV.B   &working_data + 330, R15
   \   000016   4F8E         SUB.B   R14, R15
   \   000018   0224         JEQ     ??align_metrology_with_calibration_data_0
   \   00001A   C24FB900     MOV.B   R15, &0xb9
   \                     ??align_metrology_with_calibration_data_0:
   \   00001E   2D43         MOV.W   #0x2, R13
   \   000020   0F4E         MOV.W   R14, R15
   \   000022   8F10         SWPB    R15
   \   000024   8F11         SXT     R15
   \   000026   0D8F         SUB.W   R15, R13
   \   000028   824D....     MOV.W   R13, &working_data + 328
   \   00002C   7EF3         AND.B   #0xff, R14
   \   00002E   824E....     MOV.W   R14, &working_data + 330
   1695          #if NUM_PHASES == 1  &&  defined(NEUTRAL_MONITOR_SUPPORT)
   1696              set_sd_phase_correction(&phase->metrology.current[1].in_phase_correction, NUM_PHASES, phase_cal->current[1].phase_correction);
   1697          #endif
   1698          
   1699          
   1700              metrology_init_from_nv_data ();
   \   000032   3040....     BR      #metrology_init_from_nv_data
   1701          //    return 0;
   1702          }

   Maximum stack usage in bytes:

   CSTACK Function
   ------ --------
     20   accumulate_phase_energies
       20   -> _Div64s
      2   align_metrology_with_calibration_data
        2   -> metrology_disable_analog_front_end
        2   -> metrology_init_analog_front_end_normal_mode
        2   -> metrology_init_from_nv_data
     16   calculate_phase_readings
       14   -> FOREGROUND_PROCESS_OFF
       14   -> FOREGROUND_PROCESS_ON
       14   -> _Div64s
       14   -> accumulate_phase_energies
       14   -> evaluate_current_thd
       14   -> evaluate_fundamental_active_power
       14   -> evaluate_fundamental_reactive_power
       14   -> evaluate_fundamental_rms_current
       14   -> evaluate_fundamental_rms_voltage
       14   -> evaluate_power_factor
       14   -> evaluate_reactive_power
       14   -> evaluate_rms_current
       14   -> evaluate_rms_voltage
       14   -> evaluate_voltage_thd
       14   -> memset
       14   -> mul48_32_16
     18   evaluate_current_thd
       18   -> _Div64s
       18   -> isqrt64
     16   evaluate_fundamental_active_power
       16   -> _Div64s
       16   -> div48
       16   -> mul48_32_16
     16   evaluate_fundamental_reactive_power
       16   -> _Div64s
       16   -> div48
       16   -> mul48_32_16
     26   evaluate_fundamental_rms_current
       18   -> _Div64u
       18   -> isqrt64
      6   evaluate_fundamental_rms_voltage
        6   -> div48
        6   -> mul48u_32_16
        6   -> q1_15_mul
      6   evaluate_power_factor
     10   evaluate_reactive_power
       10   -> _Div64s
       10   -> mul48_32_16
       10   -> q1_15_mul
     14   evaluate_rms_current
       14   -> _Div64s
       14   -> isqrt64
       14   -> mul48u_32_16
      2   evaluate_rms_voltage
        2   -> div48
        2   -> isqrt32
        2   -> mul48u_32_16
     18   evaluate_voltage_thd
       18   -> _Div64s
       18   -> isqrt64
     20   integrate_power_to_energy
       20   -> _Div64s
      2   set_phase_correction
      2   set_sd_phase_correction


   Segment part sizes:

   Bytes  Function/Label
   -----  --------------
       6  ?Subroutine0
       1  SD24PRE1
     264  accumulate_phase_energies
      54  align_metrology_with_calibration_data
     834  calculate_phase_readings
     190  evaluate_current_thd
     152  evaluate_fundamental_active_power
     152  evaluate_fundamental_reactive_power
     230  evaluate_fundamental_rms_current
     102  evaluate_fundamental_rms_voltage
     206  evaluate_power_factor
     156  evaluate_reactive_power
     218  evaluate_rms_current
     106  evaluate_rms_voltage
     190  evaluate_voltage_thd
     158  integrate_power_to_energy
       2  metrology_state
       1  operating_mode
       2  sd_locations
      50  set_phase_correction
      46  set_sd_phase_correction
     362  working_data

 
 3 114 bytes in segment CODE
     1 byte  in segment DATA16_AN
     2 bytes in segment DATA16_C
   365 bytes in segment DATA16_Z
 
 3 114 bytes of CODE  memory
     2 bytes of CONST memory
   365 bytes of DATA  memory (+ 1 byte shared)

Errors: none
Warnings: 2
