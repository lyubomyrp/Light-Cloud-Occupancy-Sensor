///////////////////////////////////////////////////////////////////////////////
//                                                                            /
// IAR C/C++ Compiler V5.52.1.50724/W32 for MSP430      07/Jul/2014  17:16:20 /
// Copyright 1996-2013 IAR Systems AB.                                        /
//                                                                            /
//    __rt_version  =  3                                                      /
//    __double_size =  32                                                     /
//    __reg_r4      =  free                                                   /
//    __reg_r5      =  free                                                   /
//    __pic         =  no                                                     /
//    __core        =  430                                                    /
//    Source file   =  C:\Users\a0283112\Desktop\Submeter i2040               /
//                     8k_DC_THD_AUTO_OSR_IAR5.5\emeter-metrology\src\metrolo /
//                     gy-setup.c                                             /
//    Command line  =  "C:\Users\a0283112\Desktop\Submeter i2040              /
//                     8k_DC_THD_AUTO_OSR_IAR5.5\emeter-metrology\src\metrolo /
//                     gy-setup.c" -D __MSP430__ -lCN                         /
//                     "C:\Users\a0283112\Desktop\Submeter i2040              /
//                     8k_DC_THD_AUTO_OSR_IAR5.5\emeter-metrology\emeter-metr /
//                     ology-i2041\Debug\List\" -lA                           /
//                     "C:\Users\a0283112\Desktop\Submeter i2040              /
//                     8k_DC_THD_AUTO_OSR_IAR5.5\emeter-metrology\emeter-metr /
//                     ology-i2041\Debug\List\" -o                            /
//                     "C:\Users\a0283112\Desktop\Submeter i2040              /
//                     8k_DC_THD_AUTO_OSR_IAR5.5\emeter-metrology\emeter-metr /
//                     ology-i2041\Debug\Obj\" --debug -D__MSP430I2041__ -e   /
//                     --double=32 --dlib_config "C:\Program Files (x86)\IAR  /
//                     Systems\Embedded Workbench                             /
//                     6.5_0\430\LIB\DLIB\dl430fn.h" --library_module -I      /
//                     "C:\Users\a0283112\Desktop\Submeter i2040              /
//                     8k_DC_THD_AUTO_OSR_IAR5.5\emeter-metrology\emeter-metr /
//                     ology-i2041/../../emeter-toolkit/include\" -I          /
//                     "C:\Users\a0283112\Desktop\Submeter i2040              /
//                     8k_DC_THD_AUTO_OSR_IAR5.5\emeter-metrology\emeter-metr /
//                     ology-i2041/../include\" -I                            /
//                     "C:\Users\a0283112\Desktop\Submeter i2040              /
//                     8k_DC_THD_AUTO_OSR_IAR5.5\emeter-metrology\emeter-metr /
//                     ology-i2041\" -Ohs --multiplier=16s                    /
//    List file     =  C:\Users\a0283112\Desktop\Submeter i2040               /
//                     8k_DC_THD_AUTO_OSR_IAR5.5\emeter-metrology\emeter-metr /
//                     ology-i2041\Debug\List\metrology-setup.s43             /
//                                                                            /
//                                                                            /
///////////////////////////////////////////////////////////////////////////////

        MODULE `metrology-setup`

        RTMODEL "__SystemLibrary", "DLib"
        RTMODEL "__core", "430"
        RTMODEL "__dlib_full_locale_support", "0"
        RTMODEL "__double_size", "32"
        RTMODEL "__pic", "no"
        RTMODEL "__reg_r4", "free"
        RTMODEL "__reg_r5", "free"
        RTMODEL "__rt_version", "3"

        RSEG CSTACK:DATA:SORT:NOROOT(0)

        EXTERN ?ShiftLeft32_6
        EXTERN ?DivMod32u
        EXTERN ?longjmp_r4
        EXTERN ?longjmp_r5
        EXTERN ?setjmp_r4
        EXTERN ?setjmp_r5

        PUBWEAK ?setjmp_save_r4
        PUBWEAK ?setjmp_save_r5
        PUBWEAK SD24CCTL0
        PUBWEAK SD24CCTL1
        PUBWEAK SD24CCTL2
        PUBWEAK SD24CTL
        PUBWEAK SD24INCTL0
        PUBWEAK SD24INCTL1
        PUBWEAK SD24INCTL2
        PUBWEAK SD24PRE0
        PUBWEAK SD24PRE1
        PUBWEAK SD24PRE2
        PUBWEAK TA0CCTL0
        PUBWEAK TA0CTL
        PUBLIC metrology_disable_analog_front_end
        FUNCTION metrology_disable_analog_front_end,0203H
        ARGFRAME CSTACK, 0, STACK
        LOCFRAME CSTACK, 2, STACK
        PUBLIC metrology_init
        FUNCTION metrology_init,021203H
        ARGFRAME CSTACK, 0, STACK
        LOCFRAME CSTACK, 2, STACK
        PUBLIC metrology_init_analog_front_end_normal_mode
        FUNCTION metrology_init_analog_front_end_normal_mode,0203H
        ARGFRAME CSTACK, 0, STACK
        LOCFRAME CSTACK, 2, STACK
        PUBLIC metrology_init_from_nv_data
        FUNCTION metrology_init_from_nv_data,021203H
        ARGFRAME CSTACK, 0, STACK
        LOCFRAME CSTACK, 4, STACK
        PUBLIC metrology_switch_to_normal_mode
        FUNCTION metrology_switch_to_normal_mode,021203H
        ARGFRAME CSTACK, 0, STACK
        LOCFRAME CSTACK, 2, STACK
        
          CFI Names cfiNames0
          CFI StackFrame CFA SP DATA
          CFI Resource PC:16, SP:16, SR:16, R4:16, R5:16, R6:16, R7:16, R8:16
          CFI Resource R9:16, R10:16, R11:16, R12:16, R13:16, R14:16, R15:16
          CFI EndNames cfiNames0
        
          CFI Common cfiCommon0 Using cfiNames0
          CFI CodeAlign 2
          CFI DataAlign 2
          CFI ReturnAddress PC CODE
          CFI CFA SP+2
          CFI PC Frame(CFA, -2)
          CFI SR Undefined
          CFI R4 SameValue
          CFI R5 SameValue
          CFI R6 SameValue
          CFI R7 SameValue
          CFI R8 SameValue
          CFI R9 SameValue
          CFI R10 SameValue
          CFI R11 SameValue
          CFI R12 Undefined
          CFI R13 Undefined
          CFI R14 Undefined
          CFI R15 Undefined
          CFI EndCommon cfiCommon0
        
        EXTERN nv_parms
        EXTERN calibration_defaults
        EXTERN flash_memcpy
        FUNCTION flash_memcpy,0202H
        EXTERN flash_secure
        FUNCTION flash_secure,0202H
        EXTERN working_data
        EXTERN set_sd_phase_correction
        FUNCTION set_sd_phase_correction,0202H
        EXTERN switch_to_normal_mode
        FUNCTION switch_to_normal_mode,0202H
        EXTERN operating_mode
        EXTERN dc_filter24_init
        FUNCTION dc_filter24_init,0202H
        EXTERN dc_filter16_init
        FUNCTION dc_filter16_init,0202H
        EXTERN resistance_scaling
        EXTERN capacitance_scaling
        EXTERN raw_temperature_from_adc

// C:\Users\a0283112\Desktop\Submeter i2040 8k_DC_THD_AUTO_OSR_IAR5.5\emeter-metrology\src\metrology-setup.c
//    1 /*******************************************************************************
//    2  *  metrology-setup.c -
//    3  *
//    4  *  Copyright (C) 2011 Texas Instruments Incorporated - http://www.ti.com/ 
//    5  * 
//    6  *  Redistribution and use in source and binary forms, with or without 
//    7  *  modification, are permitted provided that the following conditions 
//    8  *  are met:
//    9  *
//   10  *    Redistributions of source code must retain the above copyright 
//   11  *    notice, this list of conditions and the following disclaimer.
//   12  *
//   13  *    Redistributions in binary form must reproduce the above copyright
//   14  *    notice, this list of conditions and the following disclaimer in the 
//   15  *    documentation and/or other materials provided with the   
//   16  *    distribution.
//   17  *
//   18  *    Neither the name of Texas Instruments Incorporated nor the names of
//   19  *    its contributors may be used to endorse or promote products derived
//   20  *    from this software without specific prior written permission.
//   21  *
//   22  *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
//   23  *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
//   24  *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
//   25  *  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT 
//   26  *  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, 
//   27  *  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
//   28  *  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
//   29  *  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
//   30  *  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
//   31  *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
//   32  *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//   33  *
//   34  ******************************************************************************/
//   35 
//   36 #include <inttypes.h>
//   37 #include <stdlib.h>
//   38 #if !defined(__MSP430__)
//   39 #include <stdio.h>
//   40 #include <fcntl.h>
//   41 #include <unistd.h>
//   42 #endif
//   43 #if defined(__GNUC__)
//   44 #include <signal.h>
//   45 #endif
//   46 #include <math.h>
//   47 
//   48 #include <emeter-toolkit.h>

        ASEGN DATA16_AN:DATA:NOROOT,0b0H
// unsigned char volatile SD24INCTL0
SD24INCTL0:
        DS8 1

        ASEGN DATA16_AN:DATA:NOROOT,0b1H
// unsigned char volatile SD24INCTL1
SD24INCTL1:
        DS8 1

        ASEGN DATA16_AN:DATA:NOROOT,0b2H
// unsigned char volatile SD24INCTL2
SD24INCTL2:
        DS8 1

        ASEGN DATA16_AN:DATA:NOROOT,0b8H
// unsigned char volatile SD24PRE0
SD24PRE0:
        DS8 1

        ASEGN DATA16_AN:DATA:NOROOT,0b9H
// unsigned char volatile SD24PRE1
SD24PRE1:
        DS8 1

        ASEGN DATA16_AN:DATA:NOROOT,0baH
// unsigned char volatile SD24PRE2
SD24PRE2:
        DS8 1

        ASEGN DATA16_AN:DATA:NOROOT,0100H
// unsigned short volatile SD24CTL
SD24CTL:
        DS8 2

        ASEGN DATA16_AN:DATA:NOROOT,0102H
// unsigned short volatile SD24CCTL0
SD24CCTL0:
        DS8 2

        ASEGN DATA16_AN:DATA:NOROOT,0104H
// unsigned short volatile SD24CCTL1
SD24CCTL1:
        DS8 2

        ASEGN DATA16_AN:DATA:NOROOT,0106H
// unsigned short volatile SD24CCTL2
SD24CCTL2:
        DS8 2

        ASEGN DATA16_AN:DATA:NOROOT,0160H
// unsigned short volatile TA0CTL
TA0CTL:
        DS8 2

        ASEGN DATA16_AN:DATA:NOROOT,0162H
// unsigned short volatile TA0CCTL0
TA0CCTL0:
        DS8 2
//   49 
//   50 #include "emeter-metrology.h"
//   51 #include "metrology-structs.h"
//   52 #include "metrology-flash.h"
//   53 
//   54 #if defined(WIRE_RESISTANCE_COMPENSATE)
//   55 extern uint32_t resistance_scaling;
//   56 #endif
//   57 
//   58 #if defined(CAPACITOR_COMPENSATE_ON)
//   59 extern uint32_t capacitance_scaling;
//   60 #endif
//   61 
//   62 #if defined(__MSP430_HAS_SD16_2__)  ||  defined(__MSP430_HAS_SD16_3__)
//   63 #define SD16CONF0_FUDGE     0x70
//   64 #define SD16CONF1_FUDGE     0x48    //0x38
//   65 #endif
//   66 
//   67 #define sd_resolve_x(x) THAT_WAS_ ## x
//   68 #define sd_resolve(x) sd_resolve_x(x)
//   69 
//   70 #if defined(__MSP430_HAS_SD24_B__)
//   71 #define sd_set_normal_live_current_mode_(a) \ 
//   72     sd_xxxx_reg(SD_INCTL_, a) = SD_LIVE_CURRENT_GAIN; \ 
//   73     sd_xxxx_reg(SD_CCTL_, a) = SD_DF_1 | SD24SCS_4; \ 
//   74     sd_xxxx_reg(SD_OSR_, a) = OSR - 1; \ 
//   75     sd_xxxx_reg(SD_PRE_, a) = 0;
//   76 #define sd_set_normal_live_current_mode(a) sd_set_normal_live_current_mode_(a)
//   77 
//   78 /*
//   79 #define sd_set_limp_live_current_mode_(a) \ 
//   80     sd_xxxx_reg(SD_INCTL_, a) = SD_LIVE_CURRENT_GAIN; \ 
//   81     sd_xxxx_reg(SD_CCTL_, a) = SD_DF_1 | SD_SNGL | SD_GRP; \ 
//   82     sd_xxxx_reg(SD_OSR_, a) = 32 - 1; \ 
//   83     sd_xxxx_reg(SD_PRE_, a) = 0;
//   84 #define sd_set_limp_live_current_mode(a) sd_set_limp_live_current_mode_(a)
//   85 */
//   86 
//   87 #define sd_set_idle_live_current_mode_(a) \ 
//   88     sd_xxxx_reg(SD_INCTL_, a) = 0; \ 
//   89     sd_xxxx_reg(SD_CCTL_, a) = 0; \ 
//   90     sd_xxxx_reg(SD_OSR_, a) = 0; \ 
//   91     sd_xxxx_reg(SD_PRE_, a) = 0;
//   92 #define sd_set_idle_live_current_mode(a) sd_set_idle_live_current_mode_(a)
//   93 
//   94 
//   95 #define sd_set_normal_neutral_current_mode_(a) \ 
//   96     sd_xxxx_reg(SD_INCTL_, a) = SD_NEUTRAL_CURRENT_GAIN; \ 
//   97     sd_xxxx_reg(SD_CCTL_, a) = SD_DF_1 | SD24SCS_4; \ 
//   98     sd_xxxx_reg(SD_OSR_, a) = OSR - 1; \ 
//   99     sd_xxxx_reg(SD_PRE_, a) = 0;
//  100 #define sd_set_normal_neutral_current_mode(a) sd_set_normal_neutral_current_mode_(a)
//  101 
//  102 /*
//  103 #define sd_set_limp_neutral_current_mode_(a) \ 
//  104     sd_xxxx_reg(SD_INCTL_, a) = SD_NEUTRAL_CURRENT_GAIN; \ 
//  105     sd_xxxx_reg(SD_CCTL_, a) = SD_DF_1 | SD_SNGL | SD_GRP; \ 
//  106     sd_xxxx_reg(SD_OSR_, a) = 32 - 1; \ 
//  107     sd_xxxx_reg(SD_PRE_, a) = 0;
//  108 #define sd_set_limp_neutral_current_mode(a) sd_set_limp_neutral_current_mode_(a)
//  109 */
//  110 
//  111 #define sd_set_idle_neutral_current_mode_(a) \ 
//  112     sd_xxxx_reg(SD_INCTL_, a) = 0; \ 
//  113     sd_xxxx_reg(SD_CCTL_, a) = 0; \ 
//  114     sd_xxxx_reg(SD_OSR_, a) = 0; \ 
//  115     sd_xxxx_reg(SD_PRE_, a) = 0;
//  116 #define sd_set_idle_neutral_current_mode(a) sd_set_idle_neutral_current_mode_(a)
//  117 
//  118 #define sd_set_normal_voltage_mode_(a) \ 
//  119     sd_xxxx_reg(SD_INCTL_, a) = SD_VOLTAGE_GAIN; \ 
//  120     sd_xxxx_reg(SD_CCTL_, a) = SD_DF_1 | SD24ALGN | SD24SCS_4; \ 
//  121     sd_xxxx_reg(SD_OSR_, a) = OSR - 1; \ 
//  122     sd_xxxx_reg(SD_PRE_, a) = 0;
//  123 #define sd_set_normal_voltage_mode(a) sd_set_normal_voltage_mode_(a)
//  124 
//  125 /*
//  126 #define sd_set_limp_voltage_mode_(a) \ 
//  127     sd_xxxx_reg(SD_INCTL_, a) = SD_VOLTAGE_GAIN; \ 
//  128     sd_xxxx_reg(SD_CCTL_, a) = SD_DF_1 | SD_SNGL | SD_GRP; \ 
//  129     sd_xxxx_reg(SD_OSR_, a) = 32 - 1; \ 
//  130     sd_xxxx_reg(SD_PRE_, a) = 0;
//  131 #define sd_set_limp_voltage_mode(a) sd_set_limp_voltage_mode_(a)
//  132 */
//  133 
//  134 #define sd_set_idle_voltage_mode_(a) \ 
//  135     sd_xxxx_reg(SD_INCTL_, a) = 0; \ 
//  136     sd_xxxx_reg(SD_CCTL_, a) = 0; \ 
//  137     sd_xxxx_reg(SD_OSR_, a) = 0; \ 
//  138     sd_xxxx_reg(SD_PRE_, a) = 0;
//  139 #define sd_set_idle_voltage_mode(a) sd_set_idle_voltage_mode_(a)
//  140 
//  141 #else
//  142 
//  143 #define SD_OSR__(x) SD_OSR_ ## x
//  144 #define SD_OSR(x)  SD_OSR__ (x)
//  145 
//  146 #define sd_set_normal_live_current_mode_(a) \ 
//  147     sd_xxxx_reg(SD_INCTL_, a) = SD_INCH_CURRENT | SD_LIVE_CURRENT_GAIN; \ 
//  148       sd_xxxx_reg(SD_CCTL_, a) = (SD_OSR (OSR)) | SD_DF | SD_GRP | SD_IE; \ 
//  149     sd_xxxx_reg(SD_PRE_, a) = 0;
//  150 #define sd_set_normal_live_current_mode(a) sd_set_normal_live_current_mode_(a)
//  151 
//  152 /*
//  153 #define sd_set_limp_live_current_mode_(a) \ 
//  154     sd_xxxx_reg(SD_INCTL_, a) = SD_INCH_CURRENT | SD_LIVE_CURRENT_GAIN; \ 
//  155     sd_xxxx_reg(SD_CCTL_, a) = SD_OSR_32 | SD_DF | SD_SNGL | SD_GRP | SD_IE; \ 
//  156     sd_xxxx_reg(SD_PRE_, a) = 0;
//  157 #define sd_set_limp_live_current_mode(a) sd_set_limp_live_current_mode_(a)
//  158 */
//  159 
//  160 #define sd_set_idle_live_current_mode_(a) \ 
//  161     sd_xxxx_reg(SD_INCTL_, a) = 0; \ 
//  162     sd_xxxx_reg(SD_CCTL_, a) = 0; \ 
//  163     sd_xxxx_reg(SD_PRE_, a) = 0;
//  164 #define sd_set_idle_live_current_mode(a) sd_set_idle_live_current_mode_(a)
//  165 
//  166 #define sd_set_normal_neutral_current_mode_(a) \ 
//  167     sd_xxxx_reg(SD_INCTL_, a) = SD_INCH_CURRENT | SD_NEUTRAL_CURRENT_GAIN; \ 
//  168       sd_xxxx_reg(SD_CCTL_, a) = (SD_OSR (OSR))  | SD_DF | SD_GRP | SD_IE; \ 
//  169     sd_xxxx_reg(SD_PRE_, a) = 0;
//  170 #define sd_set_normal_neutral_current_mode(a) sd_set_normal_neutral_current_mode_(a)
//  171 
//  172 /*
//  173 #define sd_set_limp_neutral_current_mode_(a) \ 
//  174     sd_xxxx_reg(SD_INCTL_, a) = SD_INCH_CURRENT | SD_NEUTRAL_CURRENT_GAIN; \ 
//  175     sd_xxxx_reg(SD_CCTL_, a) = SD_OSR_32 | SD_DF | SD_SNGL | SD_GRP | SD_IE; \ 
//  176     sd_xxxx_reg(SD_PRE_, a) = 0;
//  177 #define sd_set_limp_neutral_current_mode(a) sd_set_limp_neutral_current_mode_(a)
//  178 */
//  179 
//  180 #define sd_set_idle_neutral_current_mode_(a) \ 
//  181     sd_xxxx_reg(SD_INCTL_, a) = 0; \ 
//  182     sd_xxxx_reg(SD_CCTL_, a) = 0; \ 
//  183     sd_xxxx_reg(SD_PRE_, a) = 0;
//  184 #define sd_set_idle_neutral_current_mode(a) sd_set_idle_neutral_current_mode_(a)
//  185 
//  186 #define sd_set_normal_voltage_mode_(a) \ 
//  187     sd_xxxx_reg(SD_INCTL_, a) = SD_INCH_VOLTAGE | SD_VOLTAGE_GAIN; \ 
//  188       sd_xxxx_reg(SD_CCTL_, a) = (SD_OSR (OSR)) | SD_DF | SD_GRP; \ 
//  189     sd_xxxx_reg(SD_PRE_, a) = 0;
//  190 #define sd_set_normal_voltage_mode(a) sd_set_normal_voltage_mode_(a)
//  191 
//  192 /*
//  193 #define sd_set_limp_voltage_mode_(a) \ 
//  194     sd_xxxx_reg(SD_INCTL_, a) = SD_INCH_VOLTAGE | SD_VOLTAGE_GAIN; \ 
//  195     sd_xxxx_reg(SD_CCTL_, a) = SD_OSR_32 | SD_DF | SD_SNGL | SD_GRP | SD_IE; \ 
//  196     sd_xxxx_reg(SD_PRE_, a) = 0;
//  197 #define sd_set_limp_voltage_mode(a) sd_set_limp_voltage_mode_(a)
//  198 */
//  199 
//  200 #define sd_set_idle_voltage_mode_(a) \ 
//  201     sd_xxxx_reg(SD_INCTL_, a) = 0; \ 
//  202     sd_xxxx_reg(SD_CCTL_, a) = 0; \ 
//  203     sd_xxxx_reg(SD_PRE_, a) = 0;
//  204 #define sd_set_idle_voltage_mode(a) sd_set_idle_voltage_mode_(a)
//  205 
//  206 
//  207 #define sd_set_normal_temperature_mode_(a) \ 
//  208     sd_xxxx_reg(SD_INCTL_, a) = SD_INCH_TEMPERATURE | SD_GAIN_TEMPERATURE; \ 
//  209       sd_xxxx_reg(SD_CCTL_, a) = (SD_OSR (OSR)) | SD_DF | SD_GRP; \ 
//  210     sd_xxxx_reg(SD_PRE_, a) = 0;
//  211 #define sd_set_normal_temperature_mode(a) sd_set_normal_temperature_mode_(a)
//  212 #endif
//  213 
//  214 #if NUM_PHASES > 1  &&  defined(__MSP430_HAS_SD24_B3__)  &&  defined(__MSP430_HAS_ADC10_A__)
//  215 extern int16_t dma_adc_buffer[6];
//  216 //extern int16_t dma_adc_buffer[NUM_PHASES];
//  217 #endif
//  218 
//  219 /*
//  220  * Analog front-end initialization routine.
//  221  *
//  222  * Configures the sigma-delta ADC module as analog front-end for
//  223  * a tamper-resistant meter using a current transformer and a
//  224  * shunt as current sensors (see configuration of channel 0 and 1).
//  225  */

        RSEG CODE:CODE:REORDER:NOROOT(1)
//  226 void metrology_init_analog_front_end_normal_mode(void)
metrology_init_analog_front_end_normal_mode:
          CFI Block cfiBlock0 Using cfiCommon0
          CFI Function metrology_init_analog_front_end_normal_mode
//  227 {
//  228 #if NUM_PHASES > 1
//  229     int i;
//  230 #endif
//  231 
//  232     /* The general configuration of the analog front-end,
//  233        that applies to all channels: clock selection (SMCLK) and divider
//  234        settings (depending on SMCLK frequency) and reference voltage
//  235        selections. */
//  236 #if defined(__MSP430_HAS_SD24_B__)
//  237     /* Enable the voltage reference at 2.0V */
//  238     REFCTL0 = REFMSTR | REFVSEL_1 | REFON;
//  239     SD_CTL1 &= ~SD24GRP0SC;
//  240 #else
//  241     sd_xxxx_reg(SD_CCTL_, PHASE_1_VOLTAGE_ADC_CHANNEL) &= ~SD_SC;
        BIC.W   #0x2, &0x102
//  242     sd_xxxx_reg(SD_CCTL_, PHASE_1_CURRENT_ADC_CHANNEL) &= ~SD_SC;
        BIC.W   #0x2, &0x104
//  243     #if !defined(VOLTAGE_SIGNAL_IS_COMMON)
//  244         #if NUM_PHASES >= 2
//  245     sd_xxxx_reg(SD_CCTL_, PHASE_2_VOLTAGE_ADC_CHANNEL) &= ~SD_SC;
//  246     sd_xxxx_reg(SD_CCTL_, PHASE_2_CURRENT_ADC_CHANNEL) &= ~SD_SC;
//  247         #endif
//  248         #if NUM_PHASES >= 3
//  249     sd_xxxx_reg(SD_CCTL_, PHASE_3_VOLTAGE_ADC_CHANNEL) &= ~SD_SC;
//  250     sd_xxxx_reg(SD_CCTL_, PHASE_3_CURRENT_ADC_CHANNEL) &= ~SD_SC;
//  251         #endif
//  252     #else
//  253         #if NUM_PHASES >= 2
//  254 //    sd_xxxx_reg(SD_CCTL_, PHASE_2_VOLTAGE_ADC_CHANNEL) &= ~SD_SC;
//  255     sd_xxxx_reg(SD_CCTL_, PHASE_2_CURRENT_ADC_CHANNEL) &= ~SD_SC;
//  256         #endif
//  257         #if NUM_PHASES >= 3
//  258 //    sd_xxxx_reg(SD_CCTL_, PHASE_3_VOLTAGE_ADC_CHANNEL) &= ~SD_SC;
//  259     sd_xxxx_reg(SD_CCTL_, PHASE_3_CURRENT_ADC_CHANNEL) &= ~SD_SC;
//  260         #endif
//  261     #endif
//  262     #if defined(NEUTRAL_MONITOR_SUPPORT)
//  263     sd_xxxx_reg(SD_CCTL_, NEUTRAL_CURRENT_ADC_CHANNEL) &= ~SD_SC;
//  264     #endif
//  265     
//  266     #if defined (TEMPERATURE_ADC_CHANNEL)
//  267     sd_xxxx_reg(SD_CCTL_, TEMPERATURE_ADC_CHANNEL) &= ~SD_SC;
        BIC.W   #0x2, &0x106
//  268     #endif
//  269 #endif
//  270 
//  271     /* Use the SMCLK. It will need to be divided to produce an ADC clock of 1.048576MHz. The ratio will depend on the
//  272        frequency the SMCLK is set to. Use the internal reference. */
//  273 #if defined(__MSP430_HAS_SD24_B__)
//  274     SD24BCTL0 = SD24SSEL__SMCLK     /* Clock is SMCLK */
//  275               | SD24PDIV_3          /* Divide by 16 => ADC clock: 1.048576MHz */
//  276               | SD24DIV0
//  277               | SD24REFS            /* Use internal reference */
//  278               | SD24OV32;
//  279     SD24BCTL1 = 0;
//  280 #else
//  281     #if defined(__MSP430_HAS_SD24_2__) || defined(__MSP430_HAS_SD24_3__) || defined(__MSP430_HAS_SD24_4__)
//  282     SD24CTL = SD24REFS;
        MOV.W   #0x4, &0x100
//  283     #elif SD_CLOCK_DIVISION == 4
//  284     SD_CTL = SD_SSEL_1 | SD_DIV_2 | SD_REFON;
//  285     #elif SD_CLOCK_DIVISION == 6
//  286     SD_CTL = SD_SSEL_1 | SD_XDIV_1 | SD_DIV_1 | SD_REFON;
//  287     #elif SD_CLOCK_DIVISION == 8
//  288     SD_CTL = SD_SSEL_1 | SD_DIV_3 | SD_REFON;
//  289     #elif SD_CLOCK_DIVISION == 12
//  290     SD_CTL = SD_SSEL_1 | SD_XDIV_1 | SD_DIV_2 | SD_REFON;
//  291     #elif SD_CLOCK_DIVISION == 16
//  292     SD_CTL = SD_SSEL_1 | SD_XDIV_2 | SD_REFON;
//  293     #elif SD_CLOCK_DIVISION == 24
//  294     SD_CTL = SD_SSEL_1 | SD_XDIV_1 | SD_DIV_3 | SD_REFON;
//  295     #endif
//  296     #if defined(SD16CONF0_FUDGE)
//  297     SD16CONF0 = SD16CONF0_FUDGE;
//  298     #endif
//  299     #if defined(SD16CONF1_FUDGE)
//  300     SD16CONF1 = SD16CONF1_FUDGE;
//  301     #endif
//  302 #endif
//  303 
//  304     sd_set_normal_live_current_mode(PHASE_1_CURRENT_ADC_CHANNEL);
        MOV.B   #0x20, &0xb1
        MOV.W   #0x119, &0x104
        MOV.B   #0x0, &0xb9
//  305 #if NUM_PHASES >= 2
//  306     sd_set_normal_live_current_mode(PHASE_2_CURRENT_ADC_CHANNEL);
//  307 #endif
//  308 #if NUM_PHASES >= 3
//  309     sd_set_normal_live_current_mode(PHASE_3_CURRENT_ADC_CHANNEL);
//  310 #endif
//  311 #if NUM_PHASES >= 4
//  312     sd_set_normal_live_current_mode(PHASE_4_CURRENT_ADC_CHANNEL);
//  313 #endif
//  314 #if NUM_PHASES >= 5
//  315     sd_set_normal_live_current_mode(PHASE_5_CURRENT_ADC_CHANNEL);
//  316 #endif
//  317 #if NUM_PHASES >= 6
//  318     sd_set_normal_live_current_mode(PHASE_6_CURRENT_ADC_CHANNEL);
//  319 #endif
//  320 #if defined(NEUTRAL_MONITOR_SUPPORT)
//  321     sd_set_normal_neutral_current_mode(NEUTRAL_CURRENT_ADC_CHANNEL);
//  322 #endif
//  323 // original : #if NUM_PHASES > 1  &&  defined(__MSP430_HAS_SD24_B3__)  &&  defined(__MSP430_HAS_ADC10_A__), modified by mars
//  324 #if NUM_PHASES > 1  &&  defined(__MSP430_HAS_SD24_B3__)  &&  defined(__MSP430_HAS_ADC10_A__) && 0
//  325     /* The ADC10A is going to measure the three voltages. It will be triggered by the SD24B, and
//  326        will deliver the three results by DMA */
//  327     /* Trigger DMA channel 0 from ADCIFG0 */
//  328     DMACTL0 = DMA0TSEL__ADC10IFG0;
//  329     __data16_write_addr((uint16_t) &DMA0SA, (uint32_t) &ADC10MEM0);
//  330     __data16_write_addr((uint16_t) &DMA0DA, (uint32_t) &dma_adc_buffer[0]);
//  331     /* Channels 5 to 0. We only want 5 to 3 really, but the sequencing engine in the ADC10A module
//  332        only supports channel X to channel 0, and currently 5, 4, and 3 are our voltage channels */
//  333     DMA0SZ = 6;
//  334     //DMA0SZ = NUM_PHASES;
//  335     /* Enable, destination address incremented, repeating single transfer. */
//  336     DMA0CTL = DMADT_4 | DMADSTINCR_3 | DMAEN;
//  337     /* Clear pending interrupts to ensure trigger for DMA */
//  338     ADC10IFG = 0;
//  339 
//  340     /* ADC on, ADC10 waits for trigger from the SD24, sampling time 2us 8xADCclk, auto next conv. */
//  341     ADC10CTL0 = ADC10SHT0 | ADC10ON | ADC10MSC;
//  342     #if SD_CLOCK_DIVISION == 8
//  343     /* Triggered by the SD24, SMCLK/2 = 4MHz, Sequence of channels */
//  344     ADC10CTL1 = ADC10SHP | ADC10SHS_3 | ADC10DIV_4 | ADC10SSEL_3 | ADC10CONSEQ_1;
//  345     #endif
//  346     #if SD_CLOCK_DIVISION == 16
//  347     /* Triggered by the SD24, SMCLK/4 = 4MHz, Sequence of channels */
//  348     ADC10CTL1 = ADC10SHP | ADC10SHS_3 | ADC10DIV_2 | ADC10SSEL_3 | ADC10CONSEQ_1;
//  349     #endif
//  350     /* Predivide by 1, 10bit resolution, results are scaled to 16bit signed numbers, so
//  351        Vr- = 0x8000 and Vr+ = 0x7FC0. */
//  352     ADC10CTL2 = ADC10RES | ADC10DF;
//  353     /* Vr- = Vss, Vr+ = Vref+, The sequence of conversions will be ch2 to ch0. */
//  354     ADC10MCTL0 = ADC10SREF_1 | ADC10INCH_5;
//  355     //ADC10MCTL0 = ADC10SREF_1 | ADC10INCH_2;
//  356     /* Start ADC and wait for a trigger from the SD24 */
//  357     ADC10CTL0 |= ADC10ENC;
//  358     SD24BIE |= SD24IE2;
//  359 #else
//  360     /* The three voltages are phase coincident. Only interrupt from one of them. */
//  361     sd_set_normal_voltage_mode(PHASE_1_VOLTAGE_ADC_CHANNEL);
        MOV.B   #0x0, &0xb0
        MOV.W   #0x111, &0x102
        MOV.B   #0x0, &0xb8
//  362     #if !defined(VOLTAGE_SIGNAL_IS_COMMON)
//  363         #if NUM_PHASES >= 2
//  364     sd_set_normal_voltage_mode(PHASE_2_VOLTAGE_ADC_CHANNEL);
//  365         #endif
//  366         #if NUM_PHASES >= 3
//  367     sd_set_normal_voltage_mode(PHASE_3_VOLTAGE_ADC_CHANNEL);
//  368         #endif
//  369     #endif
//  370 #endif
//  371 
//  372 #if defined (TEMPERATURE_ADC_CHANNEL)
//  373     sd_set_normal_temperature_mode (TEMPERATURE_ADC_CHANNEL)
        MOV.B   #0x6, &0xb2
        MOV.W   #0x111, &0x106
        MOV.B   #0x0, &0xba
//  374 #endif
//  375 
//  376 #if NUM_PHASES == 1
//  377     working_data.phases[0].metrology.current[0].in_phase_correction.sd_preloaded_offset = 0;
        MOV.W   #0x0, &working_data + 330
//  378     #if defined(NEUTRAL_MONITOR_SUPPORT)
//  379     working_data.phases[0].metrology.current[1].in_phase_correction.sd_preloaded_offset = 0;
//  380     #endif
//  381 #else
//  382     for (i = 0;  i < NUM_PHASES;  i++)
//  383         working_data.phases[i].metrology.current[0].in_phase_correction.sd_preloaded_offset = 0;
//  384 #endif
//  385 
//  386 #if defined(__MSP430_HAS_SD24_B__)
//  387     #if NUM_PHASES == 3  &&  defined(__MSP430_HAS_SD24_B3__)  &&  defined(__MSP430_HAS_ADC10_A__)
//  388     SD24BTRGCTL = SD24SCS__GROUP0;      /* Trigger generation group 0 +D24TRGIE */
//  389     SD24BCTL1 |= SD24GRP0SC;            /* Start group 0 */
//  390     #else
//  391     SD24BIE = 0x0007;
//  392     #endif
//  393 #else
//  394     sd_xxxx_reg(SD_CCTL_, PHASE_1_VOLTAGE_ADC_CHANNEL) |= SD_IE;
        BIS.W   #0x8, &0x102
//  395     #if NUM_PHASES >= 2
//  396     ?sd_xxxx_reg(SD_CCTL_, PHASE_1_CURRENT_ADC_CHANNEL) |= SD_IE;
//  397     sd_xxxx_reg(SD_CCTL_, PHASE_2_CURRENT_ADC_CHANNEL) |= SD_IE;
//  398     #endif
//  399     #if NUM_PHASES >= 3
//  400     sd_xxxx_reg(SD_CCTL_, PHASE_3_CURRENT_ADC_CHANNEL) |= SD_IE;
//  401     #endif
//  402 #endif
//  403 
//  404     /* We want to start conversion on the last converter in the set */
//  405 #if defined(__MSP430_HAS_SD24_B__)
//  406     SD_CTL1 |= SD24GRP0SC;
//  407 #else
//  408     SD_CCTL_TRIGGER &= ~SD_GRP;
        BIC.W   #0x1, &0x106
//  409     SD_CCTL_TRIGGER |= SD_SC;
        BIS.W   #0x2, &0x106
//  410 #endif
//  411 #if defined(TEMPERATURE_SUPPORT)
//  412     /* Initialise the temperature measurement to the intercept (i.e. 0C), so it doesn't take
//  413        forever to settle. */
//  414 //    raw_temperature_from_adc = ((int32_t) cal_info->temperature_sensor_intercept << 11);
//  415     raw_temperature_from_adc = cal_info->temperature_sensor_intercept;
        MOV.W   &nv_parms + 30, &raw_temperature_from_adc
//  416 #endif
//  417 }
        RET
          CFI EndBlock cfiBlock0
        REQUIRE SD24CCTL0
        REQUIRE SD24CCTL1
        REQUIRE SD24CCTL2
        REQUIRE SD24CTL
        REQUIRE SD24INCTL1
        REQUIRE SD24PRE1
        REQUIRE SD24INCTL0
        REQUIRE SD24PRE0
        REQUIRE SD24INCTL2
        REQUIRE SD24PRE2
//  418 
//  419 #if defined(LIMP_MODE_SUPPORT)
//  420 void metrology_init_analog_front_end_limp_mode(void)
//  421 {
//  422     #if NUM_PHASES > 1
//  423     int i;
//  424     #endif
//  425 
//  426     #if defined(__MSP430_HAS_SD24_B__)
//  427     SD_CTL1 &= ~SD_SC;
//  428     #else
//  429     sd_xxxx_reg(SD_CCTL_, PHASE_1_VOLTAGE_ADC_CHANNEL) &= ~SD_SC;
//  430     sd_xxxx_reg(SD_CCTL_, PHASE_1_CURRENT_ADC_CHANNEL) &= ~SD_SC;
//  431         #if NUM_PHASES >= 2
//  432     sd_xxxx_reg(SD_CCTL_, PHASE_2_VOLTAGE_ADC_CHANNEL) &= ~SD_SC;
//  433     sd_xxxx_reg(SD_CCTL_, PHASE_2_CURRENT_ADC_CHANNEL) &= ~SD_SC;
//  434         #endif
//  435         #if NUM_PHASES >= 3
//  436     sd_xxxx_reg(SD_CCTL_, PHASE_3_VOLTAGE_ADC_CHANNEL) &= ~SD_SC;
//  437     sd_xxxx_reg(SD_CCTL_, PHASE_3_CURRENT_ADC_CHANNEL) &= ~SD_SC;
//  438         #endif
//  439         #if defined(NEUTRAL_MONITOR_SUPPORT)
//  440     sd_xxxx_reg(SD_CCTL_, NEUTRAL_CURRENT_ADC_CHANNEL) &= ~SD_SC;
//  441         #endif
//  442     #endif
//  443 
//  444     #if defined(__MSP430_HAS_SD24_B__)
//  445     SD24BCTL0 = SD24SSEL__SMCLK     /* Clock is SMCLK */
//  446               | SD24PDIV_3          /* Divide by 16 => ADC clock: 1.048576MHz */
//  447               | SD24DIV0
//  448               | SD24REFS            /* Use internal reference */
//  449               | SD24OV32;
//  450     #else
//  451         #if defined(__MSP430_HAS_SD24_2__) || defined (__MSP430_HAS_SD24_3__) || defined (__MSP430_HAS_SD24_4__)
//  452     SD24CTL = SD24REFS;
//  453         #elif SD_CLOCK_DIVISION == 4
//  454     SD_CTL = SD_SSEL_1 | SD_DIV_2 | SD_REFON;
//  455         #elif SD_CLOCK_DIVISION == 8
//  456     SD_CTL = SD_SSEL_1 | SD_DIV_3 | SD_REFON;
//  457         #elif SD_CLOCK_DIVISION == 12
//  458     SD_CTL = SD_SSEL_1 | SD_XDIV_1 | SD16DIV_2 | SD_REFON;
//  459         #elif SD_CLOCK_DIVISION == 16
//  460     SD_CTL = SD_SSEL_1 | SD_XDIV_2 | SD_REFON;
//  461         #endif
//  462         #if defined(SD16CONF0_FUDGE)
//  463     SD16CONF0 = SD16CONF0_FUDGE;
//  464         #endif
//  465         #if defined(SD16CONF1_FUDGE)
//  466     SD16CONF1 = SD16CONF1_FUDGE;
//  467         #endif
//  468     #endif
//  469 
//  470     sd_set_limp_live_current_mode(PHASE_1_CURRENT_ADC_CHANNEL);
//  471     #if NUM_PHASES >= 2
//  472     sd_set_limp_live_current_mode(PHASE_2_CURRENT_ADC_CHANNEL);
//  473     #endif
//  474     #if NUM_PHASES >= 3
//  475     sd_set_limp_live_current_mode(PHASE_3_CURRENT_ADC_CHANNEL);
//  476     #endif
//  477     #if defined(NEUTRAL_MONITOR_SUPPORT)
//  478     sd_set_limp_neutral_current_mode(NEUTRAL_CURRENT_ADC_CHANNEL);
//  479     #endif
//  480 
//  481     sd_set_limp_voltage_mode(PHASE_1_VOLTAGE_ADC_CHANNEL);
//  482     #if NUM_PHASES >= 2
//  483     sd_set_limp_voltage_mode(PHASE_2_VOLTAGE_ADC_CHANNEL);
//  484     #endif
//  485     #if NUM_PHASES >= 3
//  486     sd_set_limp_voltage_mode(PHASE_3_VOLTAGE_ADC_CHANNEL);
//  487     #endif
//  488 
//  489     /* The three voltages are phase coincident. Only interrupt from one of them. */
//  490     #if defined(__MSP430_HAS_SD24_B__)
//  491     SD24BIE = 0x0007;
//  492     #else
//  493         #if NUM_PHASES >= 2
//  494     sd_xxxx_reg(SD_CCTL_, PHASE_1_CURRENT_ADC_CHANNEL) |= SD_IE;
//  495     sd_xxxx_reg(SD_CCTL_, PHASE_2_CURRENT_ADC_CHANNEL) |= SD_IE;
//  496         #endif
//  497         #if NUM_PHASES >= 3
//  498     sd_xxxx_reg(SD_CCTL_, PHASE_3_CURRENT_ADC_CHANNEL) |= SD_IE;
//  499         #endif
//  500     sd_xxxx_reg(SD_CCTL_, PHASE_1_VOLTAGE_ADC_CHANNEL) |= SD_IE;
//  501     #endif
//  502 
//  503     #if NUM_PHASES == 1
//  504     working_data.phases[0].metrology.current[0].in_phase_correction.sd_preloaded_offset = 0;
//  505         #if defined(NEUTRAL_MONITOR_SUPPORT)
//  506     working_data.phases[0].metrology.current[1].in_phase_correction.sd_preloaded_offset = 0;
//  507         #endif
//  508     #else
//  509     for (i = 0;  i < NUM_PHASES;  i++)
//  510         working_data.phases[i].metrology.current[0].in_phase_correction.sd_preloaded_offset = 0;
//  511     #endif
//  512 }
//  513 #endif
//  514 

        RSEG CODE:CODE:REORDER:NOROOT(1)
//  515 void metrology_disable_analog_front_end(void)
metrology_disable_analog_front_end:
          CFI Block cfiBlock1 Using cfiCommon0
          CFI Function metrology_disable_analog_front_end
//  516 {
//  517 #if NUM_PHASES > 1
//  518     int ph;
//  519 #endif
//  520 
//  521 #if NUM_PHASES > 1  &&  defined(__MSP430_HAS_SD24_B3__)  &&  defined(__MSP430_HAS_ADC10_A__)
//  522 #else
//  523     sd_set_idle_voltage_mode(PHASE_1_VOLTAGE_ADC_CHANNEL);
        MOV.B   #0x0, &0xb0
        MOV.W   #0x0, &0x102
        MOV.B   #0x0, &0xb8
//  524     #if !defined(VOLTAGE_SIGNAL_IS_COMMON)
//  525         #if NUM_PHASES >= 2
//  526     sd_set_idle_voltage_mode(PHASE_2_VOLTAGE_ADC_CHANNEL);
//  527         #endif
//  528         #if NUM_PHASES >= 3
//  529     sd_set_idle_voltage_mode(PHASE_3_VOLTAGE_ADC_CHANNEL);
//  530         #endif
//  531     #endif
//  532 #endif
//  533 
//  534     sd_set_idle_live_current_mode(PHASE_1_CURRENT_ADC_CHANNEL);
        MOV.B   #0x0, &0xb1
        MOV.W   #0x0, &0x104
        MOV.B   #0x0, &0xb9
//  535 #if NUM_PHASES >= 2
//  536     sd_set_idle_live_current_mode(PHASE_2_CURRENT_ADC_CHANNEL);
//  537 #endif
//  538 #if NUM_PHASES >= 3
//  539     sd_set_idle_live_current_mode(PHASE_3_CURRENT_ADC_CHANNEL);
//  540 #endif
//  541 #if NUM_PHASES >= 4
//  542     sd_set_idle_live_current_mode(PHASE_4_CURRENT_ADC_CHANNEL);
//  543 #endif
//  544 #if NUM_PHASES >= 5
//  545     sd_set_idle_live_current_mode(PHASE_5_CURRENT_ADC_CHANNEL);
//  546 #endif
//  547 #if NUM_PHASES >= 6
//  548     sd_set_idle_live_current_mode(PHASE_6_CURRENT_ADC_CHANNEL);
//  549 #endif
//  550 #if defined(NEUTRAL_MONITOR_SUPPORT)
//  551     sd_set_idle_live_current_mode(NEUTRAL_CURRENT_ADC_CHANNEL);
//  552 #endif
//  553 
//  554 #if defined(__MSP430_HAS_SD24_B__)
//  555     SD24BCTL0 = 0;
//  556 #else
//  557     SD_CTL = 0;
        MOV.W   #0x0, &0x100
//  558 #endif
//  559 
//  560 #if NUM_PHASES == 1
//  561     working_data.phases[0].metrology.current[0].in_phase_correction.sd_preloaded_offset = 0;
        MOV.W   #0x0, &working_data + 330
//  562     #if defined(NEUTRAL_MONITOR_SUPPORT)
//  563     working_data.phases[0].metrology.current[1].in_phase_correction.sd_preloaded_offset = 0;
//  564     #endif
//  565 #else
//  566     for (ph = 0;  ph < NUM_PHASES;  ph++)
//  567         working_data.phases[ph].metrology.current[0].in_phase_correction.sd_preloaded_offset = 0;
//  568 #endif
//  569 }
        RET
          CFI EndBlock cfiBlock1
        REQUIRE SD24INCTL0
        REQUIRE SD24CCTL0
        REQUIRE SD24PRE0
        REQUIRE SD24INCTL1
        REQUIRE SD24CCTL1
        REQUIRE SD24PRE1
        REQUIRE SD24CTL
//  570 

        RSEG CODE:CODE:REORDER:NOROOT(1)
//  571 int metrology_init_from_nv_data(void)
metrology_init_from_nv_data:
          CFI Block cfiBlock2 Using cfiCommon0
          CFI Function metrology_init_from_nv_data
//  572 {
//  573 #if NUM_PHASES > 1
//  574     int ph;
//  575     struct phase_parms_s *phase;
//  576     struct phase_calibration_data_s const *phase_cal;
//  577 
//  578     phase = working_data.phases;
//  579     phase_cal = cal_info->phases;
//  580     for (ph = 0;  ph < NUM_PHASES;  ph++, phase++, phase_cal++)
//  581 #endif
//  582     {
//  583         /* Prime the DC estimates for quick settling */
//  584 #if defined(LIMP_MODE_SUPPORT)
//  585         dc_filter_current_init(phase->metrology.current[0].I_dc_estimate[0], phase_cal->current[0].initial_dc_estimate[0]);
//  586         dc_filter_current_init(phase->metrology.current[0].I_dc_estimate[1], phase_cal->current[0].initial_dc_estimate[1]);
//  587         phase->metrology.current[0].I_endstops = ENDSTOP_HITS_FOR_OVERLOAD;
//  588     #if NUM_PHASES == 1  &&  defined(NEUTRAL_MONITOR_SUPPORT)
//  589         dc_filter_current_init(phase->metrology.current[1].I_dc_estimate[0], phase_cal->current[1].initial_dc_estimate[0]);
//  590         dc_filter_current_init(phase->metrology.current[1].I_dc_estimate[1], phase_cal->current[1].initial_dc_estimate[1]);
//  591         phase->metrology.current[1].I_endstops = ENDSTOP_HITS_FOR_OVERLOAD;
//  592     #endif
//  593         dc_filter_voltage_init(phase->metrology.V_dc_estimate[0], phase_cal->initial_v_dc_estimate[0]);
//  594         dc_filter_voltage_init(phase->metrology.V_dc_estimate[1], phase_cal->initial_v_dc_estimate[1]);
//  595 #else
//  596         dc_filter_current_init(phase->metrology.current[0].I_dc_estimate[0], phase_cal->current[0].initial_dc_estimate[0]);
        FUNCALL metrology_init_from_nv_data, dc_filter24_init
        LOCFRAME CSTACK, 2, STACK
        FUNCALL metrology_init_from_nv_data, dc_filter16_init
        LOCFRAME CSTACK, 2, STACK
        MOV.W   &nv_parms + 2, R14
        MOV.W   &nv_parms + 4, R15
        MOV.W   #working_data + 230, R12
        CALL    #dc_filter24_init
//  597         phase->metrology.current[0].I_endstops = ENDSTOP_HITS_FOR_OVERLOAD;
        MOV.B   #0x14, &working_data + 346
//  598     #if NUM_PHASES == 1  &&  defined(NEUTRAL_MONITOR_SUPPORT)
//  599         dc_filter_current_init(phase->metrology.current[1].I_dc_estimate[0], phase_cal->current[1].initial_dc_estimate[0]);
//  600         phase->metrology.current[1].I_endstops = ENDSTOP_HITS_FOR_OVERLOAD;
//  601     #endif
//  602         dc_filter_voltage_init(phase->metrology.V_dc_estimate[0], phase_cal->initial_v_dc_estimate[0]);
        MOV.W   &nv_parms + 16, R13
        MOV.W   #working_data + 78, R12
        CALL    #dc_filter16_init
//  603 #endif
//  604         phase->metrology.V_endstops = ENDSTOP_HITS_FOR_OVERLOAD;
        MOV.B   #0x14, &working_data + 358
//  605 #if defined(MAINS_FREQUENCY_SUPPORT)
//  606         phase->metrology.mains_period = ((SAMPLES_PER_10_SECONDS*6554)/MAINS_NOMINAL_FREQUENCY) << 8;
        MOV.W   #0x8000, &working_data + 350
        MOV.W   #0xa002, &working_data + 352
//  607 #endif
//  608     }
//  609 #if NUM_PHASES > 1  &&  defined(NEUTRAL_MONITOR_SUPPORT)
//  610     dc_filter_current_init(working_data.neutral.metrology.I_dc_estimate[0], cal_info->neutral.initial_dc_estimate[0]);
//  611     working_data.neutral.metrology.I_endstops = ENDSTOP_HITS_FOR_OVERLOAD;
//  612 #endif
//  613 
//  614 #if defined (WIRE_RESISTANCE_COMPENSATE)
//  615     resistance_scaling = ((64L * (uint32_t)(cal_info->phases[ph].initial_compensate_resistance[0]) * cal_info->phases[ph].current[0].I_rms_scale_factor[0]) / cal_info->phases[ph].V_rms_scale_factor[0]);
        PUSH.W  SR
          CFI CFA SP+4
        DINT
        NOP
        MOV.W   &nv_parms + 20, &0x130
        MOV.W   &nv_parms + 12, &0x138
        MOV.W   &0x13a, R12
        MOV.W   &0x13c, R13
        POP.W   SR
          CFI CFA SP+2
        CALL    #?ShiftLeft32_6
        MOV.W   &nv_parms + 26, R14
        MOV.W   #0x0, R15
        CALL    #?DivMod32u
        MOV.W   R12, &resistance_scaling
        MOV.W   R13, &resistance_scaling + 2
//  616 #endif
//  617 
//  618 #if defined (CAPACITOR_COMPENSATE_ON)
//  619     capacitance_scaling = ((uint32_t)(cal_info->phases[ph].initial_compensate_capacitance[0]) * cal_info->phases[ph].V_rms_scale_factor[0]) / ((uint32_t)(cal_info->phases[ph].current[0].I_rms_scale_factor[0]) * (64000 / SAMPLE_RATE));
        PUSH.W  SR
          CFI CFA SP+4
        DINT
        NOP
        MOV.W   &nv_parms + 18, &0x130
        MOV.W   &nv_parms + 26, &0x138
        MOV.W   &0x13a, R12
        MOV.W   &0x13c, R13
        POP.W   SR
          CFI CFA SP+2
        MOV.W   &nv_parms + 12, R14
        MOV.W   #0x0, R15
        RLA.W   R14
        RLC.W   R15
        RLA.W   R14
        RLC.W   R15
        RLA.W   R14
        RLC.W   R15
        CALL    #?DivMod32u
        MOV.W   R12, &capacitance_scaling
        MOV.W   R13, &capacitance_scaling + 2
//  620 #endif
//  621 
//  622 
//  623     return 0;
        MOV.W   #0x0, R12
        RET
          CFI EndBlock cfiBlock2
//  624 }
//  625 /*
//  626 int metrology_align_with_nv_data(void)
//  627 {
//  628 #if NUM_PHASES > 1
//  629     int ph;
//  630     static struct phase_parms_s *phase;
//  631     static struct phase_calibration_data_s const *phase_cal;
//  632 #endif
//  633 
//  634     metrology_disable_analog_front_end();
//  635     metrology_init_analog_front_end_normal_mode();
//  636 
//  637 #if NUM_PHASES > 1
//  638     phase = working_data.phases;
//  639     phase_cal = cal_info->phases;
//  640     for (ph = 0;  ph < NUM_PHASES;  ph++, phase++, phase_cal++)
//  641 #endif
//  642     {
//  643         set_sd_phase_correction(&phase->metrology.current[0].in_phase_correction, ph, phase_cal->current[0].phase_correction);
//  644     }
//  645 #if NUM_PHASES == 1  &&  defined(NEUTRAL_MONITOR_SUPPORT)
//  646         set_sd_phase_correction(&phase->metrology.current[1].in_phase_correction, NUM_PHASES, phase_cal->current[1].phase_correction);
//  647 #endif
//  648     return 0;
//  649 }
//  650 */

        RSEG CODE:CODE:REORDER:NOROOT(1)
//  651 void metrology_switch_to_normal_mode(void)
metrology_switch_to_normal_mode:
          CFI Block cfiBlock3 Using cfiCommon0
          CFI Function metrology_switch_to_normal_mode
//  652 {
//  653 #if NUM_PHASES > 1
//  654     int ph;
//  655     #if !defined(DYNAMIC_PHASE_CORRECTION_SUPPORT)
//  656     struct phase_parms_s *phase;
//  657     struct phase_calibration_data_s const *phase_cal;
//  658     #endif
//  659 #endif
//  660 
//  661     /* Switch to full speed, full power mode */
//  662     // metrology_state |= METROLOGY_STATUS_PHASE_VOLTAGE_OK; - removed by mars 20130204
//  663 
//  664 #if defined(__HAS_SD_ADC__)
//  665     #if defined(__MSP430_HAS_TA3__)
//  666     /* Disable the TIMER_A0 interrupt */
//  667     TACTL = 0;
        FUNCALL metrology_switch_to_normal_mode, metrology_init_analog_front_end_normal_mode
        LOCFRAME CSTACK, 2, STACK
        FUNCALL metrology_switch_to_normal_mode, set_sd_phase_correction
        LOCFRAME CSTACK, 2, STACK
        FUNCALL metrology_switch_to_normal_mode, switch_to_normal_mode
        LOCFRAME CSTACK, 2, STACK
        MOV.W   #0x0, &0x160
//  668     TACCTL0 = 0;
        MOV.W   #0x0, &0x162
//  669     #endif
//  670     __disable_interrupt();
        DINT
        NOP
//  671     metrology_init_analog_front_end_normal_mode();
        CALL    #metrology_init_analog_front_end_normal_mode
//  672 #endif
//  673 
//  674 //    samples_per_second = SAMPLES_PER_10_SECONDS/10;
//  675 
//  676     __enable_interrupt();
        EINT
//  677 
//  678 #if !defined(DYNAMIC_PHASE_CORRECTION_SUPPORT)
//  679     #if NUM_PHASES > 1
//  680     phase = working_data.phases;
//  681     phase_cal = cal_info->phases;
//  682     for (ph = 0;  ph < NUM_PHASES;  ph++, phase++, phase_cal++)
//  683     #endif
//  684     {
//  685     #if defined(__HAS_SD_ADC__)
//  686         set_sd_phase_correction(&phase->metrology.current[0].in_phase_correction, ph, phase_cal->current[0].phase_correction);
        MOV.W   &nv_parms + 10, R14
        MOV.W   #0x0, R13
        MOV.W   #working_data + 328, R12
        CALL    #set_sd_phase_correction
//  687         #if NUM_PHASES == 1  &&  defined(NEUTRAL_MONITOR_SUPPORT)
//  688         set_sd_phase_correction(&phase->metrology.current[1].in_phase_correction, NUM_PHASES, phase_cal->current[1].phase_correction);
//  689         #endif
//  690     #else
//  691         set_phase_correction(&phase->metrology.current[0].in_phase_correction, phase_cal->current[0].phase_correction);
//  692         #if NUM_PHASES == 1  &&  defined(NEUTRAL_MONITOR_SUPPORT)
//  693         set_phase_correction(&phase->metrology.current[1].in_phase_correction, phase_cal->current[1]phase_correction);
//  694         #endif
//  695     #endif
//  696     }
//  697     #if defined(__HAS_SD_ADC__)
//  698         #if NUM_PHASES > 1  &&  defined(NEUTRAL_MONITOR_SUPPORT)
//  699     set_sd_phase_correction(&working_data.neutral.metrology.in_phase_correction, NUM_PHASES, cal_info->neutral.phase_correction);
//  700         #endif
//  701     #endif
//  702 #endif
//  703     switch_to_normal_mode();
        CALL    #switch_to_normal_mode
//  704     operating_mode = OPERATING_MODE_NORMAL;
        MOV.B   #0x0, &operating_mode
//  705 #if defined(LIMP_MODE_SUPPORT)
//  706     normal_limp = 0;
//  707 #endif
//  708 }
        RET
          CFI EndBlock cfiBlock3
        REQUIRE TA0CTL
        REQUIRE TA0CCTL0
//  709 
//  710 #if defined(LIMP_MODE_SUPPORT)
//  711 void metrology_switch_to_limp_mode(void)
//  712 {
//  713     /* Switch to minimum consumption, current measurement only mode */
//  714     // metrology_state &= ~(METROLOGY_STATUS_REVERSED | METROLOGY_STATUS_PHASE_VOLTAGE_OK); - removed by mars 20130204
//  715 
//  716     #if defined(__HAS_SD_ADC__)
//  717         #if defined(__MSP430_HAS_TA3__)
//  718     /* Enable the TIMER_A0 interrupt */
//  719     TACTL = TACLR | MC_1 | TASSEL_1;
//  720     TACCTL0 = CCIE;
//  721         #endif
//  722     __disable_interrupt();
//  723     metrology_init_analog_front_end_limp_mode();
//  724     #endif
//  725 
//  726     samples_per_second = LIMP_SAMPLES_PER_10_SECONDS/10;
//  727 
//  728     __enable_interrupt();
//  729 
//  730     switch_to_limp_mode();
//  731     operating_mode = OPERATING_MODE_LIMP;
//  732     #if defined(LIMP_MODE_SUPPORT)
//  733     normal_limp = 1;
//  734     #endif
//  735 }
//  736 #endif
//  737 
//  738 #if defined(POWER_DOWN_SUPPORT)
//  739 void metrology_switch_to_powerfail_mode(void)
//  740 {
//  741     operating_mode = OPERATING_MODE_POWERFAIL;
//  742     #if defined(LIMP_MODE_SUPPORT)
//  743     normal_limp = 0;
//  744     #endif
//  745 
//  746     /* Note that a power down occured */
//  747     // metrology_state |= POWER_DOWN; - removed by mars 20130204
//  748 
//  749     // metrology_state &= ~(STATUS_REVERSED | STATUS_EARTHED | STATUS_PHASE_VOLTAGE_OK); - removed by mars 20130204
//  750     /* Turn off all the LEDs. */
//  751     #if defined(TOTAL_ACTIVE_ENERGY_SUPPORT)
//  752     total_active_energy_pulse_end();
//  753     #endif
//  754     #if defined(TOTAL_REACTIVE_ENERGY_SUPPORT)
//  755     total_reactive_energy_pulse_end();
//  756     #endif
//  757 
//  758     /* Make the EEPROM signals inputs, and rely on pullups. */
//  759     disable_eeprom_port();
//  760 
//  761     /* Shut down the LCD */
//  762     custom_lcd_sleep_handler();
//  763 
//  764     #if defined(__MSP430_HAS_TA3__)  &&  defined(__MSP430_SD_ADC__)
//  765     /* Disable the TIMER_A0 interrupt */
//  766     TACTL = 0;
//  767     TACCTL0 = 0;
//  768     /* Disable the interrupt routine which re-enables the ADC */
//  769     TACCTL2 = 0;
//  770     #endif
//  771 
//  772     #if defined(__HAS_SD_ADC__)
//  773     metrology_disable_analog_front_end();
//  774     #endif
//  775     #if defined(IEC1107_SUPPORT)  ||  defined(SERIAL_CALIBRATION_SUPPORT)  ||  defined(SERIAL_CALIBRATION_REF_SUPPORT)
//  776     /* Disable the serial port. */
//  777     U0ME &= ~(UTXE0 | URXE0);
//  778         #if defined(IEC1107_SUPPORT)
//  779     disable_ir_receiver();
//  780         #endif
//  781     #endif
//  782 
//  783     #if defined(BATTERY_MONITOR_SUPPORT)
//  784     /* Battery sensing control pin */
//  785     P3DIR &= ~(BIT1);
//  786     P3OUT |= (BIT1);
//  787     #endif
//  788 
//  789     #if defined(__MSP430_HAS_FLLPLUS__)  ||  defined(__MSP430_HAS_FLLPLUS_SMALL__)
//  790     /* Slow the clock to 1MHz as quickly as possible. The FLL will not be active
//  791        in LPM3, so switch it off now, and force the FLL's RC oscillator to
//  792        about 1MHz. The exact frequency is not critical. */
//  793     _BIS_SR(SCG0);                  /* switch off FLL locking */
//  794     SCFI0 = FLLD_1;
//  795     SCFQCTL = SCFI0_LOW | SCFQ_M;
//  796     SCFI0 = 0x00;
//  797     SCFI1 = 0x37;
//  798     #endif
//  799     #if defined(__MSP430_HAS_SVS__)
//  800     /* At 1MHz it is safe to turn off the SVS, and rely on the brownout
//  801        detector. Now the meter can survive on a very weak battery. */
//  802     SVSCTL = 0;
//  803     #endif
//  804 
//  805     /* ******************** LOW POWER STATE ************************** */
//  806     /* Go to LPM3 mode and exit only when power comes back on. The timer
//  807        interrupt that ticks every second should be checking for power
//  808        restored while we sit here. When it sees the unregulated supply
//  809        at a healthy voltage, it will wake us up. */
//  810     _BIS_SR(LPM3_bits);
//  811 
//  812     /* Waking up from power down mode */
//  813     #if defined(__MSP430_HAS_SVS__)
//  814     /* Before we go to high speed we need to make sure the supply voltage is 
//  815        adequate. If there is an SVS we can use that. There should be no wait
//  816        at this point, since we should only have been woken up if the supply
//  817        is healthy. However, it seems better to be cautious. */
//  818     SVSCTL |= 0x60;
//  819     /* Wait for adequate voltage to run at full speed */
//  820     while (!(SVSCTL & SVSON))
//  821         /* dummy loop */;
//  822     while ((SVSCTL & SVSOP))
//  823         /* dummy loop */;
//  824     /* The voltage should now be OK to run the CPU at full speed. Now it should
//  825        be OK to use the SVS as a reset source. */
//  826     SVSCTL |= PORON;
//  827     #endif
//  828 
//  829     #if defined(__MSP430_HAS_FLLPLUS__)  ||  defined(__MSP430_HAS_FLLPLUS_SMALL__)
//  830     /* Speed up the clock to high speed. */
//  831     SCFI0 = FN_3 | FLLD_4;
//  832     SCFQCTL = SCFQCTL_HIGH;
//  833     /* There seems no good reason to wait until the FLL has settled at this point. */
//  834     #endif
//  835 
//  836     /* Take control of the EEPROM signals again. */
//  837     enable_eeprom_port();
//  838 
//  839     /* Enable the serial port */
//  840     #if defined(IEC1107_SUPPORT)  ||  defined(SERIAL_CALIBRATION_SUPPORT)  ||  defined(SERIAL_CALIBRATION_REF_SUPPORT)
//  841         #if defined(SERIAL_CALIBRATION_REF_SUPPORT)
//  842     U0ME |= (UTXE0 | URXE0);
//  843         #elif defined(SERIAL_CALIBRATION_SUPPORT)
//  844     U0ME |= URXE0;
//  845         #else
//  846     U0ME |= UTXE0;
//  847         #endif
//  848     #endif
//  849 
//  850     #if defined(__MSP430_HAS_TA3__)  &&  defined(__HAS_SD_ADC__)
//  851     /* Enable the TIMER_A0 interrupt */
//  852     TACTL = TACLR | MC_1 | TASSEL_1;
//  853     TACCTL0 = CCIE;
//  854     #endif
//  855 
//  856     kick_watchdog();
//  857     #if defined(LOSE_FRACTIONAL_PULSE_AT_POWER_ON)
//  858         #if defined(TOTAL_ACTIVE_ENERGY_PULSES_PER_KW_HOUR)
//  859     totals.energy.active_energy_pulse.energy_integrator = 0;
//  860         #endif
//  861         #if defined(TOTAL_REACTIVE_ENERGY_PULSES_PER_KVAR_HOUR)
//  862     totals.energy.reactive_energy_pulse.energy_integrator = 0;
//  863         #endif
//  864     #endif
//  865 
//  866     /* Come out of power down in limp mode, as we don't know
//  867        if there is sufficent power available to driver the meter
//  868        at full speed. We will soon switch to normal mode if a
//  869        voltage signal is available. */
//  870     /* Limp mode will fire up the ADC again. */
//  871     #if defined(LIMP_MODE_SUPPORT)
//  872     switch_to_limp_mode();
//  873     #else
//  874     switch_to_normal_mode();
//  875     #endif
//  876 }
//  877 #endif
//  878 

        RSEG CODE:CODE:REORDER:NOROOT(1)
//  879 int metrology_init(void)
metrology_init:
          CFI Block cfiBlock4 Using cfiCommon0
          CFI Function metrology_init
//  880 {
//  881     /* There should always be a power scaling factor for the first current sensor channel of the
//  882        first phase, whatever type of metrology is being built, and that factor should not be
//  883        0xFFFF. */
//  884     if (cal_info->phases[0].current[0].P_scale_factor == 0xFFFF)
        FUNCALL metrology_init, flash_memcpy
        LOCFRAME CSTACK, 2, STACK
        FUNCALL metrology_init, flash_secure
        LOCFRAME CSTACK, 2, STACK
        CMP.W   #0xffff, &nv_parms + 14
        JNE     ??metrology_init_0
//  885     {
//  886         flash_memcpy((void *) cal_info, (const void *) &calibration_defaults, sizeof(calibration_defaults));
        MOV.W   #0x20, R14
        MOV.W   #calibration_defaults, R13
        MOV.W   #nv_parms + 2, R12
        CALL    #flash_memcpy
//  887         flash_secure();
        CALL    #flash_secure
//  888         return 0xffff;
        MOV.W   #0xffff, R12
        RET
//  889     }
//  890     // metrology_state = 0; - removed by mars 20130204
//  891     return 0;
??metrology_init_0:
        MOV.W   #0x0, R12
        RET
          CFI EndBlock cfiBlock4
//  892 }

        RSEG CODE:CODE:REORDER:NOROOT(1)
?setjmp_save_r4:
        REQUIRE ?setjmp_r4
        REQUIRE ?longjmp_r4

        RSEG CODE:CODE:REORDER:NOROOT(1)
?setjmp_save_r5:
        REQUIRE ?setjmp_r5
        REQUIRE ?longjmp_r5

        END
// 
// 360 bytes in segment CODE
//  18 bytes in segment DATA16_AN
// 
// 360 bytes of CODE memory
//   0 bytes of DATA memory (+ 18 bytes shared)
//
//Errors: none
//Warnings: none
